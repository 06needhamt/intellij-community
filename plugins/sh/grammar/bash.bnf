{
  generate = [ token-accessors="yes" ]

  parserClass="com.intellij.bash.parser.BashParser"
  parserUtilClass="com.intellij.bash.parser.BashParserUtil"

  implements="com.intellij.bash.psi.BashCompositeElement"
  extends="com.intellij.bash.psi.impl.BashCompositeElementImpl"

  elementTypeHolderClass="com.intellij.bash.BashTypes"
  elementTypeClass="com.intellij.bash.psi.BashCompositeElementType"
  tokenTypeClass="com.intellij.bash.psi.BashTokenType"

  psiClassPrefix="Bash"
  psiImplClassSuffix="Impl"
  psiPackage="com.intellij.bash.psi"
  psiImplPackage="com.intellij.bash.psi.impl"

  tokens = [
    DOLLAR = '$'
    LEFT_PAREN = '('
    RIGHT_PAREN = ')'
    LEFT_CURLY = '{'
    RIGHT_CURLY = '}'
    LEFT_SQUARE = '['
    RIGHT_SQUARE = ']'
    BANG = '!'

    BACKSLASH = '\\'
    AMP = '&'
    AT = '@'
    COLON = ':'
    COMMA = ','
    EQ = '='
    ADD_EQ = '+='
    SEMI = ';'
    SHIFT_RIGHT = '>>'
    LESS_THAN = '<'
    GREATER_THAN = '>'
    PIPE = '|'
    PIPE_AMP = '|&' //bash 4 only, equivalent to 2>&1 |
    AND_AND = '&&'
    OR_OR = '||'

    EXPONENT = '**'
    MULT = '*'
    DIV = '/'
    MOD = '%'
    SHIFT_LEFT = '<<'
    SHIFT_RIGHT = '>>'

    LINEFEED = '\n'
    CASE_END = ';;'

    ARITH_LE = '<='
    ARITH_GE = '>='
    ARITH_GT = 'arith >'
    ARITH_LT = 'arith <'
    ARITH_PLUS_PLUS = "++"
    ARITH_PLUS = "+"
    ARITH_MINUS_MINUS = "--"
    ARITH_MINUS = "-"

    REDIRECT_HERE_STRING = "<<<"
    REDIRECT_LESS_AMP = "<&"
    REDIRECT_GREATER_AMP = ">&"
    REDIRECT_LESS_GREATER = "<>"
    REDIRECT_GREATER_BAR = ">|"
  ]

  pin('.*list(?:_\d.*)?')=1
  pin('.*_command')=1
  extends(".*command")=command
}

private file ::=
  shebang? newlines
  simple_list

private newlines ::= '\n'*
private simple_list ::= (commands_list ['&' | ';' | newlines])*
private word_list ::= w+
private w ::= word | variable | string | num

redirection ::=    '>' w
                |  '<' w
                |  num '>' w
                |  num '<' w
                |  '>>' w
                |  num '>>' w
                |  '<<' w
                |  num '<<' w
                |  '<&' num
                |  num '<&' num
                |  '>&' num
                |  num '>&' num
                |  '<&' w
                |  num '<&' w
                |  '>&' w
                |  num '>&' w
                |  '<<-' w
                |  num '<<-' w
                |  '>&' '-'
                |  num '>&' '-'
                |  '<&' '-'
                |  num '<&' '-'
                |  '&>' w
                |  num '<>' w
                |  '<>' w
                |  '>|' w
                |  num '>|' w

private num ::= number | int
string ::= string_begin (string_content|variable)* string_end
private literal ::= w | string | num
simple_command_element ::= literal | assignment_word_rule | redirection
assignment_word_rule ::= assignment_word '=' literal

redirection_list ::= redirection redirection*
simple_command ::= simple_command_element+
command ::= simple_command | shell_command redirection_list?

shell_command ::=   for_command
                  | case_command
                  | while_command
                  | until_command
                  | select_command
                  | if_command
                  | subshell
                  | group_command
                  | function_def

while_command ::= while compound_list do compound_list done
until_command ::= until compound_list do compound_list done

for_command ::= for w (newlines in_clause? block | ';' newlines block)

private in_clause ::= "in" word_list list_terminator newlines {pin=1}

private block ::= '{' compound_list '}' | do compound_list done {pin(".*")=1}

select_command ::= select w (';'? newlines block | newlines in_clause block)

case_command ::= case w newlines "in" (case_clause_list newlines) esac {pin(".*")=1}

function_def ::=  w '(' ')' newlines group_command
                 |  function w '(' ')' newlines group_command
                 |  function w newlines group_command

subshell ::=  '(' compound_list ')'

if_command ::= if compound_list then compound_list (fi |
               else compound_list fi |
               elif_clause fi)

group_command ::= '{' list '}'

elif_clause ::= elif compound_list then compound_list |
                elif compound_list then compound_list else compound_list |
                elif compound_list then compound_list elif_clause

case_clause ::= pattern_list

pattern_list ::=   newlines pattern ')' compound_list
                 | newlines pattern ')' newlines
                 | newlines '(' pattern ')' compound_list
                 | newlines '(' pattern ')' newlines {pin=0}

private case_clause_list ::= (case_clause ';;')+

pattern ::=  w ('|' w)* {pin('.*')=1}

compound_list ::= '\n'+ list
list ::= newlines pipeline_command_list ('\n' | '&' | ';') newlines {pin=2}

private pipeline_command_list ::= pipeline_command (pipeline_command_list_separator pipeline_command)* {pin=1} // todo with pin
private pipeline_command_list_separator ::= ('&&'|  '||' |  '&' |  ';' |  '\n') newlines

list_terminator ::= '\n' | ';'

commands_list ::= pipeline_command (
                     '&&' newlines pipeline_command
                   | '||' newlines pipeline_command
                   | '&' pipeline_command
                   | ';' pipeline_command
                 )*

pipeline_command ::=  '!'? pipeline
                    | timespec '!'? pipeline
                    | '!' timespec pipeline

pipeline ::= command ('|' newlines command)* {pin(".*")=1}

time_opt ::= '-p'
timespec ::= time time_opt?
