//noinspection BnfSuspiciousTokenForFile
{
  generate = [ token-accessors="yes" ]

  parserClass="com.intellij.bash.parser.BashParser"
  parserUtilClass="com.intellij.bash.parser.BashParserUtil"

  implements="com.intellij.bash.psi.BashCompositeElement"
  extends="com.intellij.bash.psi.impl.BashCompositeElementImpl"

  elementTypeHolderClass="com.intellij.bash.BashTypes"
  elementTypeClass="com.intellij.bash.psi.BashCompositeElementType"
  tokenTypeClass="com.intellij.bash.psi.BashTokenType"

  psiClassPrefix="Bash"
  psiImplClassSuffix="Impl"
  psiPackage="com.intellij.bash.psi"
  psiImplPackage="com.intellij.bash.psi.impl"

  psiImplUtilClass="com.intellij.bash.psi.impl.BashPsiImplUtil"

  tokens = [
    // Arithmetic operations
    MULT_ASSIGN         = '*='
    DIV_ASSIGN          = '/='
    MOD_ASSIGN          = '%='
    PLUS_ASSIGN         = '+='
    MINUS_ASSIGN        = '-='
    SHIFT_RIGHT_ASSIGN  = '>>='
    SHIFT_LEFT_ASSIGN   = '<<='
    BIT_AND_ASSIGN      = '&='
    BIT_OR_ASSIGN       = '|='
    BIT_XOR_ASSIGN      = '^='
    NE                  = '!='
    EQ                  = '=='
    LE                  = '<='
    GE                  = '>='

    PLUS_PLUS           = "++"
    MINUS_MINUS         = "--"
    EXPONENT            = '**'

    BITWISE_NEGATION    = '~'
    BANG                = '!'
    PLUS                = "+"
    MINUS               = "-"
    MULT                = '*'
    DIV                 = '/'
    MOD                 = '%'

    SHIFT_LEFT          = '<<'
    SHIFT_RIGHT         = '>>'
    LT                  = '<'
    GT                  = '>'

    AND_AND             = '&&'
    OR_OR               = '||'
    AMP                 = '&'
    XOR                 = '^'
    PIPE                = '|'

    QMARK               = '?'
    COLON               = ':'
    COMMA               = ','

    //Conditional operations
    REGEXP              = '=~'

    DOLLAR = '$'
    LEFT_PAREN = '('
    RIGHT_PAREN = ')'
    LEFT_CURLY = '{'
    RIGHT_CURLY = '}'
    LEFT_SQUARE = '['
    RIGHT_SQUARE = ']'
    BACKQUOTE = '`'
    QUOTE = '"'

    EXPR_CONDITIONAL_LEFT = "[ "
    EXPR_CONDITIONAL_RIGHT = " ]"
    LEFT_DOUBLE_BRACKET = "[["
    RIGHT_DOUBLE_BRACKET = "]]"

    BACKSLASH = '\\'
    AT = '@'
    ASSIGN = '='
    SEMI = ';'
    PIPE_AMP = '|&' //bash 4 only, equivalent to 2>&1 |

    LINEFEED = '\n'
    CASE_END = ';;'

    LEFT_DOUBLE_PAREN = '(('
    RIGHT_DOUBLE_PAREN = '))'

    REDIRECT_HERE_STRING = "<<<"
    REDIRECT_LESS_AMP = "<&"
    REDIRECT_GREATER_AMP = ">&"
    REDIRECT_LESS_GREATER = "<>"
    REDIRECT_GREATER_BAR = ">|"

    FILEDESCRIPTOR='file descriptor'

    PARAMETER_EXPANSION_BODY='parameter expansion body'
  ]

  pin('.*list(?:_\d.*)?')=1
  pin('.*_(command|clause)')=1
  extends(".*command")=command

  extends("(comma|assignment|conditional|logical_or|logical_and|bitwise_or|bitwise_exclusive_or|bitwise_and|equality|comparison|bitwise_shift|add|mul|exp)_expression")=binary_expression
  extends(".*expression")=expression
}

private file ::=
  shebang? newlines
  simple_list

private newlines ::= '\n'*
private simple_list ::= (commands_list ['&' | ';' | newlines])*
private word_list ::= w+
private w ::= word | '@' | '!' | vars | '$' | string | num | bash_expansion | 'file descriptor'

redirection ::= redirection_inner | '&>' w | num redirection_inner
private redirection_inner ::= ('<&' | '>&') (num | '-')
                            | ('>' | '<' | '>>' | '<<' | '<<<' | '<&' | '>&' | '<<-' | '<>' | '>|') w

private num ::= number | int | hex | octal
string ::= ('"' (word | vars | <<notQuote>>)* '"') | RAW_STRING {
  pin(".*")=1
  methods=[getReferences]
}

variable ::= var
private vars ::= variable | composed_var | command_substitution_command
private composed_var ::= '$' &('(' | '((' | '{' | ARITH_SQUARE_LEFT) composed_var_inner {pin=2}
private composed_var_inner ::= arithmetic_expansion | old_arithmetic_expansion | command_substitution | shell_parameter_expansion
private command_substitution ::= subshell_command // todo: rethink naming with command_substitution_command
shell_parameter_expansion ::= '{' parameter_expansion_body (composed_var parameter_expansion_body?)* '}' {pin=1}
bash_expansion ::= '{' (word | bash_expansion)* '}'

command_substitution_command ::= !<<isModeOn "BACKQUOTE">> '`' <<withOn "BACKQUOTE" list?>> '`' {pin=2}

conditional_command ::= cond_left (<<condOp>> | lit | vars)* cond_right {pin(".*")=1}
private cond_right ::= ']' | ']]'
private cond_left ::= '[' | '[['
private lit ::= literal | '(' lit ')' {pin(".*")=1}

process_substitution ::= ('<' | '>') '(' compound_list ')' {pin=1}

private literal ::= w | string | num
simple_command_element ::= simple_command_element_inner
private simple_command_element_inner ::=  assignment_command
                                        | literal
                                        | redirection
                                        | composed_var
                                        | heredoc
                                        | conditional_command
                                        | command_substitution_command
                                        | arithmetic_expansion
                                        | old_arithmetic_expansion

assignment_list ::= '(' (<<backslash>> | array_assignment)* ')'
array_assignment ::= newlines '='? expression newlines

heredoc ::= HEREDOC_MARKER_TAG HEREDOC_MARKER_START ['|'? commands_list] newlines
            (HEREDOC_CONTENT)*
            (HEREDOC_MARKER_END | HEREDOC_MARKER_IGNORING_TABS_END | <<eof>>)
arithmetic_expansion ::= '((' expression '))' {pin=1}
old_arithmetic_expansion ::= ARITH_SQUARE_LEFT old_arithmetic_expansion_expression ARITH_SQUARE_RIGHT {pin=1 extends=arithmetic_expansion}
private old_arithmetic_expansion_expression ::= expression {pin=1 recoverWhile=old_arithmetic_expansion_expression_recover}
private old_arithmetic_expansion_expression_recover ::= !(ARITH_SQUARE_RIGHT)
assignment_command ::= (w | variable) array_expression? ('='|"+=") [assignment_list | <<parseUntilSpace (literal | composed_var)>>]
                       {'=' <<parseUntilSpace literal >>}* {pin=0}

redirection_list ::= redirection redirection*
simple_command ::= generic_command_directive (simple_command_element | <<keywordsRemapped>>)* {
  pin=1
  methods=[getReferences]
}
generic_command_directive ::= simple_command_element_inner {extends=simple_command}

command ::= shell_command redirection_list?
          | include_command
          | simple_command {recoverWhile=command_recover}

include_command ::= include_directive (simple_command_element | <<keywordsRemapped>>)*
include_directive ::= &('source' | '.') word {extends=generic_command_directive}

private command_recover ::= !('!' | '!=' | '$' | '%' | '%=' | '&&' | '&' | '&=' | '&>' | '(' | '((' | ')' | '))' | '*' | '**' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '/' | '/=' | ':' | ';' | ';;' | '<&' | '<' | '<<' | '<<-' | '<<<' | '<<=' | '<=' | '<>' | '=' | '==' | '>' | '>&' | '>=' | '>>' | '>>=' | '>|' | '?' | '@' | '[' | '[[' | '\n' | ']' | ']]' | '^' | '^=' | '`' | 'in' | '{' | '|' | '|=' | '||' | '}' | '~' | ARITH_SQUARE_RIGHT | EXPR_CONDITIONAL_LEFT | EXPR_CONDITIONAL_RIGHT | FILEDESCRIPTOR | HEREDOC_CONTENT | HEREDOC_MARKER_END | HEREDOC_MARKER_IGNORING_TABS_END | HEREDOC_MARKER_TAG | RAW_STRING | case | do | elif | else | esac | fi | for | function | hex | if | int | number | octal | select | string_begin | string_content | string_end | then | time | trap | until | var | while | word)

shell_command ::=   for_command
                  | case_command
                  | while_command
                  | until_command
                  | select_command
                  | if_command
                  | subshell_command
                  | block
                  | function_def {recoverWhile=command_recover}

while_command ::= while compound_list do_block
until_command ::= until compound_list do_block

for_command ::= for for_clause for_tail {pin=1}
for_clause ::= arithmetic_for_clause | in_for_clause
private in_for_clause ::= w (';' newlines | newlines in_clause?)
private arithmetic_for_clause ::= '((' expression? ';' expression? ';' expression? '))' {pin=1}
private for_tail ::= [list_terminator newlines] any_block

private in_clause ::= "in" word_list list_terminator newlines {pin=1}

private any_block ::= block | do_block
do_block ::= do  compound_list done {pin(".*")=1 extends=block}
block    ::= '{' compound_list '}'  {pin(".*")=1 extends=command}

select_command ::= select w (';'? newlines any_block | newlines in_clause any_block)

case_command ::= case w newlines "in" case_clause_list newlines esac {pin(".*")=1}

function_def ::=           word argument_list  newlines block
                | function word argument_list? newlines block {pin(".*")="function|argument_list" extends=command}
private argument_list ::= '(' ')'

subshell_command ::= '(' list ')' {pin=1}

if_command ::= if compound_list then_clause
               elif_clause*
               else_clause?
               fi

elif_clause ::= elif compound_list then_clause
else_clause ::= else compound_list
then_clause ::= then compound_list

private case_clause_list ::= case_clause (';;' (case_clause | &(esac|newlines)))+ {pin(".*")=1}
case_clause ::= newlines '('? pattern ')' (compound_case_list|newlines) {pin=3}

pattern ::= w+ ('|' w+)* {pin('.*')=1}

compound_case_list ::= (nl pipeline_command_list?| pipeline_command_list) end_of_list? newlines {pin(".*")=1 elementType=compound_list}
compound_list      ::= (nl pipeline_command_list | pipeline_command_list) end_of_list  newlines {pin(".*")=1}
list               ::= (nl pipeline_command_list | pipeline_command_list) end_of_list? newlines {pin(".*")=1 elementType=compound_list}
private nl ::= '\n'+
private end_of_list ::= '\n' | ';' | '&'

private pipeline_command_list ::= pipeline_command (pipeline_command_list_separator pipeline_command)* {
  pin=1
  recoverWhile=command_recover
} // todo with pin
private pipeline_command_list_separator ::= ('&&'|  '||' |  '&' |  ';' |  '\n') newlines

list_terminator ::= '\n' | ';'

commands_list ::= pipeline_command (
                     '&&' newlines? pipeline_command
                   | '||' newlines? pipeline_command
                   | '&' pipeline_command?
                   | ';' pipeline_command?
                 )*

pipeline_command ::=  '!'? pipeline
                    | timespec '!'? pipeline
                    | '!' timespec pipeline
                    | trap_command
                    | let_command

let_command ::= let expression

pipeline ::= command ('|' newlines command)* {pin(".*")=1}

time_opt ::= '-p'
timespec ::= time time_opt?

trap_command ::= trap literal*

expression ::=
    comma_expression
  | assignment_expression
  | conditional_expression
  | logical_or_expression
  | logical_and_expression
  | bitwise_or_expression
  | bitwise_exclusive_or_expression
  | bitwise_and_expression
  | equality_expression
  | comparison_expression
  | bitwise_shift_expression
  | add_expression
  | mul_expression
  | exp_expression
  | logical_bitwise_negation_expression
  | unary_expression
  | pre_expression
  | post_expression
  | index_expression
  | array_expression
  | literal_expression
  | parentheses_expression

comma_expression ::= expression ',' expression
assignment_expression ::= expression ('=' |'*=' |'/=' |'%=' |'+=' |'-=' |'<<=' |'>>=' |'&=' |'^=' |'|=') expression
conditional_expression ::= expression '?' expression ':' expression
logical_or_expression ::= expression '||' expression
logical_and_expression ::= expression '&&' expression
bitwise_or_expression ::= expression '|' expression
bitwise_exclusive_or_expression ::= expression '^' expression
bitwise_and_expression ::= expression '&' expression
equality_expression ::= expression ('==' | '!=') expression
comparison_expression ::= expression ('<=' | '>=' | '<' | '>') expression
bitwise_shift_expression ::= expression ('<<' | '>>') expression
add_expression ::= expression ('+' | '-') expression
mul_expression ::= expression ('*' | '/' | '%') expression
exp_expression ::= expression '**' expression
fake binary_expression ::= expression+ { methods=[left="expression[0]" right="expression[1]"] }

logical_bitwise_negation_expression ::= ('!' | '~') expression
unary_expression ::= ('-' | '+') expression
pre_expression ::= ('--' | '++') expression
post_expression ::= expression ('--' | '++')
index_expression ::= expression '[' expression ']'
array_expression ::= '[' expression ']'
parentheses_expression ::= '(' expression ')' {pin=1}

literal_expression ::= literal