//noinspection BnfSuspiciousTokenForFile
{
  generate = [ token-accessors="yes" ]

  parserClass="com.intellij.bash.parser.BashParser"
  parserUtilClass="com.intellij.bash.parser.BashParserUtil"

  implements="com.intellij.bash.psi.BashCompositeElement"
  extends="com.intellij.bash.psi.impl.BashCompositeElementImpl"

  elementTypeHolderClass="com.intellij.bash.BashTypes"
  elementTypeClass="com.intellij.bash.psi.BashCompositeElementType"
  tokenTypeClass="com.intellij.bash.psi.BashTokenType"

  psiClassPrefix="Bash"
  psiImplClassSuffix="Impl"
  psiPackage="com.intellij.bash.psi"
  psiImplPackage="com.intellij.bash.psi.impl"

  tokens = [
    DOLLAR = '$'
    LEFT_PAREN = '('
    RIGHT_PAREN = ')'
    LEFT_CURLY = '{'
    RIGHT_CURLY = '}'
    LEFT_SQUARE = '['
    RIGHT_SQUARE = ']'
    BANG = '!'

    LEFT_DOUBLE_BRACKET = "[["
    RIGHT_DOUBLE_BRACKET = "]]"

    BACKSLASH = '\\'
    AMP = '&'
    AT = '@'
    COLON = ':'
    COMMA = ','
    EQ = '='
    ADD_EQ = '+='
    SEMI = ';'
    SHIFT_RIGHT = '>>'
    LESS_THAN = '<'
    GREATER_THAN = '>'
    PIPE = '|'
    PIPE_AMP = '|&' //bash 4 only, equivalent to 2>&1 |
    AND_AND = '&&'
    OR_OR = '||'

    EXPONENT = '**'
    MULT = '*'
    DIV = '/'
    MOD = '%'
    SHIFT_LEFT = '<<'
    SHIFT_RIGHT = '>>'

    LINEFEED = '\n'
    CASE_END = ';;'

    ARITH_LE = '<='
    ARITH_GE = '>='
    ARITH_GT = 'arith >'
    ARITH_LT = 'arith <'
    ARITH_PLUS_PLUS = "++"
    ARITH_PLUS = "+"
    ARITH_MINUS_MINUS = "--"
    ARITH_MINUS = "-"

    REDIRECT_HERE_STRING = "<<<"
    REDIRECT_LESS_AMP = "<&"
    REDIRECT_GREATER_AMP = ">&"
    REDIRECT_LESS_GREATER = "<>"
    REDIRECT_GREATER_BAR = ">|"
  ]

  pin('.*list(?:_\d.*)?')=1
  pin('.*_command')=1
  extends(".*command")=command

  extends("(comma|assignment|conditional|logical_or|logical_and|bitwise_or|bitwise_exclusive_or|bitwise_and|equality|comparison|bitwise_shift|add|mul|exp)_expression")=binary_expression
  extends(".*expression")=expression
}

private file ::=
  shebang? newlines
  simple_list

private newlines ::= '\n'*
private simple_list ::= (commands_list ['&' | ';' | newlines])*
private word_list ::= w+
private w ::= word | variable | string | num

redirection ::=    '>' w
                |  '<' w
                |  num '>' w
                |  num '<' w
                |  '>>' w
                |  num '>>' w
                |  '<<' w
                |  num '<<' w
                |  '<&' num
                |  num '<&' num
                |  '>&' num
                |  num '>&' num
                |  '<&' w
                |  num '<&' w
                |  '>&' w
                |  num '>&' w
                |  '<<-' w
                |  num '<<-' w
                |  '>&' '-'
                |  num '>&' '-'
                |  '<&' '-'
                |  num '<&' '-'
                |  '&>' w
                |  num '<>' w
                |  '<>' w
                |  '>|' w
                |  num '>|' w

private num ::= number | int
string ::= (string_begin (string_content|vars)* string_end) | STRING2

private vars ::= variable | composed_var
private composed_var ::= '$' (arithmetic_expansion|command_substitution|shell_parameter_expansion)
private command_substitution ::= subshell
shell_parameter_expansion ::= '{' literal [":" ['+'|'-'] literal] '}' // todo: simplify lexer for parameters
bash_expansion ::=

conditional_command ::= cond_left [literal? <<condOp>> literal] cond_right {pin=1}
private cond_right ::= EXPR_CONDITIONAL_RIGHT | ']]'
private cond_left ::= EXPR_CONDITIONAL_LEFT | '[['

process_substitution ::= ('<' | '>') '(' compound_list ')' {pin=1}

private literal ::= w | string | num
simple_command_element ::= assignment_word_rule | literal | redirection | composed_var | heredoc | conditional_command
heredoc ::= HEREDOC_MARKER_TAG HEREDOC_MARKER_START newlines HEREDOC_CONTENT HEREDOC_MARKER_END
arithmetic_expansion ::= '((' expression '))' {pin=1}
assignment_word_rule ::= (assignment_word | word) '=' [literal | composed_var]

redirection_list ::= redirection redirection*
simple_command ::= simple_command_element+
command ::= simple_command | shell_command redirection_list?

shell_command ::=   for_command
                  | case_command
                  | while_command
                  | until_command
                  | select_command
                  | if_command
                  | subshell
                  | group_command
                  | function_def

while_command ::= while compound_list do_block
until_command ::= until compound_list do_block

for_command ::= for (
                    w (newlines in_clause? block | ';' newlines block)
                  | arithmetic_for
                  )
private arithmetic_for ::= '((' expression ';' expression ';' expression '))' [list_terminator newlines] block {pin=1}

private in_clause ::= "in" word_list list_terminator newlines {pin=1}

block ::= '{' compound_list '}' | do_block {pin(".*")=1}
do_block ::= do compound_list done {extends=block pin(".*")=1}

select_command ::= select w (';'? newlines block | newlines in_clause block)

case_command ::= case w newlines "in" (case_clause_list newlines) esac {pin(".*")=1}

function_def ::=  w '(' ')' newlines group_command
                 |  function w '(' ')' newlines group_command
                 |  function w newlines group_command

subshell ::=  '(' list ')' {pin=1}

if_command ::= if compound_list then compound_list
               (   fi
                 | else compound_list fi
                 | elif_clause fi) {pin(".*")="if|elif|then|else"}

group_command ::= '{' compound_list '}'

elif_clause ::= elif compound_list then compound_list |
                elif compound_list then compound_list else compound_list |
                elif compound_list then compound_list elif_clause {pin(".*")="elif|then|else"}

case_clause ::= pattern_list

pattern_list ::=   newlines pattern ')' compound_list
                 | newlines pattern ')' newlines
                 | newlines '(' pattern ')' compound_list
                 | newlines '(' pattern ')' newlines {pin=0}

private case_clause_list ::= (case_clause ';;')+

pattern ::=  w ('|' w)* {pin('.*')=1}

compound_list ::= newlines pipeline_command_list end_of_list  newlines {pin=2}
list ::=          newlines pipeline_command_list end_of_list? newlines {pin=2 elementType=compound_list}
private end_of_list ::= '\n' | ';' | '&'

private pipeline_command_list ::= pipeline_command (pipeline_command_list_separator pipeline_command)* {pin=1} // todo with pin
private pipeline_command_list_separator ::= ('&&'|  '||' |  '&' |  ';' |  '\n') newlines

list_terminator ::= '\n' | ';'

commands_list ::= pipeline_command (
                     '&&' newlines pipeline_command
                   | '||' newlines pipeline_command
                   | '&' pipeline_command
                   | ';' pipeline_command?
                 )*

pipeline_command ::=  '!'? pipeline
                    | timespec '!'? pipeline
                    | '!' timespec pipeline

pipeline ::= command ('|' newlines command)* {pin(".*")=1}

time_opt ::= '-p'
timespec ::= time time_opt?

expression ::=
    comma_expression
  | assignment_expression
  | conditional_expression
  | logical_or_expression
  | logical_and_expression
  | bitwise_or_expression
  | bitwise_exclusive_or_expression
  | bitwise_and_expression
  | equality_expression
  | comparison_expression
  | bitwise_shift_expression
  | add_expression
  | mul_expression
  | exp_expression
  | logical_bitwise_negation_expression
  | unary_expression
  | pre_expression
  | post_expression
  | literal_expression
  | parentheses_expression

comma_expression ::= expression ',' expression
assignment_expression ::= expression ('=' |'*=' |'/=' |'%=' |'+=' |'-=' |'<<=' |'>>=' |'&=' |'^=' |'|=') expression
conditional_expression ::= expression '?' expression ':' expression
logical_or_expression ::= expression '||' expression
logical_and_expression ::= expression '&&' expression
bitwise_or_expression ::= expression '|' expression
bitwise_exclusive_or_expression ::= expression '^' expression
bitwise_and_expression ::= expression '&' expression
equality_expression ::= expression ('==' | '!=') expression
comparison_expression ::= expression ('<=' | '>=' | '<' | '>') expression
bitwise_shift_expression ::= expression ('<<' | '>>') expression
add_expression ::= expression ('+' | '-') expression
mul_expression ::= expression ('*' | '/' | '%') expression
exp_expression ::= expression '**' expression
fake binary_expression ::= expression+ { methods=[left="expression[0]" right="expression[1]"] }

logical_bitwise_negation_expression ::= ('!' | '~') expression
unary_expression ::= ('-' | '+') expression
pre_expression ::= ('--' | '++') expression
post_expression ::= expression ('--' | '++')
parentheses_expression ::= '(' expression ')' {pin=1}

literal_expression ::= literal | assignment_word