{
  parserClass='com.jetbrains.json.JsonParser'
  parserUtilClass="com.jetbrains.json.JsonParserUtil"
  psiPackage='com.jetbrains.json.psi'
  psiImplPackage='com.jetbrains.json.psi.impl'

  elementTypeHolderClass='com.jetbrains.json.JsonElementTypes'
  elementTypeClass='com.jetbrains.json.JsonElementType'
  psiClassPrefix="Json"

  psiImplUtilClass='com.jetbrains.json.psi.JsonPsiImplUtils'
  tokenTypeClass='com.jetbrains.json.JsonTokenType'

    tokens = [
        L_CURLY='{'
        R_CURLY='}'
        L_BRACKET='['
        R_BRACKET=']'
        
        COMMA=','
        COLON=':'
        // COMMENT='regexp:"//.*|/\*.*?\*/"'
        // else /\*(?:[^*]|\*[^/])*\*/
        // unclosed string literal matches till the line's end
        STRING='regexp:"([^\\"\r\n]|\\([\\"/bfnrt]|u[a-fA-F0-9]{4}))*"?'
        NUMBER='regexp:-?\d+(\.\d+([eE][+-]?\d+)?)?'
        TRUE='true'
        FALSE='false'
        NULL='null'
        // Workaround for highlighting issue
        // plays role of IDENTIFIER or NAME token in other languages
        TEXT='regexp:\w+'
    ]

    extends("object|array|literal")=value
    extends("string_literal|number_literal|boolean_literal|null_literal")=literal
}

json ::= object | array

object ::= L_CURLY [properties] R_CURLY {
  pin=1
  methods=[
    findProperty
  ]
}
private properties ::= property (COMMA property)* { pin(".*")=1 }
property ::= property_name COLON value {
  pin = 1
  methods=[
    getName
    delete
  ]
  recoverUntil = brace_or_comma
}

array ::= L_BRACKET [array_elements] R_BRACKET { pin=1 }
private array_elements ::= array_element (COMMA array_element)* { pin(".*")=1 }
private array_element ::= value {
  recoverUntil = bracket_or_comma
}

property_name ::= string_literal
value ::= object | array | literal

string_literal ::= STRING
number_literal ::= NUMBER
boolean_literal ::= TRUE | FALSE
null_literal ::= NULL

literal ::= string_literal | number_literal | boolean_literal | null_literal {
  methods=[isQuotedString]
  mixin="com.jetbrains.json.psi.impl.JsonLiteralMixin"
}

private bracket_or_comma ::= !(R_BRACKET|COMMA)
private brace_or_comma ::= !(R_CURLY|COMMA)