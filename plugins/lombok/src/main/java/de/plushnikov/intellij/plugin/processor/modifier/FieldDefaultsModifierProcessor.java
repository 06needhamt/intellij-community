package de.plushnikov.intellij.plugin.processor.modifier;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.intellij.psi.PsiAnnotation;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiModifier;
import com.intellij.psi.PsiModifierList;
import com.intellij.psi.util.PsiTreeUtil;
import de.plushnikov.intellij.plugin.util.PsiAnnotationSearchUtil;
import de.plushnikov.intellij.plugin.util.PsiAnnotationUtil;
import lombok.AccessLevel;
import org.jetbrains.annotations.NotNull;

import java.util.Collection;
import java.util.List;
import java.util.Set;

/**
 * @author Alexej Kubarev
 */
public class FieldDefaultsModifierProcessor implements ModifierProcessor {

  private static final Set<String> SUPPORTED_MODIFIERS = ImmutableSet.of(
      PsiModifier.FINAL, PsiModifier.PRIVATE, PsiModifier.PROTECTED, PsiModifier.PUBLIC
  );

  @Override
  public boolean isSupported(@NotNull PsiModifierList modifierList, @NotNull String name) {

    if (!SUPPORTED_MODIFIERS.contains(name)) {
      return false;
    }

    // FieldDefaults only change modifiers of class fields
    if (!(modifierList.getParent() instanceof PsiField)) {
      return false;
    }

    PsiClass searchableClass = PsiTreeUtil.getParentOfType(modifierList, PsiClass.class, true);

    return null != searchableClass && PsiAnnotationSearchUtil.isAnnotatedWith(searchableClass, lombok.experimental.FieldDefaults.class);
  }

  @Override
  public Boolean hasModifierProperty(@NotNull PsiModifierList modifierList, @NotNull String name) {

    PsiClass searchableClass = PsiTreeUtil.getParentOfType(modifierList, PsiClass.class, true);
    if (searchableClass == null) {
      return null; // Should not get here, but safer to check
    }

    PsiAnnotation fieldDefaultsAnnotation = PsiAnnotationSearchUtil.findAnnotation(searchableClass, lombok.experimental.FieldDefaults.class);
    if (fieldDefaultsAnnotation == null) {
      return null; // Should not get here, but safer to check
    }

    if (!(modifierList.getParent() instanceof PsiField)) {
      return null; // Should not get here, but safer to check
    }

    PsiField parentElement = (PsiField) modifierList.getParent();

    // FINAL
    // Is @FieldDefaults(makeFinal = true)?
    if (PsiModifier.FINAL.equals(name) && PsiAnnotationUtil.getBooleanAnnotationValue(fieldDefaultsAnnotation, "makeFinal", false)) {
      if (!PsiAnnotationSearchUtil.isAnnotatedWith(parentElement, lombok.experimental.NonFinal.class)) {
        return Boolean.TRUE;
      }
    }

    // VISIBILITY
    Collection<String> defaultLevels = PsiAnnotationUtil.getAnnotationValues(fieldDefaultsAnnotation, "level", String.class);
    final AccessLevel defaultAccessLevel = AccessLevel.valueOf(Iterables.getFirst(defaultLevels, AccessLevel.NONE.name()));

    if (
        // As per doc for AccessLevel.NONE (default), no modifiers should be generated by this annotation
        AccessLevel.NONE.equals(defaultAccessLevel) ||
        // If explicit visibility modifier is set - no point to continue.
        !hasPackagePrivateModifier(modifierList) ||
        // If @PackagePrivate is requested, leave the field as is
        PsiAnnotationSearchUtil.isAnnotatedWith(parentElement, lombok.experimental.PackagePrivate.class)) {
      return null;
    }

    // PRIVATE
    if (PsiModifier.PRIVATE.equals(name) && AccessLevel.PRIVATE.equals(defaultAccessLevel)) {
      return Boolean.TRUE;
    }

    // PROTECTED
    if (PsiModifier.PROTECTED.equals(name) && AccessLevel.PROTECTED.equals(defaultAccessLevel)) {
      return Boolean.TRUE;
    }

    // PUBLIC
    if (PsiModifier.PUBLIC.equals(name) && AccessLevel.PUBLIC.equals(defaultAccessLevel)) {
      return Boolean.TRUE;
    }

    return null;
  }

  private boolean hasPackagePrivateModifier(@NotNull PsiModifierList modifierList) {
    return !(modifierList.hasExplicitModifier(PsiModifier.PUBLIC) || modifierList.hasExplicitModifier(PsiModifier.PRIVATE) ||
        modifierList.hasExplicitModifier(PsiModifier.PROTECTED));
  }
}
