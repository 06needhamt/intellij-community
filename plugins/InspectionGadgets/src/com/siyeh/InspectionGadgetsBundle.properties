plugin.InspectionGadgets.description=Adds over 400 new automated code inspections for IntelliJ IDEA.
error.message.regexp.malformed.naming.pattern=Malformed Naming Pattern
cast.to.concrete.class.display.name=Cast to a concrete class
cast.to.concrete.class.problem.descriptor=Cast to concrete class #ref #loc
class.references.subclass.display.name=Class references one of its subclasses
class.references.subclass.problem.descriptor=Class {0} references subclass #ref #loc
collection.declared.by.class.display.name=Collection declared by class, not interface
#{0} - name of the interface
collection.declarated.by.class.problem.descriptor=Declaration of #ref should probably be weakened to {0} #loc
feature.envy.display.name=Feature Envy
feature.envy.problem.descriptor=Class {0} accessed repeatedly in method #ref #loc
instance.variable.of.concrete.class.display.name=Instance variable of concrete class
instance.variable.of.concrete.class.problem.descriptor=Instance variable {0} of concrete class #ref #loc
chain.of.instanceof.checks.display.name=Chain of 'instanceof' checks
chain.of.instanceof.checks.problem.descriptor=Chain of 'instanceof' checks indicates abstraction failure #loc
instanceof.concrete.class.display.name='instanceof' a concrete class
instanceof.concrete.class.problem.descriptor='instanceof' concrete class #ref #loc
instanceof.check.for.this.display.name='instanceof' check for 'this'
instanceof.check.for.this.problem.descriptor='instanceof' check for #ref #loc
local.variable.of.concrete.class.display.name=Local variable of concrete class
local.variable.of.concrete.class.problem.descriptor=Local variable {0} of concrete class #ref #loc
magic.number.display.name="Magic number"
magic.number.problem.descriptor=Magic number '#ref' #loc
magic.number.ignore.option.label=Ignore constants in hashCode() methods
method.return.concrete.class.display.name=Method return of concrete class
method.return.concrete.class.problem.descriptor=Method returns a concrete class #ref #loc
overly.strong.type.cast.display.name=Overly-strong type cast
overly.strong.type.cast.problem.descriptor=Cast to #ref can be weakened #loc
overly.strong.type.cast.weaken.quickfix=Weaken overly-strong cast
concrete.class.method.parameter.display.name=Method parameter of concrete class
concrete.class.method.parameter.problem.descriptor=Parameter {0} of concrete class #ref #loc
public.method.not.in.interface.display.name=Public method not exposed in interface
public.method.not.in.interface.problem.descriptor=Public method '#ref' is not exposed via an interface #loc
static.variable.of.concrete.class.display.name=Static variable of concrete class
static.variable.of.concrete.class.problem.descriptor=Static variable {0} of concrete class #ref #loc
incompatible.mask.operation.display.name=Incompatible bitwise mask operation
incompatible.mask.operation.problem.descriptor.always.false=#ref is always false #loc
incompatible.mask.operation.problem.descriptor.always.true=#ref is always true #loc
pointless.bitwise.expression.display.name=Pointless bitwise expression
pointless.bitwise.expression.ignore.option.label=Ignore named constant in determinining pointless expressions
pointless.bitwise.expression.problem.descriptor=#ref can be replaced with {0} #loc
pointless.bitwise.expression.simplify.quickfix=Simplify
shift.operation.by.inappropriate.constant.display.name=Shift operation by inappropriate constant
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Shift operation #ref by overly large constant value #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Shift operation #ref by negative constant value #loc
archaic.system.property.accessors.display.name=Use of archaic system property accessors
archaic.system.property.accessors.problem.descriptor.Integer=Call to Integer.#ref() accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.problem.descriptor.Long=Call to Long.#ref() accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.problem.descriptor.Boolean=Call to Boolean.#ref()accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.replace.parse.quickfix=Replace with parse method
archaic.system.property.accessors.replace.standard.quickfix=Replace with standard property access
equals.called.on.array.display.name='.equals()' called on array type
equals.called.on.array.problem.descriptor=.#ref() between arrays should probably be Arrays.equals() #loc
equals.called.on.array.replace.quickfix=replace with Arrays.equals
assignment.to.null.display.name=Assignment to 'null'
assignment.to.null.problem.descriptor=Assignment of variable #ref to null #loc
assignment.to.static.field.from.instance.method.display.name=Assignment to static field from instance method
assignment.to.static.field.from.instance.method.problem.descriptor=Assignment to static field '#ref' from an instance method #loc
assignment.used.as.condition.display.name=Assignment used as condition
assignment.used.as.condition.problem.descriptor=#ref used as condition #loc
assignment.used.as.condition.replace.quickfix=replace '=' with '=='
cast.conflicts.with.instanceof.display.name=Cast conflicts with 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=Cast to #ref conflicts with surrounding 'instanceof' check #loc
casting.to.incompatible.interface.display.name=Casting to incompatible interface
casting.to.incompatible.interface.problem.descriptor=Cast to incompatible interface #ref #loc
collection.added.to.self.display.name=Collection added to self
collection.added.to.self.problem.descriptor=Collection '#ref' is added to self #loc
non.final.field.compareto.display.name=Non-final field referenced in 'compareTo()'
non.final.field.compareto.problem.descriptor=Non-final field #ref accessed in compareTo() #loc
covariant.compareto.display.name=Covariant 'compareTo()'
covariant.compareto.problem.descriptor=#ref should take Object as its argument #loc
covariant.equals.display.name=Covariant 'equals()'
covariant.equals.problem.descriptor=#ref should take Object as its argument #loc
empty.class.initializer.display.name=Empty class initializer
empty.class.initializer.problem.descriptor=Empty class initializer #loc
empty.class.initializer.delete.quickfix=Delete empty class initializer
statement.with.empty.body.display.name=Statement with empty body
statement.with.empty.body.problem.descriptor=#ref statement has empty body #loc
statement.with.empty.body.include.option.label=Include statement bodies that are empty code blocks
equals.between.inconvertible.types.display.name='equals()' between objects of inconvertible types
equals.between.inconvertible.types.problem.descriptor=#ref() between objects of inconvertible types {0} and {1} #loc
non.final.field.in.equals.display.name=Non-final field referenced in 'equals()'
non.final.field.in.equals.problem.descriptor=Non-final field #ref accessed in equals()  #loc
equals.doesnt.check.class.parameter.display.name='equals()' method which doesn't check class of parameter
equals.doesnt.check.class.parameter.problem.descriptor=#ref should check the class of its parameter #loc
for.loop.not.use.loop.variable.display.name='for' loop where update or condition doesn't use loop variable
for.loop.not.use.loop.variable.problem.descriptor.condition=#ref statement has condition which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.update=#ref statement has update which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=#ref statement has condition and update which do not use the for loop variable #loc
non.final.field.in.hashcode.display.name=Non-final field referenced in 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Non-final field #ref accessed in hashCode()  #loc
result.of.method.call.ignored.display.name=Result of method call ignored
result.of.method.call.ignored.problem.descriptor=result of {0}.#ref() is ignored. #loc
result.of.method.call.ignored.class.column.title=Class name
result.of.method.call.ignored.method.column.title=Method name
result.of.method.call.ignored.non.library.option=Report all ignored non-library calls
result.of.method.call.ignored.table.panel.title=Ignored calls to report
infinite.recursion.display.name=Infinite recursion
infinite.recursion.problem.descriptor=Method #ref recurses infinitely, and can only end by throw an exception #loc
instanceof.with.incompatible.interface.display.name='instanceof' with incompatible interface
instanceof.with.incompatible.interface.problem.descriptor='instanceof' incompatible interface #ref #loc
instantiation.utility.class.display.name=Instantiation of utility class
instantiation.utility.class.problem.descriptor=Instantiation of utility class '#ref' #loc
iterator.hasnext.which.calls.next.display.name='Iterator.hasNext()' which calls 'next()'
iterator.hasnext.which.calls.next.problem.descriptor=Iterator.#ref() contains call to next() #loc
iterator.next.no.throw.nosuchelementexception.display.name='Iterator.next()' which can't throw NoSuchElementException
iterator.next.no.throw.nosuchelementexception.problem.descriptor=Iterator.#ref() which can't throw NoSuchElementException #loc
malformed.format.string.display.name=Malformed format string
malformed.format.string.problem.descriptor.malformed=Format string #ref is malformed #loc
malformed.format.string.problem.descriptor.too.many.arguments=Too many arguments for format string #ref #loc
malformed.format.string.problem.descriptor.too.few.arguments=Too few arguments for format string #ref #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=Format string #ref does not match the type of its arguments #loc
malformed.regular.expression.display.name=Malformed regular expression
malformed.regular.expression.problem.descriptor=Regular expression #ref is malformed #loc
malformed.xpath.expression.display.name=Malformed XPath expression
malformed.xpath.expression.problem.description=XPath expression #ref is malformed #loc
mismatched.read.write.array.display.name=Mismatched read and write of array
mismatched.read.write.array.problem.descriptor.write.not.read=Contents of array #ref are written to, but never read #loc
mismatched.read.write.array.problem.descriptor.read.not.write=Contents of array #ref are read, but never written to #loc
mismatched.update.collection.display.name=Mismatched query and update of collection
mismatched.update.collection.problem.descriptor.updated.not.queried=Contents of collection #ref are updated, but never queried #loc
mismatched.update.collection.problem.description.queried.not.updated=Contents of collection #ref are queried, but never updated #loc
misspelled.compareto.display.name='compareto()' instead of 'compareTo()'
misspelled.compareto.problem.descriptor=#ref() method should probably be compareTo() #loc
quickfix.rename=Rename
quickfix.renameto=Rename to ''{0}''
misspelled.equals.display.name='equal()' instead of 'equals()'
misspelled.equals.problem.descriptor=#ref() method should probably be equals() #loc
misspelled.hashcode.display.name='hashcode()' instead of 'hashCode()'
misspelled.hashcode.problem.descriptor=#ref() should probably be hashCode() #loc
misspelled.tostring.display.name='tostring()' instead of 'toString()'
misspelled.tostring.problem.descriptor=#ref() method should probably be toString() #loc
non.short.circuit.boolean.expression.display.name=Non-short-circuit boolean expression
non.short.circuit.boolean.expression.problem.descriptor=Non-short-circuit boolean expression #ref #loc
non.short.circuit.boolean.expression.replace.quickfix=Replace with short circuit expression
null.argument.to.var.arg.method.display.name=Confusing 'null' argument to var-arg method
null.argument.to.var.arg.method.problem.descriptor=Confusing '#ref' argument to var-arg method #loc
object.comparison.display.name=Object comparison using ==, instead of '.equals()'
object.comparison.enumerated.ignore.option=Ignore == between enumerated types
object.comparison.klass.ignore.option=Ignore == on java.lang.Class objects
object.comparison.problem.description=Object values are compared using '#ref', not '.equals()' #loc
object.comparison.replace.quickfix=Replace with .equals()
object.equals.null.problem.descriptor=.equals(#ref) is probably not what was intended #loc
default.tostring.call.display.name=Call to default .toString()
default.tostring.call.problem.descriptor=Call to default toString() #ref #loc
octal.and.decimal.integers.in.same.array.display.name=Octal and decimal integers in same array
octal.and.decimal.integers.in.same.array.problem.descriptor=Octal and decimal integers are in the same array initializer  #loc
result.of.object.allocation.ignored.display.name=Result of object allocation ignored
result.of.object.allocation.ignored.problem.descriptor=result of new #ref() is ignored. #loc
use.0index.in.jdbc.resultset.display.name=Use of index 0 in JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Use on index 0 with JDBC ResultSet #loc
return.of.null.display.name=Return of 'null'
return.of.null.problem.descriptor=Return of '#ref' #loc
return.of.null.arrays.option=Methods that return arrays
return.of.null.objects.option=Methods that return objects
static.method.via.subclass.display.name=Static method referenced via subclass
static.method.via.subclass.problem.descriptor=Static method ''#ref'' declared on class {0} but referenced via class {1}    #loc
static.method.via.subclass.rationalize.quickfix=Rationalize static method call
static.field.via.subclass.display.name=Static field referenced via subclass
static.field.via.subclass.problem.descriptor=Static field ''#ref'' declared on class {0} but referenced via class {1}    #loc
static.field.via.subclass.rationalize.quickfix=Rationalize static field access
string.comparison.display.name=String comparison using '==', instead of '.equals()'
string.comparison.problem.descriptor=String values are compared using '#ref', not '.equals()' #loc
string.comparison.replace.quickfix=Replace with .equals()
subtraction.in.compareto.display.name=Subtraction in compareTo()
subtraction.in.compareto.problem.descriptor=Subtraction (#ref) in compareTo() may result in overflow errors #loc
text.label.in.switch.statement.display.name=Text label in 'switch' statement
text.label.in.switch.statement.problem.descriptor=Text label #ref: in 'switch' statement #loc
properties.object.as.hashtable.display.name=Use of Properties object as a Hashtable
properties.object.as.hashtable.problem.descriptor=Call to Hashtable.#ref() on properties object #loc
assignment.replaceable.with.operator.assignment.display.name=Assignment replaceable with operator assignment
assignment.replaceable.with.operator.assignment.problem.descriptor=#ref could be simplified to {0} #loc
assignment.replaceable.with.operator.assignment.replace.quickfix=Replace = with {0}=
unnecessary.code.block.display.name=Unnecessary code block
unnecessary.code.block.problem.descriptor=Braces around this statement are unnecessary #loc
unnecessary.code.block.unwrap.quickfix=Unwrap block
redundant.local.variable.display.name=Redundant local variable
redundant.local.variable.ignore.option=Ignore immediately returned or thrown variables
redundant.local.variable.problem.descriptor=Local variable #ref is redundant #loc
static.collection.display.name=Static collection
static.collection.problem.descriptor=Static collection #ref #loc
static.collection.ignore.option=Ignore weak static collections or maps
#field of type java.lang.StringBuffer
stringbuffer.field.display.name=StringBuffer field
#{0} - concrete field type
stringbuffer.field.problem.descriptor={0} field #ref #loc
gc.call.display.name=Calls to System.gc() or Runtime.gc()
gc.call.problem.descriptor=#ref should not be called in production code #loc
array.allocation.zero.length.display.name=Zero-length array allocation
array.allocation.zero.length.problem.description=Allocation of zero length array #loc
multiple.loggers.display.name=Class with multiple loggers
logger.name.option=Logger class name:
multiple.loggers.problem.descriptor=Class #ref declares multiple loggers #loc
no.logger.display.name=Class without logger
no.logger.problem.descriptor=Class #ref does not declare a logger #loc
non.constant.logger.display.name=Non-constant logger
non.constant.logger.problem.descriptor=Non-constant logger field #ref #loc
public.method.without.logging.display.name=Public method without logging
public.method.without.logging.problem.descriptor=Public method without logging #ref #loc
action.reset.telemetry.description=Reset telemetry data

telemetry.table.column.inspection.name=Inspection Name
telemetry.table.column.total.time=Total Run Time (msecs)
telemetry.table.column.average.time=Average Run Time (msecs)
telemetry.table.column.run.count=Total Run Count
telemetry.toolwindow.title=IG Telemetry
action.telemetry.refresh.description=Refresh telemetry display
finalize.doesnt.call.super.display.name='finalize()' doesn't call 'super.finalize()'
finalize.doesnt.call.super.ignore.option.label=Ignore for direct subclasses of java.lang.Object
finalize.doesnt.call.super.problem.descriptor=#ref() doesn't call super.finalize()
finalize.declaration.display.name='finalize()' declaration
finalize.declaration.problem.descriptor=#ref() declared #loc
finalize.not.declared.protected.display.name='finalize()' not declared 'protected'
finalize.not.declared.protected.problem.descriptor=#ref() not declared 'protected' #loc
finalize.not.declared.protected.make.protected.quickfix=Make 'protected'
finalize.called.explicitly.display.name='finalize()' called explicitly
finalize.called.explicitly.problem.descriptor=#ref() called explicitly #loc
java.lang.import.display.name=java.lang import
java.lang.import.problem.descriptor=Unnecessary import from package java.lang #loc
import.display.name=* import
import.problem.descriptor=Importing package #ref.*  #loc
redundant.import.display.name=Redundant import
redundant.import.problem.descriptor=Redundant import '#ref' #loc
import.from.same.package.display.name=Import from same package
import.from.same.package.problem.descriptor=Unnecessary import from same package '#ref' #loc
single.class.import.display.name=Single class import
single.class.import.problem.descriptor=Single class import '#ref' #loc
static.import.display.name=Static import
static.import.problem.descriptor=Static import #ref  #loc
static.import.replace.quickfix=Replace with non-static import
unused.import.display.name=Unused import
unused.import.problem.descriptor=Unused import '#ref' #loc
clone.instantiates.objects.with.constructor.display.name='clone()' instantiates objects with constructor
clone.instantiates.objects.with.constructor.problem.descriptor=clone() instantiates objects with constructor new #ref() #loc
clone.doesnt.call.super.clone.display.name='clone()' doesn't call 'super.clone()'
clone.doesnt.call.super.clone.problem.descriptor=#ref() doesn't call super.clone()
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' doesn't declare CloneNotSupportedException
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=#ref() doesn't declare CloneNotSupportedException #loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Declare CloneNotSupportedException
clone.method.in.non.cloneable.class.display.name='clone()' method in non-Cloneable class
clone.method.in.non.cloneable.class.problem.descriptor=#ref() defined in non-Cloneable class #loc
cloneable.class.without.clone.display.name=Cloneable class without 'clone()'
cloneable.class.without.clone.problem.descriptor=#ref doesn't define clone() #loc
cloneable.class.without.clone.ignore.option=Ignore classes cloneable due to inheritance
class.without.tostring.display.name=Class without 'toString()'
class.without.tostring.problem.descriptor=Class #ref should probably implement .toString(), for debugging purposes
use.obsolete.collection.type.display.name=Use of obsolete collection type
use.obsolete.collection.type.problem.descriptor=Obsolete collection type #ref used #loc
inspection.suppression.annotation.display.name=Inspection suppression annotation
inspection.suppression.annotation.problem.descriptor=Inspection suppression annotation #ref #loc
use.system.out.err.display.name=Use of System.out or System.err
use.system.out.err.problem.descriptor=Uses of System.out and System.err should probably be replaced with more robust logging #loc
dumpstack.call.display.name=Call to 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=Call to Thread.#ref() should probably be replaced with more robust logging #loc
printstacktrace.call.display.name=Call to 'printStackTrace()'
printstacktrace.call.problem.descriptor=Call to #ref() should probably be replaced with more robust logging #loc
todo.comment.display.name=TODO comment
todo.comment.problem.descriptor=TODO comment #ref #loc
abstract.method.call.in.constructor.display.name=Abstract method call in constructor
abstract.method.call.in.constructor.problem.descriptor=Call to abstract method #ref during object construction #loc
instance.variable.may.not.be.initialized.display.name=Instance variable may not be initialized
instance.variable.may.not.be.initialized.problem.descriptor=Instance variable #ref may not be initialized during object construction #loc
primitive.fields.ignore.option=Ignore primitive fields
instance.variable.used.before.initialized.display.name=Instance variable used before initialized
instance.variable.used.before.initialized.problem.descriptor=Instance variable #ref used before initialized #loc
non.final.static.variable.initialization.display.name=Non-final static variable is used during class initialization
non.final.static.variable.initialization.problem.descriptor=Non-final static variable #ref used during class initialization #loc
overridable.method.call.in.constructor.display.name=Overridable method call in constructor
overridable.method.call.in.constructor.problem.descriptor=Call to overridable method #ref during object construction #loc
overridden.method.call.in.constructor.display.name=Overridden method call in constructor
overridden.method.call.in.constructor.problem.descriptor=Call to overridden method #ref during object construction #loc
static.variable.may.not.be.initialized.display.name=Static variable may not be initialized
static.variable.may.not.be.initialized.problem.descriptor=Static variable #ref may not be initialized during class initialization #loc
static.variable.used.before.initialization.display.name=Static variable used before initialization
static.variable.used.before.initialization.problem.descriptor=Static variable #ref used before initialization #loc
this.reference.escaped.in.construction.display.name='this' reference escaped in object construction
this.reference.escaped.in.construction.problem.descriptor=Escape of '#ref' during object construction #loc
assignment.to.catch.block.parameter.display.name=Assignment to catch block parameter
assignment.to.catch.block.parameter.problem.descriptor=Assignment to catch block parameter #ref #loc
assignment.to.catch.block.parameter.extract.quickfix=Extract parameter as local variable
assignment.to.for.loop.parameter.display.name=Assignment to 'for' loop parameter
assignment.to.for.loop.parameter.problem.descriptor=Assignment to for-loop parameter #ref #loc
assignment.to.method.parameter.display.name=Assignment to method parameter
assignment.to.method.parameter.problem.descriptor=Assignment to method parameter #ref #loc
chained.equality.comparisons.display.name=Chained equality comparisons
chained.equality.comparisons.problem.descriptor=Chained equality comparison #ref #loc
confusing.octal.escape.sequence.display.name=Confusing octal escape sequence
confusing.octal.escape.sequence.problem.descriptor=String #ref contains potentially confusing octal escape sequence #loc
increment.decrement.display.name=Value of ++ or -- used
increment.decrement.post.inc=Value of post-increment expression #ref is used #loc
increment.decrement.post.dec=Value of post-decrement expression #ref is used #loc
increment.decrement.pre.inc=Value of pre-increment expression #ref is used #loc
increment.decrement.pre.dec=Value of pre-decrement expression #ref is used #loc
nested.assignment.display.name=Nested assignment
nested.assignment.problem.descriptor=Nested assignment #ref #loc
overloaded.methods.with.same.number.parameters.display.name=Overloaded methods with same number of parameters
overloaded.methods.with.same.number.parameters.problem.descriptor=Multiple methods names '#ref' with the same number of parameters
refused.bequest.display.name=Refused bequest
refused.bequest.problem.descriptor=Method #ref ignores defined method in superclass #loc
reuse.of.local.variable.display.name=Reuse of local variable
reuse.of.local.variable.problem.descriptor=Reuse of local variable #ref #loc
reuse.of.local.variable.split.quickfix=Split local variable
character.comparison.display.name=Character comparison
character.comparison.problem.descriptor=Character comparison #ref in an internationalized context #loc
assignment.collection.array.field.from.parameter.display.name=Assignment to Collection or array field from parameter
assignment.collection.array.field.from.parameter.problem.descriptor.array=assignment to array field #ref from parameter {0}#loc
assignment.collection.array.field.from.parameter.problem.descriptor.collection=assignment to Collection field #ref from parameter {0}#loc
assignment.to.date.calendar.field.from.parameter.display.name=Assignment to Date or Calendar field from parameter
assignment.to.date.calendar.field.from.parameter.problem.descriptor=assignment to {0} field #ref from parameter {1}#loc
package.visible.field.display.name=Package-visible field
package.visible.field.problem.descriptor=Package-visible field #ref #loc
package.visible.inner.class.display.name=Package-visible inner class
package.visible.inner.class.problem.descriptor=Package-visible inner class #ref #loc
protected.field.display.name=Protected field
protected.field.problem.descriptor=Protected field #ref #loc
protected.inner.class.display.name=Protected inner class
protected.inner.class.problem.descriptor=Protected inner class #ref #loc
public.field.display.name=Public field
public.field.problem.descriptor=Public field #ref #loc
public.inner.class.display.name=Public inner class
public.inner.class.problem.descriptor=Public inner class #ref #loc
return.of.collection.array.field.display.name=Return of Collection or array field
return.of.collection.array.field.problem.descriptor.array='return' of array field #ref #loc
return.of.collection.array.field.problem.descriptor.collection='return' of Collection field #ref #loc
return.date.calendar.field.display.name=Return of Date or Calendar field
return.date.calendar.field.problem.descriptor=''return'' of {0} field #ref #loc
accessing.non.public.field.of.another.object.display.name=Accessing a non-public field of another object
accessing.non.public.field.of.another.object.problem.descriptor=Direct access of non-public field #ref on another object #loc
call.to.date.tostring.display.name=Call to Date.toString()
call.to.date.tostring.problem.descriptor=Date.#ref() used in an internationalized context #loc
magic.character.display.name="Magic character"
magic.character.problem.descriptor="Magic character" #ref in an internationalized context #loc
call.to.numeric.tostring.display.name=Call to Numeric .toString()
call.to.numeric.tostring.problem.descriptor=Numeric .#ref()  called in an internationalized context #loc
instantiating.simpledateformat.without.locale.display.name=Instantiating a SimpleDateFormat without a Locale
instantiating.simpledateformat.without.locale.problem.descriptor=Instantiating a #ref without specifying a Locale in an internationalized context #loc
string.compareto.call.display.name=Call to String.compareTo()
string.compareto.call.problem.descriptor=String.#ref() called in an internationalized context #loc
string.concatenation.display.name=String concatenation
string.concatenation.problem.descriptor=String concatenation (#ref) in an internationalized context #loc
string.equalsignorecase.call.display.name=Call to String.equalsIgnoreCase()
string.equalsignorecase.call.problem.descriptor=String.#ref() in an internationalized context #loc
string.equals.call.display.name=Call to String.equals()
string.equals.call.problem.descriptor=String.#ref() in an internationalized context #loc
string.touppercase.tolowercase.without.locale.display.name=Call to String.toUpperCase() or .toLowerCase() without a Locale
string.touppercase.tolowercase.without.locale.problem.descriptor=String.#ref() called without specifying a Locale in an internationalized context #loc
use.stringtokenizer.display.name=Use of StringTokenizer
use.stringtokenizer.problem.descriptor=#ref in an internationalized context #loc
time.tostring.call.display.name=Call to Time.toString()
time.tostring.call.problem.descriptor=Time.#ref() in an internationalized context #loc
class.escapes.defined.scope.display.name=Class escapes defined scope
class.escapes.defined.scope.problem.descriptor=Class '#ref' is made visible outside its defined scope #loc
field.name.hides.in.superclass.display.name=Field name hides field in superclass
field.name.hides.in.superclass.problem.descriptor=Field '#ref' hides field in superclass #loc
field.name.hides.in.superclass.ignore.option=Ignore superclass fields not visible from subclass
inner.class.field.hides.outer.display.name=Inner class field hides outer class field
inner.class.field.hides.outer.ignore.option=Ignore outer fields not visible from inner class
inner.class.field.hides.outer.problem.descriptor=Inner class field '#ref' hides outer class field #loc
local.variable.hides.member.variable.display.name=Local variable hides member variable
local.variable.hides.member.variable.problem.descriptor=Local variable '#ref' hides member variable #loc
local.variable.hides.member.variable.ignore.option=Ignore local variables in static methods
method.overloads.display.name=Method overloads method of superclass
method.overloads.problem.descriptor=Method '#ref' overloads a compatible method of a superclass, when overriding might have been intended #loc
method.overrides.private.display.name=Method overrides private method of superclass
method.overrides.private.display.name.problem.descriptor=Method '#ref' overrides a private method of a superclass #loc
method.overrides.static.display.name=Method overrides static method of superclass
method.overrides.static.problem.descriptor=Method '#ref' overrides a static method of a superclass #loc
parameter.hides.member.variable.display.name=Parameter hides member variable
parameter.hides.member.variable.problem.descriptor=Parameter '#ref' hides member variable #loc
parameter.hides.member.variable.ignore.setters.option=Ignore for property setters
parameter.hides.member.variable.ignore.superclass.option=Ignore superclass fields not visible from subclass
parameter.hides.member.variable.ignore.constructors.option=Ignore for constructors
parameter.hides.member.variable.ignore.abstract.methods.option=Ignore for abstract methods
parameter.hides.member.variable.ignore.static.parameters.option=Ignore for static method parameters hiding instance fields
type.parameter.hides.visible.type.display.name=Type parameter hides visible type
type.parameter.hides.visible.type.problem.descriptor=Type parameter '#ref' hides a visible type ''{0}''#loc
channel.opened.not.closed.display.name=Channel opened but not safely closed
channel.opened.not.closed.problem.descriptor={0} should be opened in a try block, and closed in a finally block #loc
drivermanager.call.display.name=Use of DriverManager to get JDBC connection
drivermanager.call.problem.descriptor=Call to DriverManager.#ref() #loc
hibernate.resource.opened.not.closed.display.name=Hibernate resource opened but not safely closed
hibernate.resource.opened.not.closed.problem.descriptor={0} should be opened in a try block, and closed in a finally block #loc
i.o.resource.opened.not.closed.display.name=I/O resource opened but not safely closed
resource.opened.not.closed.problem.descriptor={0} should be opened in a try block, and closed in a finally block #loc
jdbc.resource.opened.not.closed.display.name=JDBC resource opened but not safely closed
jdbc.resource.opened.not.closed.problem.descriptor=JDBC {0} should be opened in a try block, and closed in a finally block #loc
jndi.resource.opened.not.closed.display.name=JNDI resource opened but not safely closed
socket.opened.not.closed.display.name=Socket opened but not safely closed
annotation.class.display.name=Annotation class
annotation.class.problem.descriptor=Annotation class '#ref' #loc
annotation.display.name=Annotation
annotation.problem.descriptor=Annotation '#ref' #loc
use.assert.as.identifier.display.name=Use of 'assert' as identifier
use.assert.as.identifier.problem.descriptor=Use of '#ref' as identifier #loc
assert.statement.display.name='assert' statement
assert.statement.problem.descriptor='#ref' statement #loc
auto.boxing.display.name=Auto-boxing
auto.boxing.problem.descriptor=Auto-boxing #ref #loc
auto.boxing.make.boxing.explicit.quickfix=Make boxing explicit
auto.unboxing.display.name=Auto-unboxing
auto.unboxing.problem.descriptor=Auto-unboxing #ref #loc
auto.unboxing.make.unboxing.explicit.quickfix=Make unboxing explicit
use.enum.as.identifier.display.name=Use of 'enum' as identifier
use.enum.as.identifier.problem.descriptor=Use of '#ref' as identifier #loc
enumerated.class.display.name=Enumerated class
enumerated.class.problem.descriptor=Enumerated class '#ref' #loc
extended.for.statement.display.name=Extended 'for' statement
extended.for.statement.problem.descriptor='Extended #ref' statement #loc
extended.for.statement.replace.quickfix=Replace with old-style 'for' statement
variable.argument.method.display.name=Variable argument method
variable.argument.method.problem.descriptor=Variable argument method '#ref' #loc
hardcoded.file.separator.display.name=Hardcoded file separator
hardcoded.file.separator.problem.descriptor=Hardcoded file separator #ref #loc
hardcoded.line.separator.display.name=Hardcoded line separator
hardcoded.line.separator.problem.descriptor=Hardcoded line separator #ref #loc
native.method.display.name=Native method
native.method.problem.descriptor=Methods declared '#ref' are non-portable #loc
runtime.exec.call.display.name=Call to 'Runtime.exec()'
runtime.exec.call.problem.descriptor=Call to Runtime.#ref() is non-portable #loc
system.exit.call.display.name=Call to 'System.exit()' or related methods
system.exit.call.problem.descriptor=Call to {0}.#ref() is non-portable #loc
system.getenv.call.display.name=Call to 'System.getenv()'
system.getenv.call.problem.descriptor=Call to System.#ref() is non-portable #loc
use.of.awt.peer.class.display.name=Use of AWT peer class
use.of.awt.peer.class.problem.descriptor=Use of AWT peer class #ref is non-portable #loc
use.of.concrete.jdbc.driver.class.display.name=Use of concrete JDBC driver class
use.of.concrete.jdbc.driver.class.problem.descriptor=Use of concrete JDBC driver class #ref is non-portable #loc
use.processbuilder.class.display.name=Use of java.lang.ProcessBuilder class
use.processbuilder.class.problem.descriptor=Use of #ref is non-portable #loc
use.sun.classes.display.name=Use of sun.* classes
use.sun.classes.problem.descriptor=Use of Sun-supplied class #ref is non-portable #loc
abstract.class.one.inheritor.display.name=Abstract class which has only one direct inheritor
abstract.class.one.inheritor.problem.descriptor=Abstract class #ref has only one direct inheritor #loc
anonymous.inner.may.be.named.static.inner.class.display.name=Anonymous inner class may be a named static inner class
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=Anonymous inner class #ref may be name static inner class #loc
array.length.in.loop.condition.display.name=Array.length in loop condition
array.length.in.loop.condition.problem.descriptor=Check of array .#ref in loop condition #loc
large.array.allocation.no.outofmemoryerror.display.name=Large array allocation with no OutOfMemoryError check
large.array.allocation.no.outofmemoryerror.problem.descriptor=Large array allocation which is not checked for out-of-memory condition #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Maximum number of elements
connection.opened.not.safely.closed.display.name=Connection opened but not safely closed
field.repeatedly.accessed.in.method.display.name=Field repeatedly accessed in method
field.repeatedly.accessed.in.method.problem.descriptor=Field {0} accessed repeatedly in method #ref #loc
field.repeatedly.accessed.in.method.ignore.option=Ignore final fields
interface.one.inheritor.display.name=Interface which has only one direct inheritor
interface.one.inheritor.problem.descriptor=Interface #ref has only one direct inheritor #loc
method.call.in.loop.condition.display.name=Method call in loop condition
method.call.in.loop.condition.problem.descriptor=Call to method '#ref()' in loop condition #loc
large.initializer.primitive.type.array.display.name=Overly large initializer for array of primitive type
large.initializer.primitive.type.array.problem.descriptor=Primitive array initializer with too many elements ({0}) #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=Maximum number of elements
private.member.access.between.outer.and.inner.classes.display.name=Private member access between outer and inner classes
private.member.access.between.outer.and.inner.classes.problem.descriptor=Access to private member of class ''{0}'' #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Make ''{0}'' package local
recordstore.opened.not.safely.closed.display.name=RecordStore opened but not safely closed