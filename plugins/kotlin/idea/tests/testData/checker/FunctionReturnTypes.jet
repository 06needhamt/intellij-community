fun none() {}

fun unitEmptyInfer() {}
fun unitEmpty() : Unit {}
fun unitEmptyReturn() : Unit {return}
fun unitIntReturn() : Unit {return <error>1</error>}
fun unitUnitReturn() : Unit {return ()}
fun test1() : Any = {return}
fun test2() : Any = @a {return@a 1}
fun test3() : Any { <error>return</error> }

fun bbb() {
  return <error>1</error>
}

fun foo(expr: StringBuilder): Int {
  val c = 'a'
  when(c) {
    0.chr => throw Exception("zero")
    else => throw Exception("nonzero" + c)
  }
}


fun unitShort() : Unit = ()
fun unitShortConv() : Unit = <error>1</error>
fun unitShortNull() : Unit = <error>null</error>

fun intEmpty() : Int <error>{}</error>
fun intShortInfer() = 1
fun intShort() : Int = 1
//fun intBlockInfer()  {1}
fun intBlock() : Int {return 1}
fun intBlock() : Int {<error>1</error>}

fun intString(): Int = <error>"s"</error>
fun intFunctionLiteral(): Int = <error>{ 10 }</error>

fun blockReturnUnitMismatch() : Int {<error>return</error>}
fun blockReturnValueTypeMismatch() : Int {return <error>3.4</error>}
fun blockReturnValueTypeMatch() : Int {return 1}
fun blockReturnValueTypeMismatchUnit() : Int {return <error>()</error>}

fun blockAndAndMismatch() : Int {
  <error>true && false</error>
}
fun blockAndAndMismatch() : Int {
  return <error>true && false</error>
}
fun blockAndAndMismatch() : Int {
  <error>(return <error>true</error>) && (return <error>false</error>)</error>
}

fun blockAndAndMismatch() : Int {
  <error>true || false</error>
}
fun blockAndAndMismatch() : Int {
  return <error>true || false</error>
}
fun blockAndAndMismatch() : Int {
  <error>(return <error>true</error>) || (return <error>false</error>)</error>
}
fun blockReturnValueTypeMatch() : Int {
  return if (1 > 2) <error>1.0</error> else <error>2.0</error>
}
fun blockReturnValueTypeMatch() : Int {
  return <error>if (1 > 2) 1</error>
}
fun blockReturnValueTypeMatch() : Int {
  return <error>if (1 > 2) else 1</error>
}
fun blockReturnValueTypeMatch() : Int {
  if (1 > 2)
    return <error>1.0</error>
  else return <error>2.0</error>
}
fun blockReturnValueTypeMatch() : Int {
  if (1 > 2)
    return <error>1.0</error>
  return <error>2.0</error>
}
fun blockReturnValueTypeMatch() : Int {
  if (1 > 2)
    else return <error>1.0</error>
  return <error>2.0</error>
}
fun blockReturnValueTypeMatch() : Int {
  if (1 > 2)
    <error>1.0</error>
  else <error>2.0</error>
}
fun blockReturnValueTypeMatch() : Int {
  if (1 > 2)
    1.0
  else 2.0
  return 1
}
fun blockReturnValueTypeMatch() : Int {
  <error>if (1 > 2)
    <error>1.0</error></error>
}
fun blockReturnValueTypeMatch() : Int {
  return <error>if (1 > 2)
    1</error>
}
fun blockReturnValueTypeMatch() : Int {
  <error>if (1 > 2)
  else <error>1.0</error></error>
}
fun blockReturnValueTypeMatch() : Int {
  if (1 > 2)
    return 1
  else return <error>1.0</error>
}
fun blockNoReturnIfValDeclaration(): Int {
  <error>val x = 1</error>
}
fun blockNoReturnIfEmptyIf(): Int {
  if (1 < 2) <error>{}</error> else <error>{}</error>
}
fun blockNoReturnIfUnitInOneBranch(): Int {
  if (1 < 2) {
    return 1
  } else {
    if (3 < 4) <error>{
    }</error> else {
      return 2
    }
  }
}
fun nonBlockReturnIfEmptyIf(): Int = if (1 < 2) <error>{}</error> else <error>{}</error>
fun nonBlockNoReturnIfUnitInOneBranch(): Int = if (1 < 2) <error>{}</error> else 2

val a = <error>return 1</error>

class A() {
  this(a : Int) : this() {
    if (a == 1)
      return
    return <error>1</error>
  }

}
fun illegalConstantBody(): Int = <error>"s"</error>
fun illegalConstantBlock(): String {
    return <error>1</error>
}
fun illegalIfBody(): Int =
    if (1 < 2) <error>'a'</error> else { <error>1.0</error> }
fun illegalIfBlock(): Boolean {
    if (1 < 2)
        return false
    else { return <error>1</error> }
}
fun illegalReturnIf(): Char {
    return if (1 < 2) 'a' else { <error>1</error> }
}

fun returnNothing(): Nothing {
    throw 1
}
fun f(): Int {
    if (1 < 2) { return 1 } else returnNothing()
}

fun f(): Int = if (1 < 2) 1 else returnNothing()
