namespace automatic_casts

fun toInt(i: Int?): Int = if (i != null) i else 0
fun illegalWhenBody(a: Any): Int = when(a) {
    is Int => a
    is String => <error>a</error>
}
fun illegalWhenBlock(a: Any): Int {
    when(a) {
        is Int => return a
        is String => return <error>a</error>
    }
}
fun declarations(a: Any?) {
    if (a is String) {
       val p4: (Int, String) = (2, a)
    }
    if (a is String?) {
        if (a != null) {
            val s: String = a
        }
    }
    if (a != null) {
        if (a is String?) {
            val s: String = a
        }
    }
}
fun tuples(a: Any?) {
    if (a != null) {
        val s: (Any, String) = (a, <error>a</error>)
    }
    if (a is String) {
        val s: (Any, String) = (a, a)
    }
    fun illegalTupleReturnType(): (Any, String) = (<error>a</error>, <error>a</error>)
    if (a is String) {
        fun legalTupleReturnType(): (Any, String) = (a, a)
    }
    val illegalFunctionLiteral: Function0<Int> = <error>{ <error>a</error> }</error>
    val illegalReturnValueInFunctionLiteral: Function0<Int> = { (): Int => <error>a</error> }

    if (a is Int) {
        val legalFunctionLiteral: Function0<Int> = { a }
        val alsoLegalFunctionLiteral: Function0<Int> = { (): Int => a }
    }
}
fun returnFunctionLiteralBlock(a: Any?): Function0<Int> {
    if (a is Int) return { a }
    else return { 1 }
}
fun returnFunctionLiteral(a: Any?): Function0<Int> =
    if (a is Int) { (): Int => a }
    else { () => 1 }

fun illegalTupleReturnType(a: Any): (Any, String) = (a, <error>a</error>)

fun declarationInsidePattern(x: (Any, Any)): String = when(x) { is (val a is String, *) => a; else => "something" }