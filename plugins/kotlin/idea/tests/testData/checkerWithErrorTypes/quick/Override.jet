namespace override

namespace normal {
    trait MyTrait {
        fun foo()
    }

    abstract class MyAbstractClass {
        abstract fun bar()
    }

    open class MyClass : MyTrait, MyAbstractClass {
        override fun foo() {}
        override fun bar() {}
    }

    class MyChildClass : MyClass {}

    class <!ABSTRACT_METHOD_NOT_IMPLEMENTED!>MyIllegalClass<!> : MyTrait, MyAbstractClass {}

    class <!ABSTRACT_METHOD_NOT_IMPLEMENTED!>MyIllegalClass2<!> : MyTrait, MyAbstractClass {
        override fun foo() {}
    }

    class <!ABSTRACT_METHOD_NOT_IMPLEMENTED!>MyIllegalClass3<!> : MyTrait, MyAbstractClass {
        override fun bar() {}
    }

    class <!ABSTRACT_METHOD_NOT_IMPLEMENTED!>MyIllegalClass4<!> : MyTrait, MyAbstractClass {
        fun <!VIRTUAL_METHOD_HIDDEN!>foo<!>() {}
        <!NOTHING_TO_OVERRIDE!>override<!> fun other() {}
    }

    class MyChildClass1 : MyClass {
        fun <!VIRTUAL_METHOD_HIDDEN!>foo<!>() {}
        override fun bar() {}
    }
}

namespace generics {
    trait MyTrait<T> {
        fun foo(t: T) : T
    }

    abstract class MyAbstractClass<T> {
        abstract fun bar(t: T) : T
    }

    open class MyGenericClass<T> : MyTrait<T>, MyAbstractClass<T> {
        override fun foo(t: T) = t
        override fun bar(t: T) = t
    }

    class MyChildClass : MyGenericClass<Int> {}
    class MyChildClass1<T> : MyGenericClass<T> {}
    class MyChildClass2<T> : MyGenericClass<T> {
        fun <!VIRTUAL_METHOD_HIDDEN!>foo<!>(t: T) = t
        override fun bar(t: T) = t
    }

    open class MyClass : MyTrait<Int>, MyAbstractClass<String> {
        override fun foo(i: Int) = i
        override fun bar(s: String) = s
    }

    class <!ABSTRACT_METHOD_NOT_IMPLEMENTED!>MyIllegalGenericClass1<!><T> : MyTrait<T>, MyAbstractClass<T> {}
    class <!ABSTRACT_METHOD_NOT_IMPLEMENTED!>MyIllegalGenericClass2<!><T, R> : MyTrait<T>, MyAbstractClass<R> {
        <!NOTHING_TO_OVERRIDE!>override<!> fun foo(r: R) = r
    }
    class <!ABSTRACT_METHOD_NOT_IMPLEMENTED!>MyIllegalClass1<!> : MyTrait<Int>, MyAbstractClass<String> {}

    class <!ABSTRACT_METHOD_NOT_IMPLEMENTED!>MyIllegalClass2<!><T> : MyTrait<Int>, MyAbstractClass<Int> {
        fun foo(t: T) = t
        fun bar(t: T) = t
    }
}