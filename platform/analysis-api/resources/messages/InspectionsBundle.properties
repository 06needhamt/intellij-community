inspection.diff.format.error=Required parameters: <old_file> <new_file> [<delta_file_name>]
inspection.command.line.explanation=Expected parameters: <project_file_path> <inspection_profile> <output_path> \
  <inspections_profile> -- use here profile name configured in the project or locally or path to the inspection profile; can be stabbed when one of the -e|-profileName|-profilePath is used\n\
  [<options>]\n \
  Available options are:\n \
  -d <directory_path>  --  directory to be inspected. Optional. Whole project is inspected by default.\n \
  -e                   --  skip  \n\
  -v[0|1|2]            --  verbose level. 0 - silent, 1 - verbose, 2 - most verbose. \n\
  -profileName         --  name of a profile defined in project \n \
  -profilePath         --  absolute path to the profile file \n \
  -format              --  report output format. Supported options: xml, json, plain. Defaults to xml \n \
  -changes             --  inspect uncommitted changes and report new problems

inspection.action.title=Inspection
inspection.action.noun=Inspection
inspection.action.profile.label=Inspection profile

inspection.disabled.title=Inspection disabled
inspection.problem.synopsis=Problem synopsis

#export results view
inspection.export.results.package=package
inspection.export.results.constructor=constructor
inspection.export.results.method=method
inspection.export.results.field=field
#can be final
inspection.can.be.final.display.name=Declaration can have final modifier
#dataflow
inspection.data.flow.display.name=Constant conditions \\& exceptions
inspection.data.flow.nullable.quickfix.option=Suggest @Nullable annotation for methods/fields/parameters where nullable values are used
inspection.data.flow.true.asserts.option=Don't report assertions with condition statically proven to be always <code>true</code>
inspection.data.flow.filter.notnull.quickfix=Insert 'filter(Objects::nonNull)' step
inspection.data.flow.use.computeifpresent.quickfix=Replace 'compute' with 'computeIfPresent'
#messages from dataflow inspection
inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> without ''isPresent()'' check

#deprecated
#empty method
inspection.empty.method.display.name=Empty method
inspection.empty.method.delete.quickfix=Delete unnecessary method(s)
inspection.empty.method.problem.descriptor=Method only calls its super
inspection.empty.method.problem.descriptor1=Empty method overrides empty method
inspection.empty.method.problem.descriptor2=The method is empty
inspection.empty.method.problem.descriptor3=The method and all its derivables are empty
inspection.empty.method.problem.descriptor4=All implementations of this method are empty

#redundant cast
inspection.redundant.cast.display.name=Redundant type cast
#redundant throws
inspection.redundant.throws.display.name=Redundant 'throws' clause
inspection.equals.hashcode.display.name='equals()' and 'hashCode()' not paired
inspection.equals.hashcode.only.one.defined.problem.descriptor=Class has {0} defined but does not define {1}
inspection.equals.hashcode.generate.equals.quickfix=Generate 'equals()'
inspection.equals.hashcode.generate.hashcode.quickfix=Generate 'hashCode()'

inspection.1.5.display.name=Usages of API which isn't available at the configured language level
inspection.1.5.problem.descriptor=Usage of API documented as @since {0}+
inspection.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
inspection.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
inspection.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}

inspection.return.separated.from.computation.name='return' separated from the result computation
inspection.return.separated.from.computation.descriptor=Return separated from computation of value of ''{0}''
inspection.return.separated.from.computation.quickfix=Move ''return'' closer to computation of the value of ''{0}''
inspection.return.separated.from.computation.family.quickfix=Move 'return' closer to computation of the result

inspection.notnull.field.not.initialized.display.name=@NotNull field is not initialized
inspection.notnull.field.not.initialized.option.implicit=Ignore fields which could be initialized implicitly
inspection.notnull.field.not.initialized.option.setup=Ignore fields initialized in setUp() method

inspection.nullable.problems.display.name=@NotNull/@Nullable problems
#check box options
inspection.nullable.problems.method.overrides.notnull.option=<html>Report @NotNull &parameters overriding @Nullable and <br>@Nullable methods overriding @NotNull</html>
inspection.nullable.problems.method.overrides.option=Report non-&annotated parameters or methods overriding @NotNull
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=Report non-annotated &setter parameters or getters of annotated fields
inspection.nullable.problems.ignore.external.notnull=&Ignore external @NotNull
inspection.nullable.problems.notnull.overrides.option=Report @NotNull &parameters overriding non-annotated
inspection.nullable.problems.notnull.parameters.with.null.literal.option=Report @NotNull parameters with null-literal argument usages

#problem descriptor messages
inspection.visibility.display.name=Declaration access can be weaker
#can be private|package-private|protected|public
inspection.field.can.be.local.display.name=Field can be local
inspection.field.can.be.local.problem.descriptor=Field can be converted to a local variable
inspection.parameter.can.be.local.display.name=Parameter can be local
inspection.parameter.can.be.local.problem.descriptor=Parameter can be converted to a local variable
inspection.convert.to.local.quickfix=Convert to local
inspection.field.can.be.local.quickfix.initializer=Convert field to local variable in initializer section
inspection.field.can.be.local.quickfix.constructor=Convert field to local variable in constructor
inspection.field.can.be.local.quickfix.one.method=Convert field to local variable in method ''{0}''

inspection.unused.return.value.display.name=Method can be void
inspection.unused.return.value.problem.descriptor=Return value of the method is never used
inspection.unused.return.value.make.void.quickfix=Make method 'void'

inspection.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated

inspection.same.parameter.display.name=Actual method parameter is the same constant
inspection.same.parameter.problem.descriptor=Actual value of parameter ''{0}'' is always ''{1}''

inspection.unused.assignment.display.name=Unused assignment
inspection.unused.assignment.option=Report ++i when may be replaced with (i + 1)
inspection.unused.assignment.option1=Report i++ when changed value is not used afterwards
inspection.unused.assignment.option2=Report redundant initializers
inspection.unused.assignment.remove.quickfix=Remove redundant initializer
inspection.unused.assignment.remove.assignment.quickfix=Remove redundant assignment
inspection.unused.assignment.problem.descriptor1=Variable {0} is never used
inspection.unused.assignment.problem.descriptor2=Variable {0} initializer {1} is redundant
inspection.unused.assignment.problem.descriptor3=The value {0} assigned to {1} is never used
inspection.unused.assignment.problem.descriptor4=The value changed at {0} is never used

inspection.unused.parameter.composer=Parameter <code>#ref</code> is not used in any implementation
inspection.unused.parameter.composer1=Parameter <code>#ref</code> is not used in either this method or any of its derived methods
inspection.unused.parameter.display.name=Unused method parameters
inspection.unused.parameter.delete.quickfix=Delete unused parameter(s)
inspection.redundant.array.creation.display.name=Redundant array creation
inspection.redundant.array.creation.quickfix=Remove explicit array creation
inspection.redundant.array.creation.for.varargs.call.descriptor=Redundant array creation for calling varargs method

inspection.raw.variable.type.can.be.generic.name=Raw type can be generic
inspection.raw.variable.type.can.be.generic.quickfix=Change type of {0} to {1}
inspection.raw.variable.type.can.be.generic.family.quickfix=Add generic parameters to the type

inspection.reference.default.package=<default>
inspection.export.save.button=Save
inspection.export.dialog.title=Export
inspection.export.options.panel.title=Options
inspection.export.open.option=Open generated HTML in &browser
inspection.export.title=Code Inspection results
inspection.export.generating.html.for=Generating HTML:{0}
inspection.export.error.writing.to=Error writing to {0}: {1}

inspection.common.if.parts.message.variables.only=Extract variables from ''if''{0}
inspection.common.if.parts.message.with.variables.extract=Extract common part with variables from ''if''{0}
inspection.common.if.parts.message.without.variables.extract=Extract common part from ''if''{0}
inspection.common.if.parts.message.whole.branch=Extract common part removing branch{0}
inspection.common.if.parts.message.complete.duplicate=Collapse ''if'' statement{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Collapse 'if' statement and extract side effect
inspection.common.if.parts.description.variables.only=Variables can be extracted from ''if''{0}
inspection.common.if.parts.description.with.variables.extract=Common parts with variables can be extracted from ''if''{0}
inspection.common.if.parts.description.without.variables.extract=Common part can be extracted from ''if''{0}
inspection.common.if.parts.description.whole.branch=Common part can be extracted removing branch{0}
inspection.common.if.parts.description.complete.duplicate=''if'' statement can be collapsed{0}
inspection.common.if.parts.description.complete.duplicate.side.effect='if' statement can be collapsed with side effect extraction


inspection.common.if.parts.description='if' statement with common parts

inspection.export.results.error.title=Inspection Results Export
inspection.export.inspections.link.text=Inspections
inspection.export.open.source.link.text=Open source
inspection.offline.view.empty.browser.text=<HTML><BODY>Select inspection result on the left to see details</BODY></HTML>
inspection.offline.view.tool.display.name.title=Name
inspection.generating.html.progress.title=Generating HTML...
inspection.generating.xml.progress.title=Dumping XML...
inspection.action.export.html=Export
inspection.action.export.popup.title=Export To
inspection.tool.description.under.construction.text=Under construction
inspection.tool.in.browser.id.title=ID
inspection.tool.in.browser.description.title=Description
inspection.action.edit.settings=Edit Settings
inspection.action.apply.quickfix=Apply a quickfix
inspection.action.apply.quickfix.description=Apply an inspection quickfix
inspection.tree.popup.title=Accept Resolution
inspection.action.rerun=Rerun Inspection
inspection.general.tools.group.name=General
inspection.invalid.node.text=(INVALID)
inspection.problem.descriptor.count={0, choice, 0#|1#(1 item)|2#({0,number,integer} items)}
inspection.action.go.next=Go Next Problem
inspection.action.go.prev=Go Prev Problem
inspection.action.suppress=Suppressing inspection ''{0}''
inspection.action.group.by.directory=Group by Directory

inspection.javadoc.display.name=Declaration has Javadoc problems
inspection.javadoc.ref.display.name=Declaration has problems in Javadoc references
inspection.javadoc.lint.display.name=HTML problems in Javadoc (DocLint)
inspection.javadoc.option.tab.title.package=Package
inspection.javadoc.option.tab.title.module=Module
inspection.javadoc.option.tab.title=Class
inspection.javadoc.option.tab.title.method=Method
inspection.javadoc.option.tab.title.field=Field
inspection.javadoc.option.tab.title.inner.class=Inner class
inspection.javadoc.option.ignore.deprecated=Ignore elements marked as @deprecated
inspection.javadoc.option.ignore.period=Ignore period problems
inspection.javadoc.option.ignore.throws=Ignore duplicate 'throws' tag
inspection.javadoc.option.ignore.self.ref=Ignore Javadoc pointing to itself
inspection.javadoc.option.ignore.simple=Ignore simple property accessors

inspection.scope.for.title=Scope

inspection.javadoc.required.tags.option.title=Required Tags
inspection.javadoc.problem.descriptor=Required Javadoc is absent
inspection.javadoc.problem.descriptor1=Period in the documentation is missing. The period is used by the Javadoc tool to generate the comment for the overview page
inspection.javadoc.problem.missing.tag=Required tag {0} is missing
inspection.javadoc.problem.missing.tag.description={0} is missing after @{1} tag
inspection.javadoc.problem.see.tag.expecting.ref=Class/method reference, quoted text, or HTML link are expected after @see tag
inspection.javadoc.problem.cannot.resolve=Cannot resolve symbol {0}
inspection.javadoc.problem.inaccessible=Symbol {0} is inaccessible from here
inspection.javadoc.problem.name.expected=Name expected
inspection.javadoc.problem.wrong.tag=Wrong tag {0}
inspection.javadoc.problem.disallowed.tag=Tag {0} is not allowed here
inspection.javadoc.method.problem.descriptor=Description is missing in {0} tag for parameter {1}
inspection.javadoc.method.problem.missing.tag.description={0} tag description is missing
inspection.javadoc.method.problem.missing.param.tag=Required tag <code>@param</code> is missing for parameter {0}
inspection.javadoc.problem.duplicate.param=Duplicate @param tag for parameter ''{0}''
inspection.javadoc.problem.duplicate.throws=Duplicate @throws or @exception tag for exception ''{0}''
inspection.javadoc.problem.duplicate.tag=Duplicate @{0} tag
inspection.javadoc.problem.add.tag=Add tag @{0} {1}
inspection.javadoc.problem.add.tag.family=Add missing Javadoc tag
inspection.javadoc.problem.add.param.tag.family=Add missing Javadoc param tag
inspection.javadoc.problem.add.param.tag=Add tag @param for parameter ''{0}''

inspection.export.results.abstract=abstract
inspection.export.results.static=static
inspection.export.results.initializer=initializer
inspection.export.results.implicit.constructor=implicit constructor of

inspection.quickfix.assert.family=Assert
inspection.assert.quickfix=Assert ''{0}''
inspection.surround.if.quickfix=Surround with ''if ({0}{1})''
inspection.replace.ternary.quickfix=Replace with ''{0} != null ?:''
inspection.replace.methodref.ternary.quickfix=Replace with null-checking lambda
inspection.surround.if.family=Surround with if
inspection.dependency.configure.button.text=Configure dependency rules
inspection.javadoc.label.text=Additional Javadoc Tags:
inspection.javadoc.dialog.title=Edit Additional Javadoc Tags
inspection.javadoc.html.not.required.label.text=Additional Not Required Html Attributes:
inspection.javadoc.html.not.required.dialog.title=Edit Additional Not Required Html Attributes
inspection.required.attributes.display.name=Missing required attribute

inspection.unused.symbol.check.localvars=Local variables
inspection.unused.symbol.check.fields=Fields:
inspection.unused.symbol.check.methods=Methods:
inspection.unused.symbol.check.accessors=Getters/setters
inspection.unused.symbol.check.classes=Classes:
inspection.unused.symbol.check.inner.classes=Inner classes:
inspection.unused.symbol.check.parameters=Parameters in

inspection.results.for.profile.toolwindow.title=''{0}'' Profile on {1}
inspection.results.for.inspection.toolwindow.title=''{0}'' Inspection on {1}
inspection.export.results.invalidated.item=invalidated item
inspection.export.results.extends.implements=Extends/implements
inspection.export.results.extended.implemented=Extended/implemented by
inspection.export.results.extended=Extended by
inspection.export.results.overrides.library.methods=Overrides library methods
inspection.export.results.overrides.implements=Overrides/implements
inspection.export.results.derived.methods=Derived methods
inspection.export.results.type.references=The following uses this type
inspection.export.results.suppress=Suppress
inspection.export.results.callees=Call chain
inspection.export.results.anonymous.ref.in.owner=in

inspection.display.name=Analyzing code ...

inspection.action.group.by.severity=Group by Severity
inspection.action.group.by.severity.description=Group Inspections By Severity
inspection.no.jdk.error.message=The JDK is not configured properly for this project. Inspection cannot proceed.
inspection.no.problems.dialog.title=Code Inspection
inspection.no.problems.message=No suspicious code found. {0} files processed in ''{1}''.
inspection.view.invalid.scope.message=Inspection scope is invalid.
inspection.error.loading.message=Error reading inspection profile {0, choice, 0#from {1}|1#}
inspection.errors.occurred.dialog.title=Errors Occurred
inspection.severity=Se&verity:
inspection.scopes.and.severities=Severity by Scope
inspection.description.title=Description:
inspection.as=As {0}
inspection.new.profile.dialog.title=Create new profile
inspection.unable.to.create.profile.dialog.title=Unable to Create Profile.
inspection.unable.to.create.profile.message=Inspection profile with name ''{0}'' already exists.
inspection.profile.unnamed=Unnamed
inspection.tool.availability.in.tree.node=(available for editor highlighting)
inspection.tool.availability.in.tree.node1=(available for Analyze|Inspect Code)
inspection.error.level.popup.menu.title=Choose Error Level
inspection.edit.severities.text=Edit severities...

inspection.application.starting.up=Starting up {0} ...
inspection.done=done.
inspection.capitalized.done=Done.
inspection.application.file.cannot.be.found=File {0} cannot be found
inspection.application.opening.project=Opening project...
inspection.application.initializing.project=Initializing project...
inspection.application.directory.cannot.be.found=Directory {0} cannot be found
inspection.application.project.has.older.format.and.will.be.converted=Project has an older format and will be converted.
inspection.application.project.was.succesfully.converted.old.project.files.were.saved.to.0=Project was succesfully converted. Old project files were saved to {0}
inspection.application.cannot.convert.project.0=Cannot convert project: {0}
inspection.application.cannot.convert.the.project.the.following.files.are.read.only.0=Cannot convert the project. The following files are read only: {0}

inspection.comparing.references.display.name=== used instead of equals()
inspection.comparing.references.use.quickfix=Use equals()
inspection.comparing.references.problem.descriptor=Suspicious comparison #ref #loc

inspection.dead.code.option.main=<html><code>void main(String args[])</code> methods</html>
inspection.dead.code.option.applet=Applets
inspection.dead.code.option.servlet=Servlets
inspection.dead.code.option.external=Classes with usages in non-Java files
inspection.export.results.dead.code=unused declaration
inspection.dead.code.comment=// --Commented out by Inspection
inspection.dead.code.date.comment=// --Commented out by Inspection ({0}):
inspection.dead.code.stop.comment=// --Commented out by Inspection STOP ({0})\n
inspection.dead.code.start.comment=// --Commented out by Inspection START ({0}):\n
inspection.dead.code.safe.delete.quickfix=Safe delete
inspection.dead.code.comment.quickfix=Comment out
inspection.dead.code.entry.point.quickfix=Add as Entry Point
inspection.dead.code.remove.user.defined.entry.point.quickfix=Remove User-defined Entry Points
inspection.dead.code.entry.points.display.name=Entry Points
inspection.dead.code.export.results.no.instantiations.found=No instantiations found.
inspection.dead.code.export.results.instantiated.from.heading=Instantiated from
inspection.dead.code.problem.synopsis=Field is never assigned.
inspection.dead.code.problem.synopsis1=Field has no usages.
inspection.dead.code.problem.synopsis2=Field is assigned but never accessed.
inspection.dead.code.problem.synopsis3=Field has one usage, but it is not reachable from entry points.
inspection.dead.code.problem.synopsis4=Field has {0, choice, 1#1 usage|2#{0,number} usages}, but they are not reachable from entry points.
inspection.dead.code.problem.synopsis6=Reachable. {0, choice, 1#1 usage|2#{0, number} usages} found in the project code.
inspection.dead.code.problem.synopsis6.suspicious=Not Reachable. {0, choice, 1#1 usage|2#{0, number} usages} found in the project code.
inspection.dead.code.problem.synopsis7.suspicious=Has no reachable instantiations. {0, choice, 0#No instantiations|1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis8.suspicious=Has no reachable implementation instantiations. {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis9.suspicious=Anonymous class context is not reachable. Class is not instantiated. {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis7=Has reachable instantiations. {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis8=Has reachable implementation instantiations. {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis9=Instantiated {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis10=Anonymous class declaration context is not reachable from entry points. Class is never instantiated.
inspection.dead.code.problem.synopsis11=No class references has been found. Class static initializer is not reachable.
inspection.dead.code.problem.synopsis12=Class has one instantiation, but it is not reachable from entry points.
inspection.dead.code.problem.synopsis13=Class is not instantiated.
inspection.dead.code.problem.synopsis14=<ul><li>Abstract method is not implemented OR</li><li>Implementation class is never instantiated OR</li><li>An instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis15=<ul><li>Method owner class is never instantiated OR</li><li>An instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis16=Method is never used.
inspection.dead.code.problem.synopsis17=Method has usage(s), but they all belong to the calls chain that has no members reachable from entry points.
inspection.dead.code.problem.synopsis18=Method is not reachable from entry points.
inspection.dead.code.problem.synopsis19=Class and {0, choice, 1#its implementation|2#{0,number} its implementations} are never instantiated.
inspection.dead.code.problem.synopsis20=Class has {0, choice, 1#instantiation|2#{0,number} instantiations}, but they are not reachable from entry points.

#{0} is class or interface (translated)
inspection.dead.code.problem.synopsis21=Method is never used as a member of this {0}, but only as a member of the implementation class(es). The project will stay compilable if the method is removed from the {0}.
inspection.dead.code.problem.synopsis22=Method overrides a library method but<ul><li>its {0} is never instantiated OR</li><li>its {0} instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis23={0} is not implemented.
inspection.dead.code.problem.synopsis24={0} has an implementation but <ul><li>it is never instantiated OR</li><li>no instantiations are reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis25={0} has {1, choice, 1#direct or indirect implementation|2#{1,number} direct or indirect implementations} but <ul><li>\u2014they are never instantiated OR</li><li>\u2014no instantiations are reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis26.constructor=Constructor is never used.
inspection.dead.code.problem.synopsis27.constructor=All constructor usages belong to the calls chain that has no members reachable from entry points.
inspection.dead.code.problem.synopsis28.constructor=Constructor has one usage, but it is not reachable from entry points.
inspection.dead.code.problem.synopsis29.constructor=Constructor has {0, choice, 1#usage|2#{0,number} usages}, but they are not reachable from entry points.

inspection.dead.code.problem.synopsis26.method=Method is never used.
inspection.dead.code.problem.synopsis27.method=All method usages belong to the calls chain that has no members reachable from entry points.
inspection.dead.code.problem.synopsis28.method=Method has one usage, but it is not reachable from entry points.
inspection.dead.code.problem.synopsis29.method=Method has {0, choice, 1#usage|2#{0,number} usages}, but they are not reachable from entry points.
inspections.dead.code.entry.points.annotations.list.title=Additional entry points annotations

inspection.duplicates.display.name=Duplicate string literal
inspection.duplicates.replace.family.quickfix=Replace
inspection.duplicates.replace.quickfix=Replace with ''{0}''
inspection.duplicates.navigate.to.occurrences=Navigate to occurrences
inspection.duplicates.option=&Min string length:
inspection.duplicates.occurrences.view.title=Duplicates for ''{0}''

inspection.duplicates.message.in.this.file=(in this file)
inspection.duplicates.message.more=... ({0} more)
inspection.duplicates.message=<html><body>Duplicate string literal found in<br>{0}</body></html>

inspection.redundant.requires.statement.name=Redundant 'requires' directive in module-info
inspection.forward.compatibility.name=Forward compatibility

inspection.root.node.title=Inspections

# inspection tools list actions:
inspection.tools.action.show.global.inspections.text=Hide Global Inspections
inspection.tools.action.show.global.inspections.description=Hide Global Inspections Settings
# hardcoded inspection tools
deprecated.symbol=Deprecated symbol
unused.import=Unused import (editor light)
unused.symbol=Unused symbol
redundant.throws.declaration=Redundant throws declaration
access.static.via.instance=Access static member via instance reference
wrong.package.statement=Wrong package statement
illegal.package.dependencies=Illegal package dependencies
unchecked.warning=Unchecked warning

# suppression stuff
suppress.inspection.family=Suppress inspection
suppress.inspection.statement=Suppress for statement
suppress.inspection.class=Suppress for class
suppress.inspection.member=Suppress for member
edit.dependency.rules.family=Edit dependency rules
edit.dependency.rules.text=Edit dependency rule \"{0} \"
error.analysis.is.in.progress=Error analysis is in progress
no.errors.found.in.this.file=No errors found in this file
edit.options.of.reporter.inspection.family=Edit options of reporter inspection
edit.options.of.reporter.inspection.text=Edit inspection profile setting

#Inspection group names
group.names.abstraction.issues=Abstraction issues
group.names.assignment.issues=Assignment issues
group.names.probable.bugs=Probable bugs
group.names.nullability.problems=Nullability problems
group.names.bitwise.operation.issues=Bitwise operation issues
group.names.class.structure=Class structure
group.names.class.metrics=Class metrics
group.names.compiler.issues=Compiler issues
group.names.potentially.confusing.code.constructs=Potentially confusing code constructs
group.names.encapsulation.issues=Encapsulation
group.names.error.handling=Error handling
group.names.try.statement=Try statement issues
group.names.logging.issues=Logging
group.names.finalization.issues=Finalization
group.names.imports=Imports
group.names.initialization.issues=Initialization
group.names.internationalization.issues=Internationalization
group.names.junit.issues=JUnit
group.names.code.maturity.issues=Code maturity
group.names.method.metrics=Method metrics
group.names.naming.conventions=Naming conventions
group.names.performance.issues=Performance
group.names.memory.issues=Memory
group.names.java.language.level.issues=Java language level issues
group.names.portability.issues=Portability
group.names.security.issues=Security
group.names.serialization.issues=Serialization issues
group.names.code.style.issues=Code style issues
group.names.threading.issues=Threading issues
group.names.verbose.or.redundant.code.constructs=Verbose or redundant code constructs
group.names.visibility.issues=Visibility
group.names.cloning.issues=Cloning issues
group.names.resource.management.issues=Resource management
group.names.j2me.issues=Embedded
group.names.control.flow.issues=Control flow issues
group.names.numeric.issues=Numeric issues
group.names.language.level.specific.issues.and.migration.aids=Java language level migration aids
group.names.language.level.specific.issues.and.migration.aids7=Java 7
group.names.language.level.specific.issues.and.migration.aids8=Java 8
group.names.language.level.specific.issues.and.migration.aids9=Java 9
group.names.language.level.specific.issues.and.migration.aids5=Java 5
group.names.language.level.specific.issues.and.migration.aids10=Java 10
group.names.language.level.specific.issues.and.migration.aids11=Java 11
group.names.language.level.specific.issues.and.migration.aids14=Java 14
group.names.javabeans.issues=JavaBeans issues
group.names.inheritance.issues=Inheritance issues
group.names.data.flow.issues=Data flow
group.names.declaration.redundancy=Declaration redundancy
group.names.javadoc.issues=Javadoc
group.names.concurrency.annotation.issues=Concurrency annotation issues
group.names.javaee.issues=Java EE
group.names.properties.files=Properties files
group.names.xml=XML
group.names.toString.issues=toString() issues
group.names.reflective.access.issues=Reflective access

duplicate.property.display.name=Duplicate Property
duplicate.property.diff.key.problem.descriptor=Duplicate Property Key ''{0}'' With Different Values #treeend :<br>
duplicate.property.diff.key.progress.indicator.text=Processing duplicate property key: {0}
duplicate.property.key.problem.descriptor=Duplicate Property Key ''{0}'' #treeend With Values:<br>
duplicate.property.key.progress.indicator.text=Processing duplicate property key:{0}
duplicate.property.value.problem.descriptor=Duplicate Property Value ''{0}'' #treeend With Keys:<br>
duplicate.property.value.progress.indicator.text=Processing duplicate property value: {0}
duplicate.property.diff.key.option=&Duplicate keys with different values
duplicate.property.value.option=Duplicate &values
duplicate.property.key.option=Duplicate &keys
duplicate.property.file.scope.option=&File scope
duplicate.property.module.scope.option=&Module Scope
duplicate.property.project.scope.option=&Project Scope
inspection.javadoc.throws.or.exception.option=@throws or @exception

suppress.inspection.annotation.syntax.error=Incorrect annotation syntax: {0}

default.file.template.report.file.header=Report Default file header
default.file.template.report.method.body=Report default created/overridden/implemented method body
default.file.template.report.catch.section=Report default catch section
default.file.template.description=Default File template
default.file.template.display.name=Default File Template Usage
default.file.template.edit.template=Edit template...
default.file.template.replace.with.actual.file.template=Replace with actual file template

#profile stuff
profile.assignments.display.name=Errors
profile.mapping.inspection.profile.column.title=inspection profile
profile.mapping.scope.column.title=scope
boolean.method.is.always.inverted.display.name=Boolean method is always inverted
boolean.method.is.always.inverted.problem.descriptor=Boolean method <code>#ref</code> is always inverted
inspection.results.title=Results By Editor Settings
unnecessary.module.dependency.exported.problem.descriptor1=Module ''{0}'' does not depend on ''{1}''. Though ''{0}'' depends on ''{2}'' through exported dependencies of ''{1}''
run.with.editor.settings.dialog.option=Run with &editor settings
inspection.new.profile.text=New Profile Name
profile.save.as.project.checkbox.title=Save as project profile
profile.save.as.ide.checkbox.title=Save as IDE profile
profile.assignment.repeatable.scope.warning=Repeatable scope. Correct assignments.
profile.ide.profile.radiobutton.title=IDE Profile
profile.project.radiobutton.title=Project Profile
profile.default.profile.title=Default Project Profile
profile.assignments.table.title=Project Inspection Profile Assignments
profile.assignments.browse.scope.button.title=&Browse ...
profile.assignments.browse.profile.scopes.dialog.title=Profiles Scopes
profile.quick.change.suggestion.message=<html>There are a few scopes configured for the project. Do you want to edit profile assignments on them?</html>
profile.quick.change.suggestion.dialog.title=Unable to switch profile
unhandled.exception.in.jsp.name=Unhandled Exception in JSP
inspection.no.modules.error.message=This project contains no modules. Inspection cannot proceed.
inspection.redundant.suppression.name=Redundant suppression
inspection.redundant.suppression.description=Redundant suppression
run.with.choosen.profile.dialog.option=Run with &chosen profile
disable.inspection.action.name=Disable inspection
group.names.packaging.issues=Packaging issues
group.names.dependency.issues=Dependency issues
group.names.modularization.issues=Modularization issues
run.inspection.on.file.intention.text=Run inspection on ...
severities.editor.dialog.title=Severities Editor
highlight.severity.create.dialog.title=New Highlight Severity
highlight.severity.create.dialog.name.label=Name
suspicious.name.combination.display.name=Suspicious variable/parameter name combination
suspicious.name.combination.options.title=Groups of names
suspicious.name.combination.options.prompt=Enter a comma-separated list of names:
suspicious.name.combination.add.title=Add Group of Names
suspicious.name.combination.edit.title=Edit Group of Names

special.annotations.list.add.annotation.class=Add Annotation Class
special.annotations.list.annotation.class=Annotation Class
special.annotations.list.remove.annotation.class=Remove Annotation Class
dependency.injection.annotations.list=Additional Dependency Injection Annotations
special.annotations.annotations.list=Additional Special Annotations

inspection.filter.resolved.action.text=Filter resolved items
inspection.filter.show.diff.action.text=Show diff
inspection.filter.show.diff.only.action.text=Show diff only
inspection.new.profile.ide.to.project.warning.message=Do you want to save selected IDE profile as project profile?
inspection.new.profile.ide.to.project.warning.title=Unable to set up IDE profile for scope
profile.project.settings.banner=Project Profiles Settings
profile.project.display.name=Project Profiles
profile.banner.text=Inspection profile: {0} {1, choice, 0#(inactive)|1#}
profile.ide.tree.text=IDE Profiles
profile.ide.settings.banner=IDE Profiles Settings
profile.project.settings.disable.text=< Use IDE Profile >
errors.single.profile.title=Errors: ''{0}'' inspection profile
rename.inspection.profile=Rename inspection profile
rename.message.prefix.inspection.profile=Inspection profile
default.ide.profile.label.text=Default IDE profile:
profile.lock.action.text=Lock
profile.unlock.action.text=Unlock
profile.activate.action.text=Set as project default
profile.project.activate.action.text=Set as IDE default
inspection.annotate.quickfix.overridden.method.messages=Method {0} {1} method {2}.\nAnnotate the base method as well?
inspection.annotate.quickfix.overridden.method.warning=Overridden Method Warning
inspection.annotate.quickfix.implements=implements
inspection.annotate.quickfix.overrides=overrides
offline.inspections.jdk.not.found={0} not found
offline.inspections.module.jdk.not.found=Please, specify sdk ''{0}'' for module ''{1}''
inconsistent.resource.bundle.display.name=Inconsistent resource bundle
inconsistent.bundle.property.error=Inconsistent property ''{0}''. Must be defined in the parent file ''{1}''.
inconsistent.bundle.untranslated.property.error=Untranslated property ''{0}''. Should be overridden in the ''{1}''.
inconsistent.bundle.report.missing.translations=Report &missing translations
inconsistent.bundle.report.inconsistent.properties=Report &inconsistent properties
inconsistent.bundle.report.duplicate.properties.values=Report properties &overridden with the same value
inconsistent.bundle.report.inconsistent.properties.placeholders=Report properties with inconsistent &placeholders
inconsistent.bundle.report.inconsistent.properties.ends=Report properties with inconsistent &ends
inconsistent.bundle.property.inconsistent.placeholders=Inconsistent count of placeholders: found {0} in ''{1}''
inconsistent.bundle.property.inconsistent.end.parent.end.from.check.symbols=Inconsistent property value end ''{0}'' but found ''{1}'' in ''{2}''
inconsistent.bundle.property.inconsistent.end=Inconsistent property value end ''{0}''
inconsistent.bundle.property.inherited.with.the.same.value=Property inherited from the ''{0}'' file with the same value
edit.inspection.options=Edit ''{0}'' Options
offline.view.title=Offline View
offline.view.editor.settings.title=Editor Settings
offline.view.parse.exception.title=An Error Occurred While Parsing XML
parsing.inspections.dump.progress.title=Parsing Inspections XML Dump

suppress.inspection.problem=Suppress
inspections.view.options.title=Inspection {0} options
offline.inspections.library.was.not.resolved=Please configure library ''{0}'' which is used in module ''{1}''
offline.inspections.library.urls.were.not.resolved=Roots {0} of the library ''{1}'' from module ''{2}'' were not resolved
offline.inspections.no.source.roots=No source roots detected for module ''{0}''
unused.library.backward.analysis.job.description=Perform backward analysis
inspection.duplicates.option.report.propertykey.expressions=&Ignore @PropertyKey expressions
inspection.same.parameter.fix.name=Inline value ''{1}'' for parameter ''{0}''
inspection.same.parameter.fix.family.name=Inline parameter as constant value
fix.all.inspection.problems.in.file=Fix all ''{0}'' problems in file
severities.default.settings.message=Edit Settings|Colors \\& Fonts
unsupported.character.for.the.charset=Unsupported characters for the charset ''{0}''
lossy.encoding=Lossy encoding
non.ascii.characters=Non-ASCII characters
inspection.duplicated.code.display.name=Duplicated Code
inconsistent.line.separators=Inconsistent line separators
inspection.unused.symbol.public.method.parameters=Check parameters in &Non-private methods
introduce.constant.across.the.project=Introduce constant across the project
inspection.application.chosen.profile.log.message=Inspecting with profile ''{0}''
inspection.javadoc.problem.pointing.to.itself=Javadoc pointing to itself

inspection.illegal.character=Illegal character

nothing.found=Nothing found
special.annotations.list.annotation.pattern=Add Annotations Pattern

inspection.variable.assigned.to.itself.display.name=Variable is assigned to itself
assignment.to.itself.problem.descriptor=Variable ''{0}'' is assigned to itself
assignment.to.declared.variable.problem.descriptor=Variable ''{0}'' is initialized with self assignment
assignment.to.itself.quickfix.name=Remove self assignment

problematic.whitespace.display.name=Problematic whitespace
problematic.whitespace.tabs.problem.descriptor=File ''{0}'' uses tabs for indentation
problematic.whitespace.spaces.problem.descriptor=File ''{0}'' uses spaces for indentation
problematic.whitespace.show.whitespaces.quickfix=Toggle show whitespace in the editor

todo.comment.display.name=TODO comment
todo.comment.problem.descriptor=TODO comment <code>#ref</code> #loc
long.line.display.name=Line is longer than allowed by code style

inspection.default.annotation.param=Default annotation parameter value
preparing.for.apply.fix=Preparing to Apply Fix...
inspection.tool.window.dialog.title=Inspection Tool Window
inspection.tool.window.dialog.no.options=Inspection ''{0}'' has no configurable options
inspection.tool.window.inspection.dialog.title=Inspection ''{0}'' options
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=Navigate to 'null' argument usages
nullable.stuff.inspection.navigate.null.argument.usages.view.name=''null'' argument usages for parameter {0}

inspection.excessive.lambda.message=Excessive lambda usage
inspection.excessive.lambda.fix.family.name=Replace lambda with constant
inspection.excessive.lambda.fix.name=Use ''{0}'' method without lambda

inspection.explicit.argument.can.be.lambda.message=Explicit argument can be converted to lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=Replace explicit argument with function
inspection.explicit.argument.can.be.lambda.fix.name=Use ''{0}'' method with functional argument

inspection.lambda.to.method.call.fix.family.name=Replace lambda expression with method call
inspection.lambda.to.method.call.fix.name=Replace lambda expression with ''{0}''

naming.convention.problem.descriptor.short={0} name <code>#ref</code> is too short ({1} \\&lt; {2}) #loc
naming.convention.problem.descriptor.long={0} name <code>#ref</code> is too long ({1} \\&gt; {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} name <code>#ref</code> doesn''t match regex ''{1}'' #loc

inspection.replace.with.bulk.message=Iteration can be replaced with bulk ''{0}'' call
inspection.replace.with.bulk.fix.name=Replace iteration with bulk ''{0}'' call
inspection.replace.with.bulk.fix.family.name=Replace with bulk method call
inspection.replace.with.bulk.wrap.arrays=Use Arrays.asList() to wrap arrays
inspection.explicit.array.filling.fix.family.name=Replace loop with ''Arrays.{0}()'' method call
inspection.explicit.array.filling.redundant.loop.description=Redundant initialization of a newly created array
inspection.explicit.array.filling.description=Can be replaced with single ''Arrays.{0}()'' method call
inspection.explicit.array.filling.suggest.set.all=Suggest 'Arrays.setAll()'
inspection.explicit.array.filling.no.suggestion.for.set.all=Do not suggest to use 'Arrays.setAll()'

inspection.simplify.collector.message=Can be simplified using ''{0}'' collector
inspection.simplify.collector.fix.family.name=Simplify cascaded collector
inspection.simplify.collector.fix.name=Use ''Collectors.{0}'' collector

inspection.require.non.null=Replace null check with Objects/Stream static call
inspection.require.non.null.message=Replace condition with {0}
inspection.require.non.null.description=Null check can be replaced with method call
inspection.require.non.null.no.warning.replacement.bigger=Don't warn if length of replacement bigger than original
inspection.require.non.null.option.min.size=Minimal delta length when inspection will warn

inspection.redundant.stream.optional.call.message=Redundant ''{0}'' call
inspection.redundant.stream.optional.call.explanation.filter=predicate is always true
inspection.redundant.stream.optional.call.explanation.sorted=subsequent ''{0}'' call doesn''t depend on the sort order
inspection.redundant.stream.optional.call.explanation.sorted.twice=stream content is sorted again after that
inspection.redundant.stream.optional.call.explanation.distinct=there already was a 'distinct' call in the chain
inspection.redundant.stream.optional.call.explanation.distinct.set=elements will be distinct anyways when collected to the Set
inspection.redundant.stream.optional.call.explanation.unordered=there already was an 'unordered' call in the chain
inspection.redundant.stream.optional.call.explanation.parallel=there''s subsequent ''{0}'' call which overrides this call
inspection.redundant.stream.optional.call.explanation.at.most.one=stream contains at most one element
inspection.redundant.stream.optional.call.explanation.parallel.single=stream created from single element will not be parallelized
inspection.redundant.stream.optional.call.explanation.map.flatMap=previous 'map' call can replace the 'flatMap' step
inspection.redundant.stream.optional.call.fix.family.name=Remove redundant chain call
inspection.redundant.stream.optional.call.fix.name=Remove ''{0}'' call
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=Collect to 'LinkedHashSet'
inspection.redundant.stream.optional.call.option.streamboxing=Report redundant boxing in Stream.map

inspection.map.foreach.display.name=Map.forEach() can be used
inspection.map.foreach.option.no.loops=Do not report loops

inspection.simplify.foreach.display.name=Simplifiable forEach() call

inspection.collection.factories.message=Can be replaced with ''{0}.{1}'' call
inspection.collection.factories.option.ignore.non.constant=Do not warn when content is non-constant
inspection.collection.factories.option.suggest.ofentries=Suggest 'Map.ofEntries'
inspection.collection.factories.fix.family.name=Replace with collection factory call
inspection.collection.factories.fix.name=Replace with ''{0}.{1}'' call

inspection.null.value.for.optional.message=Null is used for ''Optional'' type in {0}
inspection.null.value.for.optional.fix.family.name=Replace with empty Optional method
inspection.null.value.for.optional.assigned.message=Optional value is compared with null
inspection.null.value.for.optional.assigned.ignore.fix.name=Do not warn when comparing Optional with null
inspection.null.value.for.optional.context.assignment=assignment
inspection.null.value.for.optional.context.parameter=parameter
inspection.null.value.for.optional.context.lambda=lambda expression
inspection.null.value.for.optional.context.return=return statement
inspection.null.value.for.optional.context.declaration=declaration

inspection.handle.signature.name=MethodHandle/VarHandle type mismatch
inspection.handle.signature.field.static=Field ''{0}'' is static
inspection.handle.signature.field.not.static=Field ''{0}'' is not static
inspection.handle.signature.field.type=The type of field ''{0}'' is ''{1}''
inspection.handle.signature.field.cannot.resolve=Cannot resolve field ''{0}''
inspection.handle.signature.method.static=Method ''{0}'' is static
inspection.handle.signature.method.not.static=Method ''{0}'' is not static
inspection.handle.signature.method.abstract=Method ''{0}'' is abstract in ''{1}''
inspection.handle.signature.not.subclass=Caller class ''{0}'' must be a subclass of ''{1}''

inspection.handle.signature.change.type.fix.name=Change type to ''{0}''
inspection.handle.signature.replace.with.fix.name=Replace with ''{0}''
inspection.handle.signature.use.method.fix.family.name=Use one of method overloads
inspection.handle.signature.use.method.fix.name=Use method ''{0}''
inspection.handle.signature.use.constructor.fix.family.name=Use one of constructor overloads
inspection.handle.signature.use.constructor.fix.name=Use constructor ''{0}''

inspection.reflection.invocation.name=Reflective invocation arguments mismatch
inspection.reflection.invocation.argument.count={0,choice,0#No arguments are|1#One argument is|1<{0} arguments are} expected
inspection.reflection.invocation.item.count={0,choice,0#Empty array is|1#Single-item array is|1<{0} array items are} expected
inspection.reflection.invocation.argument.not.assignable=Argument is not assignable to ''{0}''
inspection.reflection.invocation.item.not.assignable=Array item is not assignable to ''{0}''
inspection.reflection.invocation.array.not.assignable=Array {0,choice,1#item has|1<items have} incompatible {0,choice,1#type|1<types}

inspection.reflect.handle.invocation.receiver.null=Call receiver is 'null'
inspection.reflect.handle.invocation.receiver.incompatible=Call receiver type is incompatible: ''{0}'' is expected
inspection.reflect.handle.invocation.argument.not.exact=Argument type should be exactly ''{0}''
inspection.reflect.handle.invocation.result.not.exact=Should be cast to ''{0}''
inspection.reflect.handle.invocation.result.not.assignable=Should be cast to ''{0}'' or its superclass
inspection.reflect.handle.invocation.argument.not.array=Argument is not an array type
inspection.reflect.handle.invocation.primitive.argument.null=Argument of type ''{0}'' cannot be ''null''
inspection.reflect.handle.invocation.result.void=Return type is 'void'
inspection.reflect.handle.invocation.result.null=Returned value is always 'null'

inspection.implicit.subclass.display.forMethod=Method ''{0}'' should be overridable
inspection.reflection.visibility.name=Reflective access across modules issues

inspection.reflection.member.access.name=Reflective access to nonexistent/not visible class member
inspection.reflection.member.access.cannot.resolve.field=Cannot resolve field ''{0}''
inspection.reflection.member.access.field.not.in.class=Field ''{0}'' is not declared in class ''{1}''
inspection.reflection.member.access.field.not.public=Field ''{0}'' is not public
inspection.reflection.member.access.cannot.resolve.method=Cannot resolve method ''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=Cannot resolve method ''{0}'' with specified argument types
inspection.reflection.member.access.method.not.in.class=Method ''{0}'' is not declared in class ''{1}''
inspection.reflection.member.access.method.not.public=Method ''{0}'' is not public
inspection.reflection.member.access.cannot.resolve.constructor.arguments=Cannot resolve constructor with specified argument types
inspection.reflection.member.access.constructor.not.public=Constructor is not public
inspection.reflection.member.access.check.exists=Check that field/method exists in non-final classes
inspection.reflection.member.access.check.exists.exclude=Exclude classes
inspection.reflection.member.access.check.exists.exclude.chooser=Class to exclude
inspection.reflection.member.access.fix.family.name=Use appropriate reflection method

inspection.replace.with.trivial.lambda.fix.family.name=Replace with trivial lambda
inspection.replace.with.trivial.lambda.fix.name=Replace with lambda returning ''{0}''

inspection.redundant.null.check.message=Redundant null-check: {0} is never null
inspection.redundant.null.check.always.fail.message=Null-check will always fail: {0} is never null
inspection.redundant.null.check.fix.family.name=Remove redundant null-check
inspection.redundant.null.check.fix.notnull.family.name=Remove erroneous '!= null'

inspection.comparator.result.comparison.display.name=Suspicious usage of compare method
inspection.comparator.result.comparison.problem.display.name=Comparison of compare method result with specific constant
inspection.comparator.result.comparison.fix.family.name=Fix comparator result comparison

module.not.in.requirements=The module ''{0}'' does not have the module ''{1}'' in requirements
module.package.not.exported=The module ''{0}'' does not export the package ''{1}'' to the module ''{2}''
module.package.not.open=The module ''{0}'' does not open the package ''{1}'' to the module ''{2}''
psi.search.overriding.progress=Searching for Overriding Methods...
inspection.fuse.stream.operations.fix.family.name=Fuse more statements to the Stream API chain
inspection.fuse.stream.operations.fix.name=Fuse {0} into the Stream API chain
inspection.fuse.stream.operations.message=Stream may be extended replacing {0}
inspection.fuse.stream.operations.display.name=Subsequent steps can be fused into Stream API chain
inspection.fuse.stream.operations.option.strict.mode=Do not suggest 'toList()' or 'toSet()' collectors

inspection.overwritten.key.set.message=Duplicate Set element
inspection.overwritten.key.map.message=Duplicate Map key
navigate.to.duplicate.fix=Navigate to duplicate

inspection.idempotent.loop.body=Idempotent loop body

inspection.undeclared.service.usage.name=Usage of service not declared in 'module-info'
inspection.undeclared.service.usage.message=Usage of service ''{0}'' is not declared in module-info

inspection.conditional.break.in.infinite.loop=Move condition to loop
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=Don't suggest to replace with 'do while'
inspection.conditional.break.in.infinite.loop.description=Conditional break inside infinite loop

inspection.endless.stream.description=Non-short-circuit operation consumes infinite stream

inspection.simplifiable.comparator.display.name=Comparator can be simplified
inspection.simplifiable.comparator.comparing.message=Unnecessary ''{0}()'' call
inspection.simplifiable.comparator.reversed.message=Comparator can be simplified if ''{0}()'' call is replaced with ''{1}()''
inspection.simplifiable.comparator.entry.comparator.message=''{0}'' can be used instead
inspection.simplifiable.comparator.fix.comparing.family.name=Remove redundant call
inspection.simplifiable.comparator.fix.remove.name=Remove ''{0}()'' call
inspection.simplifiable.comparator.fix.replace.name=Remove ''{0}()'' call and use ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=Simplify comparator replacing 'max' with 'min'
inspection.simplifiable.comparator.fix.reversed.name=Replace with ''{0}'' simplifying the comparator
inspection.simplifiable.comparator.fix.entry.comparator.family.name=Use predefined Map.Entry comparator

inspection.capturing.cleaner=Runnable passed to Cleaner.register() captures ''{0}'' reference
inspection.capturing.cleaner.description=Cleaner captures object reference

inspection.redundant.explicit.close=Redundant 'close()'
inspection.fold.expression.into.stream.display.name=Expression can be folded into Stream chain
inspection.fold.expression.into.stream.fix.name=Fold expression into Stream chain
inspection.fold.expression.into.string.display.name=Expression can be folded into 'String.join'
inspection.fold.expression.into.string.fix.name=Fold expression into 'String.join'
inspection.fold.expression.fix.family.name=Fold expression
inspection.text.block.migration.name=Text block can be used
inspection.text.block.migration.message={0} can be replaced with text block
inspection.text.block.migration.suggest.literal.replacement=Suggest to replace string with line breaks
inspection.replace.with.text.block.fix=Replace with text block

inspection.text.block.backward.migration.name=Text block can be replaced with regular string literal
inspection.text.block.backward.migration.message=Text block can be converted to regular string literal
inspection.replace.with.regular.string.literal.fix=Replace with regular string literal

inspection.charset.object.can.be.used.display.name=Standard Charset object can be used
inspection.charset.object.can.be.used.message={0} can be used instead
inspection.charset.object.can.be.used.fix.family.name=Use Charset constant
inspection.charset.object.can.be.used.fix.name=Replace with ''{0}''

inspection.suspicious.list.remove.display.name=Suspicious 'List.remove()' in the loop

inspection.cast.can.be.removed.narrowing.variable.type.name=Too weak variable type leads to unnecessary cast
inspection.cast.can.be.removed.narrowing.variable.type.message=Cast may be removed by changing the type of ''{0}'' to ''{1}''
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=Change variable type and remove cast
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=Change type of ''{0}'' to ''{1}'' and remove cast

inspection.wrapper.type.may.be.primitive.name=Type may be primitive
inspection.wrapper.type.may.be.primitive.fix.name=Convert wrapper type to primitive

redundant.backticks.around.raw.string.literal.display.name=Redundant backticks around raw string literal
inspection.duplicate.expressions.display.name=Multiple occurrences of the same expression
inspection.duplicate.expressions.message=Multiple occurrences of <code>#ref</code> #loc
inspection.duplicate.expressions.complexity.threshold=Expression complexity threshold
inspection.duplicate.expressions.introduce.variable.fix.family.name=Introduce variable
inspection.duplicate.expressions.introduce.variable.fix.name=Introduce variable for ''{0}''
inspection.duplicate.expressions.reuse.variable.fix.family.name=Reuse variable
inspection.duplicate.expressions.reuse.variable.fix.name=Reuse variable ''{0}'' for ''{1}''
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=Replace with variable other occurrences of expression
inspection.duplicate.expressions.replace.other.occurrences.fix.name=Replace with ''{0}'' other occurrences of ''{1}''

inspection.sorted.collection.with.non.comparable.keys.display.name=Sorted collection with non-comparable elements
inspection.sorted.collection.with.non.comparable.keys.message=Construction of sorted collection with non-comparable elements
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=Don't report non-comparable type parameters

inspection.join.declaration.and.assignment.display.name=Assignment can be joined with declaration
inspection.join.declaration.and.assignment.message=Assignment can be joined with declaration of ''{0}''
inspection.join.declaration.and.assignment.fix.family.name=Join declaration and assignment

inspection.overflowing.loop.index.inspection.name=Loop executes zero or billions times
inspection.overflowing.loop.index.inspection.description=Loop executes zero or billions times

inspection.switch.expression.migration.inspection.name=Statement can be replaced with enhanced 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch statement can be replaced with enhanced 'switch'
inspection.switch.expression.migration.warn.only.on.expression=Show warning only if conversion to expression is possible
inspection.switch.expression.migration.inspection.if.name=If statement can be replaced with enhanced 'switch'
inspection.replace.with.switch.expression.fix.name=Replace with 'switch' expression
inspection.replace.with.enhanced.switch.statement.fix.name=Replace with enhanced 'switch' statement

inspection.switch.expression.backward.migration.inspection.name=New style 'switch' can be replaced with old style one
inspection.switch.expression.backward.expression.migration.inspection.name='switch' expression can be replaced with old style 'switch' statement
inspection.switch.expression.backward.statement.migration.inspection.name='switch' statement can be replaced with old style 'switch' statement
inspection.replace.with.old.style.switch.statement.fix.name=Replace with old style 'switch' statement

inspection.duplicate.branches.in.switch.display.name=Duplicate branches in 'switch'
inspection.duplicate.branches.in.switch.message=Duplicate branch in 'switch'
inspection.duplicate.branches.in.switch.default.message=Branch in 'switch' is a duplicate of the default branch
inspection.duplicate.branches.in.switch.merge.fix.family.name=Merge duplicate branches in 'switch'
inspection.duplicate.branches.in.switch.merge.fix.name=Merge with ''{0}''
inspection.duplicate.branches.in.switch.delete.fix.family.name=Delete redundant 'switch' branches
inspection.duplicate.branches.in.switch.delete.fix.name=Delete redundant 'switch' branch
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=Merge with the default 'switch' branch

inspection.switch.labeled.rule.can.be.code.block.display.name=Labeled switch rule can have code block
inspection.switch.labeled.rule.can.be.code.block.expression.message=Labeled rule's result expression can be wrapped with code block
inspection.switch.labeled.rule.can.be.code.block.statement.message=Labeled rule's statement can be wrapped with code block
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=Wrap labeled rule's result expression with code block
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=Wrap labeled rule's statement with code block

inspection.labeled.switch.rule.redundant.code.block.display.name=Labeled switch rule has redundant code block
inspection.labeled.switch.rule.redundant.code.block.message=Labeled rule's code block is redundant
inspection.labeled.switch.rule.redundant.code.fix.name=Unwrap code block of labeled rule

inspection.redundant.operation.on.empty.container.display.name=Redundant operation on empty container
inspection.redundant.operation.on.empty.array.message=Array <code>#ref</code> is always empty
inspection.redundant.operation.on.empty.collection.message=Collection <code>#ref</code> is always empty
inspection.redundant.operation.on.empty.map.message=Map <code>#ref</code> is always empty

inspection.collection.used.as.vararg.display.name=Iterable is used as vararg
inspection.collection.used.as.vararg.message=Iterable is passed as vararg: probably an array was intended
inspection.manual.min.max.calculation.description=Can be replaced with ''Math.{0}'' call
inspection.manual.min.max.calculation.disable.for.non.integral=Disable for float and double

inspection.null.value.for.optional.option.comparisons=Report comparison of Optional with null

action.DumbAware.SingleInspectionProfilePanel.text.reset.to.empty=Reset to Empty
action.DumbAware.SingleInspectionProfilePanel.description.reset.to.empty=Reset to Empty

inspection.redundant.record.constructor.description=Redundant record constructor
inspection.redundant.record.constructor.compact.message=Redundant compact constructor
inspection.redundant.record.constructor.statement.message=Redundant field assignment in compact constructor
inspection.redundant.record.constructor.canonical.message=Redundant canonical constructor
inspection.redundant.record.constructor.can.be.compact.message=Canonical constructor can be converted to compact form
inspection.redundant.record.constructor.fix.family.name=Convert canonical constructor to compact form
action.presentation.ScopesChooser.text=In All Scopes
replace.with.0=Replace with {0}
replace.with=Replace with <>
replace.with.java.stream.api.pipeline=Replace with Java Stream API pipeline
pseudo.functional.style.code=Pseudo functional style code
remove.not.null.annotation=Remove not-null annotation
higher.than=Higher than:
respecting.to.project.language.level.settings=Respecting to project language level settings
forbid.api.usages=Forbid API usages:
deprecated.members=Deprecated members
finding.cause=Finding Cause
find.cause=Find cause
replace.with.magic.constant=Replace with magic constant
wrap.with.mutable.collection=Wrap with mutable collection
wrap.0.with.1=Wrap ''{0}'' with ''{1}''
entry.points=Entry points
members.to.report=Members to report
replace.with.stream.api.equivalent=Replace with Stream API equivalent
use.flatmap=Use 'flatMap'
0.may.not.work.before.jdk.11.0.2={0} (may not work before JDK 11.0.2)
can.be.replaced.with.files.readstring=Can be replaced with 'Files.readString()'
suggest.replacement.even.if.lambda.may.have.side.effects=Suggest replacement even if lambda may have side effects
treat.get.k.null.the.same.as.containskey.k.may.change.semantics=Treat 'get(k) != null' the same as 'containsKey(k)' (may change semantics)
suggest.conversion.to.map.replaceall=Suggest conversion to Map.replaceAll
suggest.conversion.to.map.merge=Suggest conversion to Map.merge
suggest.conversion.to.map.putifabsent=Suggest conversion to Map.putIfAbsent
suggest.conversion.to.map.getordefault=Suggest conversion to Map.getOrDefault
suggest.conversion.to.map.computeifabsent=Suggest conversion to Map.computeIfAbsent
avoid.mutation.using.stream.api=Avoid mutation using Stream API
avoid.mutation.using.stream.api.0.operation=Avoid mutation using Stream API ''{0}'' operation
simplify.foreach.lambda=Simplify forEach lambda
can.be.replaced.with.string.repeat=Can be replaced with 'String.repeat()'
add.math.max.0.count.to.avoid.possible.semantics.change=Add Math.max(0, count) to avoid possible semantics change
remove.redundant.parameter=Remove redundant parameter
redundant.default.parameter.value.assignment=Redundant default parameter value assignment
replace.optional.chain.with.if.statements=Replace Optional chain with if statements
replace.optional.with.if.statements=Replace Optional with if statements
configure.code.patterns=Configure Code Patterns
code.patterns=Code patterns...
annotations=Annotations...
configure.annotations=Configure Annotations
maximal.reported.method.visibility=Maximal reported method visibility:
ignore.simple.setters=Ignore simple setters
replace.filter.0.is.present.with.any.match=Replace ''filter().{0}().isPresent()'' with ''anyMatch()''
replace.collect.0.with.1.2=Replace ''collect({0}())'' with ''{1}''{2}
replace.stream.0.with.1.2=Replace ''stream().{0}()'' with ''{1}()''{2}
replace.0.stream.with.1.2=Replace {0}.stream() with {1}.{2}()
simplify.stream.call.chain=Simplify stream call chain
can.be.replaced.with.0.constructor=Can be replaced with ''{0}'' constructor
constructors=constructors
warn.if.the.loop.is.trivial=Warn if the loop is trivial
warn.if.only.foreach.replacement.is.available=Warn if only 'forEach' replacement is available
search.for.overriding.methods=Search for Overriding Methods...
minimal.reported.method.usage.count=Minimal reported method usage count:
minimal.reported.method.visibility=Minimal reported method visibility:
replace.with.optional.of.nullable.chain=Replace with Optional.ofNullable() chain
may.change.semantics=\ (may change semantics)
can.be.replaced.with.optional.of.nullable=Can be replaced with Optional.ofNullable()
replace.with.method.reference=Replace with method reference
anonymous.ref.loc.can.be.replaced.with.method.reference=Anonymous #ref #loc can be replaced with method reference
replace.cast.type=Replace cast type
annotate.local.variables=Annotate local variables
preprocess.usages=Preprocess Usages
jetbrains.annotations.library.is.missing=JetBrains annotations library is missing.\nWithout the library, IntelliJ IDEA cannot run the analysis. Would you like to add it?
infer.nullity.annotations.requires.the.project.language.level=Infer Nullity Annotations requires the project language level be set to 1.5 or greater.
check.applicability=Check Applicability...
infer.nullity=Infer Nullity
infer.nullity.results=Infer Nullity Results
no.places.found.to.infer.nullable.notnull=No places found to infer @Nullable/@NotNull
replace.inefficient.stream.count=Replace inefficient Stream.count()
comments.and.javadoc.count.as.content=Comments and javadoc count as content
edit.method.contract=Edit method contract
mutates=Mutates:
contract=Contract:
add.method.contract.to.0=Add method contract to ''{0}''
edit.method.contract.of.0=Edit method contract of ''{0}''
edit.range=Edit range
to.inclusive=To (inclusive):
from.inclusive=From (inclusive):
add.range.to.0=Add range to ''{0}''
edit.range.of.0=Edit range of ''{0}''
ignore.fields.used.in.multiple.methods=Ignore fields used in multiple methods
optimize.imports=Optimize Imports...
find.references.in.implement.extends.lists=Find References in Implement/Extends Lists...
replace.implements.with.static.import=Replace implements with static import
replace.optional.ispresent.condition.with.functional.style.expression=Replace Optional.isPresent() condition with functional style expression
can.be.replaced.with.single.expression.in.functional.style=Can be replaced with single expression in functional style
unimplement.interface.class=Unimplement Interface/Class
unimplement.0=Unimplement {0}
replace.stream.api.chain.with.loop=Replace Stream API chain with loop
iterate.unknown.stream.sources.via.stream.iterator=Iterate unknown Stream sources via Stream.iterator()
remove.redundant.parameter.types=Remove redundant parameter types
lambda.parameter.type.is.redundant=Lambda parameter type is redundant
remove.tag=Remove tag
remove.0.1=Remove @{0} {1}
change.to=Change to ...
html.report.inaccessible.symbols=<html>Report inaccessible symbols<br>(javadoc tool may be unable to create hyperlink)
entry.points.label=Entry points:
unused.declaration.unused.option=unused
unused.declaration.used.option=used
unused.declaration.reachable.from.tests.option=When entry points are in test sources, mark callees as:
inspection.suspicious.names.ignore.methods.title=Ignore methods
new.line.0=New line ({0})
edit.property.value=Edit property value
annotate.capitalization.type=Annotate capitalization type
title.capitalization.fix.family.name=Properly capitalize
title.capitalization.fix.text=Properly capitalize ''{0}''
inspection.title.capitalization.description=String ''{0}'' is not properly capitalized. It should have {1} capitalization
suppress.with.0.comment=Suppress with ''{0}'' comment
if.the.resource.bundle.is.invalid.either.declare.it.as.an.object=If the resource bundle is invalid, either declare it as an object of the java.util.ResourceBundle class in the source code, or edit the internationalization template to point to the method of your custom resource bundle class.
searching.for.duplicates.of.0=Searching for Duplicates of ''{0}''
property.has.no.usages=Property has no usages
property.has.non.method.usages=Property has non-method usages

# Pseudo functional expression using static class inspection, add methods dialog
inspection.pseudo.functional.style.add.methods.fully.qualified.class.name=Fully qualified class name:
inspection.pseudo.functional.style.add.methods.method.name=Method name:
inspection.pseudo.functional.style.add.methods.stream.api.replacement=Stream API replacement:
inspection.pseudo.functional.style.add.methods.before.quick.fix=Before quick fix:
inspection.pseudo.functional.style.add.methods.after.quick.fix=After quick fix:

# Undeclared test inspection
inspection.undeclared.test.problem.descriptor=Undeclared test ''{0}''
inspection.undeclared.test.register=Register ''{0}''
inspection.undeclared.test.register.test=Register test
inspection.undeclared.test.create.suite.fix=Create suite

# Groups problem inspection
inspection.depends.on.groups.add.as.defined.test.group.fix=Add ''{0}'' as a defined test group.
inspection.depends.on.groups.undefined.group.problem=Group ''{0}'' is undefined.
inspection.depends.on.groups.defined.groups.panel.title=&Defined Groups
inspection.depends.on.groups.display.name=TestNG
inspection.depends.on.groups.family.name=TestNG

# "dependsOnMethods" problem inspection
inspection.depends.on.method.unknown.method.problem=Method ''{0}'' unknown.
inspection.depends.on.method.duplicated.name.problem=Duplicated method name: {0}
inspection.depends.on.method.name=TestNG

# Expected exception never thrown in test method body inspection
inspection.testng.expected.exception.never.thrown.problem=Expected <code>#ref</code> never thrown in body of ''{0}()'' #loc

# Data provider problems inspection
inspection.testng.data.provider.does.not.exist.problem=Data provider does not exist
inspection.testng.data.provider.need.to.be.static=Data provider from foreign class need to be static

# Unnecessary default tag inspection
inspection.javafx.default.tag.unwrap.tag.fix.name=Unwrap ''{0}''
inspection.javafx.default.tag.unwrap.tag.fix.family.name=Unwrap tag
inspection.javafx.default.tag.could.be.removed=Default property tag could be removed

# Event handler method signature problems inspection
inspection.javafx.event.handler.ambiguous.problem=Ambiguous event handler name: more than one matching method found
inspection.javafx.event.handler.return.type.problem=Return type of event handler should be void
inspection.javafx.event.handler.incompatible.generic.parameter.problem=Incompatible generic parameter of event handler argument: {0} is not assignable from {1}
inspection.javafx.event.handler.incompatible.handler.argument=Incompatible event handler argument: {0} is not assignable from {1}
inspection.javafx.event.handler.create.options.panel=Detect event handler method having non-void return type
inspection.javafx.event.handler.change.parameter.type=Change parameter type of event handler method

# Color component is out of range inspection
inspection.javafx.color.component.out.of.range.problem=Color component has to be a number between 0.0 and 1.0, inclusively

# JavaFX unused imports inspection
inspection.javafx.unused.imports.problem=Unused import

# Unresolved fx:id attribute reference inspection
inspection.javafx.unresolved.fx.id.reference.problem=Unresolved fx:id reference

javafx.collapse.subtag.to.attribute.intention=Collapse tag ''{0}'' to attribute
javafx.collapse.subtag.to.attribute.intention.family.name=Collapse tag to attribute
javafx.wrap.with.fx.define.intention.family.name=Wrap with fx:define
javafx.wrap.id.with.fx.define.intention=Wrap \"{0}\" with fx:define
javafx.expand.attribute.to.tag.intention=Expand ''{0}'' to tag
javafx.expand.attribute.to.tag.intention.family.name=Expand attribute to tag
javafx.field.to.property.intention.search.for.usages=Searching for usages of ''{0}''
javafx.inject.page.language.intention.family.name=Specify page language

# JavaFX redundant property values inspection
inspection.javafx.redundant.property.values.problem=Attribute is redundant because it contains default value
inspection.javafx.redundant.property.values.redundant.tag.problem=Tag is redundant because it contains default value