// Copyright 2000-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.credentialStore.keePass

import com.intellij.credentialStore.KeePassCredentialStore
import com.intellij.credentialStore.LOG
import com.intellij.credentialStore.getTrimmedChars
import com.intellij.credentialStore.kdbx.IncorrectMasterPasswordException
import com.intellij.credentialStore.kdbx.KdbxPassword
import com.intellij.credentialStore.kdbx.loadKdbx
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.actionSystem.PlatformDataKeys
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.ui.Messages
import com.intellij.openapi.ui.ValidationInfo
import com.intellij.ui.components.dialog
import com.intellij.ui.layout.*
import com.intellij.util.SmartList
import com.intellij.util.io.delete
import com.intellij.util.io.toByteArray
import java.awt.Component
import java.nio.CharBuffer
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardCopyOption
import javax.swing.JPasswordField

internal open class KeePassFileManager(private val file: Path, private val masterKeyFile: Path) {
  fun clear() {
    try {
      val db = KeePassCredentialStore(dbFile = file, masterKeyFile = masterKeyFile)
      db.clear()
      db.save()
    }
    catch (e: Exception) {
      // ok, just remove file
      if (ApplicationManager.getApplication()?.isUnitTestMode == false) {
        LOG.error(e)
      }
      file.delete()
    }
  }

  fun import(fromFile: Path, event: AnActionEvent?) {
    if (file == fromFile) {
      return
    }

    val contextComponent = event?.getData(PlatformDataKeys.CONTEXT_COMPONENT)

    // check master key file in parent dir of imported file
    val possibleMasterKeyFile = fromFile.parent.resolve(MASTER_KEY_FILE_NAME)
    var masterPassword = MasterKeyFileStorage(possibleMasterKeyFile).get()
    try {
      if (masterPassword != null) {
        try {
          loadKdbx(fromFile, KdbxPassword(masterPassword))
        }
        catch (e: IncorrectMasterPasswordException) {
          LOG.warn("On import \"$fromFile\" found existing master key file \"$possibleMasterKeyFile\" but key is not correct")
          masterPassword = null
        }
      }

      if (masterPassword == null && !requestMasterPassword("Specify Master Password", contextComponent) {
          try {
            loadKdbx(fromFile, KdbxPassword(it))
            masterPassword = it
            null
          }
          catch (e: IncorrectMasterPasswordException) {
            return@requestMasterPassword "Master password not correct."
          }
        }) {
        return
      }

      Files.copy(fromFile, file, StandardCopyOption.REPLACE_EXISTING)
      MasterKeyFileStorage(masterKeyFile).set(MasterKey(masterPassword!!, isAutoGenerated = false))
    }
    catch (e: Exception) {
      LOG.warn(e)
      Messages.showMessageDialog(contextComponent!!, "Internal error", "Cannot Import", Messages.getErrorIcon())
    }
  }

  fun askAndSetMasterKey(event: AnActionEvent?): Boolean {
    val contextComponent = event?.getData(PlatformDataKeys.CONTEXT_COMPONENT)

    // to open old database, key can be required, so, to avoid showing 2 dialogs, check it before
    val store = try {
      KeePassCredentialStore(file, masterKeyFile)
    }
    catch (e: IncorrectMasterPasswordException) {
      // ok, old key is required
      return requestOldAndNewKeys(contextComponent)
    }

    return requestMasterPassword("Set Master Password", contextComponent) {
      store.setMasterPassword(MasterKey(it, isAutoGenerated = false))
      null
    }
  }

  protected open fun requestOldAndNewKeys(contextComponent: Component?): Boolean {
    val oldPasswordField = JPasswordField()
    val newPasswordField = JPasswordField()
    val panel = panel {
      noteRow("Existing KeePass database requires old password.")
      row("Old password:") { oldPasswordField() }
      row("New password:") { newPasswordField() }

      noteRow("If you don't remember old password,\nthe only solution to Clear database.")
    }

    return dialog(title = "Change Master Password", panel = panel, focusedComponent = oldPasswordField, parent = contextComponent) {
      val errors = SmartList<ValidationInfo>()
      val old = checkIsEmpty(oldPasswordField, errors)
      val new = checkIsEmpty(newPasswordField, errors)

      if (errors.isEmpty()) {
        try {
          if (doSetNewMasterPassword(old, new)) {
            return@dialog errors
          }
        }
        catch (e: IncorrectMasterPasswordException) {
          errors.add(ValidationInfo("Old password not correct.", oldPasswordField))
          new?.fill(0.toChar())
        }
      }
      else {
        old?.fill(0.toChar())
        new?.fill(0.toChar())
      }

      errors
    }.showAndGet()
  }

  @Suppress("MemberVisibilityCanBePrivate")
  protected fun doSetNewMasterPassword(old: CharArray?, new: CharArray?): Boolean {
    val store = KeePassCredentialStore(file, masterKeyFile, preloadedMasterKey = MasterKey(old!!.toByteArrayAndClear(), isAutoGenerated = false))
    store.setMasterPassword(MasterKey(new!!.toByteArrayAndClear(), isAutoGenerated = false))
    return false
  }

  private fun checkIsEmpty(field: JPasswordField, errors: MutableList<ValidationInfo>): CharArray? {
    val chars = field.getTrimmedChars()
    if (chars == null) {
      errors.add(ValidationInfo("Old master password is empty.", field))
    }
    return chars
  }

  protected open fun requestMasterPassword(title: String, contextComponent: Component?, ok: (value: ByteArray) -> String?): Boolean {
    val passwordField = JPasswordField()
    val panel = panel {
      row("Master password:") { passwordField() }
    }

    return dialog(title = title, panel = panel, focusedComponent = passwordField, parent = contextComponent) {
      val errors = SmartList<ValidationInfo>()
      val value = checkIsEmpty(passwordField, errors)
      if (errors.isEmpty()) {
        val result = value!!.toByteArrayAndClear()
        ok(result)?.let {
          errors.add(ValidationInfo(it, passwordField))
        }
        if (!errors.isEmpty()) {
          result.fill(0)
        }
      }
      errors
    }
      .showAndGet()
  }
}

private fun CharArray.toByteArrayAndClear(): ByteArray {
  val charBuffer = CharBuffer.wrap(this)
  val byteBuffer = Charsets.UTF_8.encode(charBuffer)
  charBuffer.array().fill(0.toChar())
  return byteBuffer.toByteArray(isClear = true)
}