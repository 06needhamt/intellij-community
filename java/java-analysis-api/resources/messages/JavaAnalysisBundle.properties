add.explicit.type.arguments=Add explicit type arguments

# suppress inspection "UnusedProperty"
annotation.target.ANNOTATION_TYPE=annotation type
# suppress inspection "UnusedProperty"
annotation.target.CONSTRUCTOR=constructor
# suppress inspection "UnusedProperty"
annotation.target.FIELD=field
# suppress inspection "UnusedProperty"
annotation.target.LOCAL_VARIABLE=local variable
# suppress inspection "UnusedProperty"
annotation.target.METHOD=method
# suppress inspection "UnusedProperty"
annotation.target.MODULE=module
# suppress inspection "UnusedProperty"
annotation.target.PACKAGE=package
# suppress inspection "UnusedProperty"
annotation.target.PARAMETER=parameter
# suppress inspection "UnusedProperty"
annotation.target.RECORD_COMPONENT=record component
# suppress inspection "UnusedProperty"
annotation.target.TYPE=type
# suppress inspection "UnusedProperty"
annotation.target.TYPE_PARAMETER=type parameter
# suppress inspection "UnusedProperty"
annotation.target.TYPE_USE=type use

change.type.arguments=Change type arguments
change.type.arguments.to.0=Change type arguments to <{0}>
convert.0.to.float=Convert ''{0}'' to float

dataflow.message.array.index.out.of.bounds=Array index is out of bounds
dataflow.message.arraystore=Storing element of type <code>{0}</code> to array of <code>{1}</code> elements may produce <code>ArrayStoreException</code>
dataflow.message.assigning.null.notannotated=Assigning <code>null</code> value to non-annotated field
dataflow.message.assigning.null=<code>null</code> is assigned to a variable that is annotated with @NotNull
dataflow.message.assigning.nullable.notannotated=Expression <code>#ref</code> #loc might be null but is assigned to non-annotated field
dataflow.message.assigning.nullable=Expression <code>#ref</code> might evaluate to null but is assigned to a variable that is annotated with @NotNull
dataflow.message.cce.always=Casting <code>{0}</code> to <code>#ref</code> #loc will produce <code>ClassCastException</code> for any non-null value
dataflow.message.cce=Casting <code>{0}</code> to <code>#ref</code> #loc may produce <code>ClassCastException</code>
dataflow.message.constant.condition.when.reached=Condition <code>#ref</code> #loc is always <code>{0, choice, 0#false|1#true}</code> when reached
dataflow.message.constant.condition=Condition <code>#ref</code> #loc is always <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.method.reference=Method reference result is always ''{0}''
dataflow.message.constant.no.ref=Condition is always {0, choice, 0#false|1#true}
dataflow.message.contract.fail.index=The call to '#ref' always fails as index is out of bounds
dataflow.message.contract.fail=The call to '#ref' always fails, according to its method contracts
dataflow.message.immutable.modified=Immutable object is modified
dataflow.message.immutable.passed=Immutable object is passed where mutable is expected
dataflow.message.npe.array.access.sure=Array access <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.array.access=Array access <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.field.access.sure=Dereference of <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.field.access=Dereference of <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=Inner class construction will produce <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=Inner class construction may produce <code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=Method invocation <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.method.invocation=Method invocation <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=Method reference invocation <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.only.switch.label=Switch label <code>#ref</code> #loc is the only reachable in the whole switch
dataflow.message.passing.null.argument.nonannotated=Passing <code>null</code> argument to non-annotated parameter
dataflow.message.passing.null.argument=Passing <code>null</code> argument to parameter annotated as @NotNull
dataflow.message.passing.nullable.argument.methodref.nonannotated=Method reference argument might be null but passed to non-annotated parameter
dataflow.message.passing.nullable.argument.methodref=Method reference argument might be null
dataflow.message.passing.nullable.argument.nonannotated=Argument <code>#ref</code> #loc might be null but passed to non-annotated parameter
dataflow.message.passing.nullable.argument=Argument <code>#ref</code> #loc might be null
dataflow.message.pointless.assignment.expression=Condition <code>#ref</code> #loc at the left side of assignment expression is always <code>{0}</code>. Can be simplified
dataflow.message.pointless.same.arguments=Arguments of '#ref' are the same. Calling this method with the same arguments is meaningless.
dataflow.message.redundant.assignment=Variable is already assigned to this value
dataflow.message.redundant.instanceof=Condition <code>#ref</code> #loc is redundant and can be replaced with a null check
dataflow.message.redundant.update=Variable update does nothing
dataflow.message.return.null.from.notnull=<code>null</code> is returned by the method declared as @{0}
dataflow.message.return.null.from.notnullable=<code>null</code> is returned by the method which is not declared as @{0}
dataflow.message.return.nullable.from.notnull.function=Function may return null, but it's not allowed here
dataflow.message.return.nullable.from.notnull=Expression <code>#ref</code> might evaluate to null but is returned by the method declared as @{0}
dataflow.message.return.nullable.from.notnullable=Expression <code>#ref</code> might evaluate to null but is returned by the method which is not declared as @{0}
dataflow.message.storing.array.null=<code>null</code> is stored to an array of @NotNull elements
dataflow.message.storing.array.nullable=Expression <code>#ref</code> might evaluate to null but is stored to an array of @NotNull elements
dataflow.message.unboxing.method.reference=Use of <code>#ref</code> #loc would need unboxing which may produce <code>NullPointerException</code>
dataflow.message.unboxing=Unboxing of <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.unreachable.switch.label=Switch label <code>#ref</code> #loc is unreachable
dataflow.method.fails.with.null.argument=Method will throw an exception when parameter is null
dataflow.not.precise={0} is complex: data flow results could be imprecise
dataflow.too.complex={0} is too complex to analyze by data flow algorithm

delete.repeated.0=Delete repeated ''{0}''
delete.repeated.interface=Delete repeated interface
exception.removal.will.break.source.code.proceed.anyway=Exception removal will break source code. Proceed anyway?

feature.generics=Generics
feature.annotations=Annotations
feature.static.imports=Static imports
feature.for.each=For-each loops
feature.varargs=Variable arity methods
feature.hex.fp.literals=Hexadecimal floating point literals
feature.diamond.types=Diamond types
feature.multi.catch=Multi-catches
feature.try.with.resources=Try-with-resources
feature.binary.literals=Binary literals
feature.underscores.in.literals=Underscores in literals
feature.extension.methods=Extension methods
feature.method.references=Method references
feature.lambda.expressions=Lambda expressions
feature.type.annotations=Type annotations
feature.type.receivers=Receiver parameters
feature.intersections.in.casts=Intersection types in casts
feature.static.interface.calls=Static interface method calls
feature.try.with.resources.refs=Resource references
feature.modules=Modules
feature.lvti=Local variable type inference
feature.text.blocks=Text block literals
feature.enhanced.switch=Enhanced 'switch' blocks
feature.switch.expressions='switch' expressions
feature.records=Records
feature.patterns.instanceof=Patterns in 'instanceof'
feature.text.block.escape.sequences='\\s' and '\\' escape sequences

find.searching.for.references.to.class.progress=Searching for references to class {0}...
find.usages.panel.title.derived.classes=Derived Classes
find.usages.panel.title.derived.interfaces=Derived Interfaces
find.usages.panel.title.implementing.classes=Implementing Classes
find.usages.panel.title.implementing.methods=Implementing Methods
find.usages.panel.title.overloaded.methods.usages=Overloaded Methods Usages
find.usages.panel.title.overriding.methods=Overriding Methods
get.class.in.accessible.message.class.0.is.not.accessible.from.module=Class ''{0}'' is not accessible from module ''{1}''
get.class.in.accessible.message.class.0.is.not.accessible.here=Class ''{0}'' is not accessible here

inspection.i18n.quickfix.annotate=Annotate...
inspection.i18n.quickfix.annotate.as=Annotate as @{0}
inspection.i18n.quickfix.annotate.element=Annotate {0} ''{1}''...
inspection.i18n.quickfix.annotate.element.as=Annotate {0} ''{1}'' as @{2}
inspection.reference.default.package=<default>
invalid.java.type=Invalid Java type
move.0.to.the.beginning=Move ''{0}'' to the beginning
move.to.front=Move to front
processing.method.usages=Processing Method Usages...
qualify.0=Qualify {0}
qualify.with.0.this=Qualify with {0}.this
remove.annotation=Remove annotation
remove.left.side.of.assignment=Remove left side of assignment
replace.get.class.with.class.literal=Replace getClass() with .class literal
service.provides=Provides service <a href="#javaClass/{0}">{0}</a><br><div style='margin-top: 5px'><font size='2'>Click to navigate</font></div>
service.uses=Uses service <a href="#javaClass/{0}">{0}</a><br><div style='margin-top: 5px'><font size='2'>Click to navigate</font></div>
suppress.for.parameter=Suppress for parameter
suppress.for.statement.with.comment=Suppress for statement with comment