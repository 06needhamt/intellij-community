access.static.via.instance=Access static member via instance reference
action.AnActionButton.text.select.annotation.used.for.code.generation=Select annotation used for code generation
assignment.to.declared.variable.problem.descriptor=Variable ''{0}'' is initialized with self assignment
assignment.to.itself.problem.descriptor=Variable ''{0}'' is assigned to itself
assignment.to.itself.quickfix.name=Remove self assignment
boolean.method.is.always.inverted.display.name=Boolean method is always inverted
boolean.method.is.always.inverted.problem.descriptor=Boolean method <code>#ref</code> is always inverted
button.add.class=Add Class...
button.add.pattern=Add Pattern...
button.annotations=Annotations...
button.code.patterns=Code patterns...
change.color.command.text=Change color
checkbox.annotate.local.variables=Annotate local variables
checkbox.comments.and.javadoc.count.as.content=Comments and javadoc count as content
checkbox.deprecated.members=Deprecated members
checkbox.html.report.inaccessible.symbols=<html>Report inaccessible symbols<br>(javadoc tool may be unable to create hyperlink)
checkbox.ignore.fields.used.in.multiple.methods=Ignore fields used in multiple methods
checkbox.ignore.simple.setters=Ignore simple setters
checkbox.iterate.unknown.stream.sources.via.stream.iterator=Iterate unknown Stream sources via Stream.iterator()
checkbox.suggest.conversion.to.map.computeifabsent=Suggest conversion to Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=Suggest conversion to Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=Suggest conversion to Map.merge
checkbox.suggest.conversion.to.map.putifabsent=Suggest conversion to Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=Suggest conversion to Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=Suggest replacement even if lambda may have side effects
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=Treat 'get(k) != null' the same as 'containsKey(k)' (may change semantics)
checkbox.warn.if.only.foreach.replacement.is.available=Warn if only 'forEach' replacement is available
checkbox.warn.if.the.loop.is.trivial=Warn if the loop is trivial
class.filter.editor.add.dialog.title=New Filter
class.filter.editor.choose.class.title=Choose Class
configure.annotations.option=Configure Annotations
default.file.template.description=Default File template
default.file.template.display.name=Default File Template Usage
default.file.template.edit.template=Edit template...
default.file.template.replace.with.actual.file.template=Replace with actual file template
dialog.message.infer.nullity.annotations.requires.the.project.language.level=Infer Nullity Annotations requires the project language level be set to 1.5 or greater.
dialog.message.jetbrains.annotations.library.is.missing=JetBrains annotations library is missing.\nWithout the library, IntelliJ IDEA cannot run the analysis. Would you like to add it?
dialog.message.no.places.found.to.infer.nullable.notnull=No places found to infer @Nullable/@NotNull
dialog.title.configure.annotations=Configure Annotations
dialog.title.configure.code.patterns=Configure Code Patterns
dialog.title.edit.method.contract=Edit Method Contract
dialog.title.edit.range=Edit Range
dialog.title.infer.nullity=Infer Nullity
dialog.title.infer.nullity.results=Infer Nullity Results
edit.dependency.rules.family=Edit dependency rules
edit.dependency.rules.text=Edit dependency rule \"{0} \"
icon.preview=Icon preview
inspection.1.5.display.name=Usages of API which isn't available at the configured language level
inspection.1.5.problem.descriptor=Usage of API documented as @since {0}+
inspection.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
inspection.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
inspection.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}
inspection.assert.quickfix=Assert ''{0}''
inspection.capturing.cleaner=Runnable passed to Cleaner.register() captures ''{0}'' reference
inspection.capturing.cleaner.description=Cleaner captures object reference
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=Change variable type and remove cast
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=Change type of ''{0}'' to ''{1}'' and remove cast
inspection.cast.can.be.removed.narrowing.variable.type.message=Cast may be removed by changing the type of ''{0}'' to ''{1}''
inspection.cast.can.be.removed.narrowing.variable.type.name=Too weak variable type leads to unnecessary cast
inspection.charset.object.can.be.used.display.name=Standard Charset object can be used
inspection.charset.object.can.be.used.fix.family.name=Use Charset constant
inspection.charset.object.can.be.used.fix.name=Replace with ''{0}''
inspection.charset.object.can.be.used.message={0} can be used instead
inspection.collection.factories.fix.family.name=Replace with collection factory call
inspection.collection.factories.fix.name=Replace with ''{0}.{1}'' call
inspection.collection.factories.message=Can be replaced with ''{0}.{1}'' call
inspection.collection.factories.option.ignore.non.constant=Do not warn when content is non-constant
inspection.collection.factories.option.suggest.ofentries=Suggest 'Map.ofEntries'
inspection.collection.used.as.vararg.display.name=Iterable is used as vararg
inspection.collection.used.as.vararg.message=Iterable is passed as vararg: probably an array was intended
inspection.comparator.result.comparison.display.name=Suspicious usage of compare method
inspection.comparator.result.comparison.fix.family.name=Fix comparator result comparison
inspection.comparator.result.comparison.problem.display.name=Comparison of compare method result with specific constant
inspection.conditional.break.in.infinite.loop=Move condition to loop
inspection.conditional.break.in.infinite.loop.description=Conditional break inside infinite loop
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=Don't suggest to replace with 'do while'
inspection.convert.to.local.quickfix=Convert to local
inspection.data.flow.display.name=Constant conditions \\& exceptions
inspection.data.flow.filter.notnull.quickfix=Insert 'filter(Objects::nonNull)' step
inspection.data.flow.nullable.quickfix.option=Suggest @Nullable annotation for methods/fields/parameters where nullable values are used
inspection.data.flow.true.asserts.option=Don't report assertions with condition statically proven to be always <code>true</code>
inspection.data.flow.use.computeifpresent.quickfix=Replace 'compute' with 'computeIfPresent'
inspection.dead.code.option.applet=Applets
inspection.dead.code.option.external=Classes with usages in non-Java files
inspection.dead.code.option.main=<html><code>void main(String args[])</code> methods</html>
inspection.dead.code.option.servlet=Servlets
inspection.default.annotation.param=Default annotation parameter value
inspection.dependency.configure.button.text=Configure dependency rules
inspection.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated
inspection.duplicate.branches.in.switch.default.message=Branch in 'switch' is a duplicate of the default branch
inspection.duplicate.branches.in.switch.delete.fix.family.name=Delete redundant 'switch' branches
inspection.duplicate.branches.in.switch.delete.fix.name=Delete redundant 'switch' branch
inspection.duplicate.branches.in.switch.display.name=Duplicate branches in 'switch'
inspection.duplicate.branches.in.switch.merge.fix.family.name=Merge duplicate branches in 'switch'
inspection.duplicate.branches.in.switch.merge.fix.name=Merge with ''{0}''
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=Merge with the default 'switch' branch
inspection.duplicate.branches.in.switch.message=Duplicate branch in 'switch'
inspection.duplicate.expressions.complexity.threshold=Expression complexity threshold
inspection.duplicate.expressions.display.name=Multiple occurrences of the same expression
inspection.duplicate.expressions.introduce.variable.fix.family.name=Introduce variable
inspection.duplicate.expressions.introduce.variable.fix.name=Introduce variable for ''{0}''
inspection.duplicate.expressions.message=Multiple occurrences of <code>#ref</code> #loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=Replace with variable other occurrences of expression
inspection.duplicate.expressions.replace.other.occurrences.fix.name=Replace with ''{0}'' other occurrences of ''{1}''
inspection.duplicate.expressions.reuse.variable.fix.family.name=Reuse variable
inspection.duplicate.expressions.reuse.variable.fix.name=Reuse variable ''{0}'' for ''{1}''
inspection.empty.method.delete.quickfix=Delete unnecessary method(s)
inspection.empty.method.problem.descriptor=Method only calls its super
inspection.empty.method.problem.descriptor1=Empty method overrides empty method
inspection.empty.method.problem.descriptor2=The method is empty
inspection.empty.method.problem.descriptor3=The method and all its derivables are empty
inspection.empty.method.problem.descriptor4=All implementations of this method are empty
inspection.endless.stream.description=Non-short-circuit operation consumes infinite stream
inspection.equals.hashcode.display.name='equals()' and 'hashCode()' not paired
inspection.equals.hashcode.generate.equals.quickfix=Generate 'equals()'
inspection.equals.hashcode.generate.hashcode.quickfix=Generate 'hashCode()'
inspection.excessive.lambda.fix.family.name=Replace lambda with constant
inspection.excessive.lambda.fix.name=Use ''{0}'' method without lambda
inspection.excessive.lambda.message=Excessive lambda usage
inspection.explicit.argument.can.be.lambda.fix.family.name=Replace explicit argument with function
inspection.explicit.argument.can.be.lambda.fix.name=Use ''{0}'' method with functional argument
inspection.explicit.argument.can.be.lambda.message=Explicit argument can be converted to lambda
inspection.explicit.array.filling.description=Can be replaced with single ''Arrays.{0}()'' method call
inspection.explicit.array.filling.fix.family.name=Replace loop with ''Arrays.{0}()'' method call
inspection.explicit.array.filling.no.suggestion.for.set.all=Do not suggest to use 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=Redundant initialization of a newly created array
inspection.explicit.array.filling.suggest.set.all=Suggest 'Arrays.setAll()'
inspection.export.results.callees=Call chain
inspection.export.results.implicit.constructor=implicit constructor of
inspection.export.results.overrides.library.methods=Overrides library methods
inspection.export.results.package=package
inspection.export.results.type.references=The following uses this type
inspection.field.can.be.local.display.name=Field can be local
inspection.field.can.be.local.problem.descriptor=Field can be converted to a local variable
inspection.field.can.be.local.quickfix.constructor=Convert field to local variable in constructor
inspection.field.can.be.local.quickfix.initializer=Convert field to local variable in initializer section
inspection.field.can.be.local.quickfix.one.method=Convert field to local variable in method ''{0}''
inspection.fold.expression.fix.family.name=Fold expression
inspection.fold.expression.into.stream.display.name=Expression can be folded into Stream chain
inspection.fold.expression.into.stream.fix.name=Fold expression into Stream chain
inspection.fold.expression.into.string.display.name=Expression can be folded into 'String.join'
inspection.fold.expression.into.string.fix.name=Fold expression into 'String.join'
inspection.forward.compatibility.name=Forward compatibility
inspection.fuse.stream.operations.display.name=Subsequent steps can be fused into Stream API chain
inspection.fuse.stream.operations.fix.family.name=Fuse more statements to the Stream API chain
inspection.fuse.stream.operations.fix.name=Fuse {0} into the Stream API chain
inspection.fuse.stream.operations.message=Stream may be extended replacing {0}
inspection.fuse.stream.operations.option.strict.mode=Do not suggest 'toList()' or 'toSet()' collectors
inspection.handle.signature.change.type.fix.name=Change type to ''{0}''
inspection.handle.signature.field.cannot.resolve=Cannot resolve field ''{0}''
inspection.handle.signature.field.not.static=Field ''{0}'' is not static
inspection.handle.signature.field.static=Field ''{0}'' is static
inspection.handle.signature.field.type=The type of field ''{0}'' is ''{1}''
inspection.handle.signature.method.abstract=Method ''{0}'' is abstract in ''{1}''
inspection.handle.signature.method.not.static=Method ''{0}'' is not static
inspection.handle.signature.method.static=Method ''{0}'' is static
inspection.handle.signature.name=MethodHandle/VarHandle type mismatch
inspection.handle.signature.not.subclass=Caller class ''{0}'' must be a subclass of ''{1}''
inspection.handle.signature.replace.with.fix.name=Replace with ''{0}''
inspection.handle.signature.use.constructor.fix.family.name=Use one of constructor overloads
inspection.handle.signature.use.constructor.fix.name=Use constructor ''{0}''
inspection.handle.signature.use.method.fix.family.name=Use one of method overloads
inspection.handle.signature.use.method.fix.name=Use method ''{0}''
inspection.idempotent.loop.body=Idempotent loop body
inspection.illegal.character=Illegal character
inspection.javadoc.dialog.title=Edit Additional Javadoc Tags
inspection.javadoc.display.name=Declaration has Javadoc problems
inspection.javadoc.label.text=Additional Javadoc Tags:
inspection.javadoc.lint.display.name=HTML problems in Javadoc (DocLint)
inspection.javadoc.method.problem.missing.param.tag=Required tag <code>@param</code> is missing for parameter {0}
inspection.javadoc.method.problem.missing.tag.description={0} tag description is missing
inspection.javadoc.option.ignore.deprecated=Ignore elements marked as @deprecated
inspection.javadoc.option.ignore.period=Ignore period problems
inspection.javadoc.option.ignore.self.ref=Ignore Javadoc pointing to itself
inspection.javadoc.option.ignore.simple=Ignore simple property accessors
inspection.javadoc.option.ignore.throws=Ignore duplicate 'throws' tag
inspection.javadoc.option.tab.title=Class
inspection.javadoc.option.tab.title.field=Field
inspection.javadoc.option.tab.title.inner.class=Inner class
inspection.javadoc.option.tab.title.method=Method
inspection.javadoc.option.tab.title.module=Module
inspection.javadoc.option.tab.title.package=Package
inspection.javadoc.problem.add.param.tag=Add tag @param for parameter ''{0}''
inspection.javadoc.problem.add.param.tag.family=Add missing Javadoc param tag
inspection.javadoc.problem.add.tag=Add tag @{0} {1}
inspection.javadoc.problem.add.tag.family=Add missing Javadoc tag
inspection.javadoc.problem.cannot.resolve=Cannot resolve symbol {0}
inspection.javadoc.problem.descriptor=Required Javadoc is absent
inspection.javadoc.problem.descriptor1=Period in the documentation is missing. The period is used by the Javadoc tool to generate the comment for the overview page
inspection.javadoc.problem.disallowed.tag=Tag {0} is not allowed here
inspection.javadoc.problem.duplicate.param=Duplicate @param tag for parameter ''{0}''
inspection.javadoc.problem.duplicate.tag=Duplicate @{0} tag
inspection.javadoc.problem.duplicate.throws=Duplicate @throws or @exception tag for exception ''{0}''
inspection.javadoc.problem.inaccessible=Symbol {0} is inaccessible from here
inspection.javadoc.problem.missing.tag=Required tag {0} is missing
inspection.javadoc.problem.missing.tag.description={0} is missing after @{1} tag
inspection.javadoc.problem.name.expected=Name expected
inspection.javadoc.problem.pointing.to.itself=Javadoc pointing to itself
inspection.javadoc.problem.see.tag.expecting.ref=Class/method reference, quoted text, or HTML link are expected after @see tag
inspection.javadoc.problem.wrong.tag=Wrong tag {0}
inspection.javadoc.ref.display.name=Declaration has problems in Javadoc references
inspection.javadoc.required.tags.option.title=Required Tags
inspection.javadoc.throws.or.exception.option=@throws or @exception
inspection.join.declaration.and.assignment.display.name=Assignment can be joined with declaration
inspection.join.declaration.and.assignment.fix.family.name=Join declaration and assignment
inspection.join.declaration.and.assignment.message=Assignment can be joined with declaration of ''{0}''
inspection.labeled.switch.rule.redundant.code.block.display.name=Labeled switch rule has redundant code block
inspection.labeled.switch.rule.redundant.code.block.message=Labeled rule's code block is redundant
inspection.labeled.switch.rule.redundant.code.fix.name=Unwrap code block of labeled rule
inspection.lambda.to.method.call.fix.family.name=Replace lambda expression with method call
inspection.lambda.to.method.call.fix.name=Replace lambda expression with ''{0}''
inspection.manual.min.max.calculation.description=Can be replaced with ''Math.{0}'' call
inspection.manual.min.max.calculation.disable.for.non.integral=Disable for float and double
inspection.map.foreach.display.name=Map.forEach() can be used
inspection.map.foreach.option.no.loops=Do not report loops
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=Anonymous #ref #loc can be replaced with method reference
inspection.message.can.be.replaced.with.0.constructor=Can be replaced with ''{0}'' constructor
inspection.message.can.be.replaced.with.files.readstring=Can be replaced with 'Files.readString()'
inspection.message.can.be.replaced.with.optional.of.nullable=Can be replaced with Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=Can be replaced with single expression in functional style
inspection.message.can.be.replaced.with.string.repeat=Can be replaced with 'String.repeat()'
inspection.message.lambda.parameter.type.is.redundant=Lambda parameter type is redundant
inspection.message.pseudo.functional.style.code=Pseudo functional style code
inspection.message.redundant.default.parameter.value.assignment=Redundant default parameter value assignment
inspection.message.replace.optional.with.if.statements=Replace Optional with if statements
inspection.no.jdk.error.message=The JDK is not configured properly for this project. Inspection cannot proceed.
inspection.no.modules.error.message=This project contains no modules. Inspection cannot proceed.
inspection.notnull.field.not.initialized.display.name=@NotNull field is not initialized
inspection.notnull.field.not.initialized.option.implicit=Ignore fields which could be initialized implicitly
inspection.notnull.field.not.initialized.option.setup=Ignore fields initialized in setUp() method
inspection.null.value.for.optional.assigned.ignore.fix.name=Do not warn when comparing Optional with null
inspection.null.value.for.optional.assigned.message=Optional value is compared with null
inspection.null.value.for.optional.context.assignment=assignment
inspection.null.value.for.optional.context.declaration=declaration
inspection.null.value.for.optional.context.lambda=lambda expression
inspection.null.value.for.optional.context.parameter=parameter
inspection.null.value.for.optional.context.return=return statement
inspection.null.value.for.optional.fix.family.name=Replace with empty Optional method
inspection.null.value.for.optional.message=Null is used for ''Optional'' type in {0}
inspection.null.value.for.optional.option.comparisons=Report comparison of Optional with null
inspection.nullable.problems.display.name=@NotNull/@Nullable problems
inspection.nullable.problems.ignore.external.notnull=&Ignore external @NotNull
inspection.nullable.problems.method.overrides.notnull.option=<html>Report @NotNull &parameters overriding @Nullable and <br>@Nullable methods overriding @NotNull</html>
inspection.nullable.problems.method.overrides.option=Report non-&annotated parameters or methods overriding @NotNull
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=Report non-annotated &setter parameters or getters of annotated fields
inspection.nullable.problems.notnull.overrides.option=Report @NotNull &parameters overriding non-annotated
inspection.nullable.problems.notnull.parameters.with.null.literal.option=Report @NotNull parameters with null-literal argument usages
inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> without ''isPresent()'' check
inspection.overflowing.loop.index.inspection.description=Loop executes zero or billions times
inspection.overflowing.loop.index.inspection.name=Loop executes zero or billions times
inspection.overwritten.key.map.message=Duplicate Map key
inspection.overwritten.key.set.message=Duplicate Set element
inspection.parameter.can.be.local.display.name=Parameter can be local
inspection.parameter.can.be.local.problem.descriptor=Parameter can be converted to a local variable
inspection.pseudo.functional.style.add.methods.after.quick.fix=After quick fix:
inspection.pseudo.functional.style.add.methods.before.quick.fix=Before quick fix:
inspection.pseudo.functional.style.add.methods.fully.qualified.class.name=Fully qualified class name:
inspection.pseudo.functional.style.add.methods.method.name=Method name:
inspection.pseudo.functional.style.add.methods.stream.api.replacement=Stream API replacement:
inspection.quickfix.assert.family=Assert
inspection.raw.variable.type.can.be.generic.family.quickfix=Add generic parameters to the type
inspection.raw.variable.type.can.be.generic.name=Raw type can be generic
inspection.raw.variable.type.can.be.generic.quickfix=Change type of {0} to {1}
inspection.redundant.array.creation.display.name=Redundant array creation
inspection.redundant.array.creation.for.varargs.call.descriptor=Redundant array creation for calling varargs method
inspection.redundant.array.creation.quickfix=Remove explicit array creation
inspection.redundant.explicit.close=Redundant 'close()'
inspection.redundant.null.check.always.fail.message=Null-check will always fail: {0} is never null
inspection.redundant.null.check.fix.family.name=Remove redundant null-check
inspection.redundant.null.check.fix.notnull.family.name=Remove erroneous '!= null'
inspection.redundant.null.check.message=Redundant null-check: {0} is never null
inspection.redundant.operation.on.empty.array.message=Array <code>#ref</code> is always empty
inspection.redundant.operation.on.empty.collection.message=Collection <code>#ref</code> is always empty
inspection.redundant.operation.on.empty.container.display.name=Redundant operation on empty container
inspection.redundant.operation.on.empty.map.message=Map <code>#ref</code> is always empty
inspection.redundant.record.constructor.can.be.compact.message=Canonical constructor can be converted to compact form
inspection.redundant.record.constructor.canonical.message=Redundant canonical constructor
inspection.redundant.record.constructor.compact.message=Redundant compact constructor
inspection.redundant.record.constructor.description=Redundant record constructor
inspection.redundant.record.constructor.fix.family.name=Convert canonical constructor to compact form
inspection.redundant.record.constructor.statement.message=Redundant field assignment in compact constructor
inspection.redundant.stream.optional.call.explanation.at.most.one=stream contains at most one element
inspection.redundant.stream.optional.call.explanation.distinct=there already was a 'distinct' call in the chain
inspection.redundant.stream.optional.call.explanation.distinct.set=elements will be distinct anyways when collected to the Set
inspection.redundant.stream.optional.call.explanation.filter=predicate is always true
inspection.redundant.stream.optional.call.explanation.map.flatMap=previous 'map' call can replace the 'flatMap' step
inspection.redundant.stream.optional.call.explanation.parallel=there''s subsequent ''{0}'' call which overrides this call
inspection.redundant.stream.optional.call.explanation.parallel.single=stream created from single element will not be parallelized
inspection.redundant.stream.optional.call.explanation.sorted=subsequent ''{0}'' call doesn''t depend on the sort order
inspection.redundant.stream.optional.call.explanation.sorted.twice=stream content is sorted again after that
inspection.redundant.stream.optional.call.explanation.unordered=there already was an 'unordered' call in the chain
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=Collect to 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=Remove redundant chain call
inspection.redundant.stream.optional.call.fix.name=Remove ''{0}'' call
inspection.redundant.stream.optional.call.message=Redundant ''{0}'' call
inspection.redundant.stream.optional.call.option.streamboxing=Report redundant boxing in Stream.map
inspection.reflect.handle.invocation.argument.not.array=Argument is not an array type
inspection.reflect.handle.invocation.argument.not.exact=Argument type should be exactly ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=Argument of type ''{0}'' cannot be ''null''
inspection.reflect.handle.invocation.receiver.incompatible=Call receiver type is incompatible: ''{0}'' is expected
inspection.reflect.handle.invocation.receiver.null=Call receiver is 'null'
inspection.reflect.handle.invocation.result.not.assignable=Should be cast to ''{0}'' or its superclass
inspection.reflect.handle.invocation.result.not.exact=Should be cast to ''{0}''
inspection.reflect.handle.invocation.result.null=Returned value is always 'null'
inspection.reflect.handle.invocation.result.void=Return type is 'void'
inspection.reflection.invocation.argument.count={0,choice,0#No arguments are|1#One argument is|1<{0} arguments are} expected
inspection.reflection.invocation.argument.not.assignable=Argument is not assignable to ''{0}''
inspection.reflection.invocation.array.not.assignable=Array {0,choice,1#item has|1<items have} incompatible {0,choice,1#type|1<types}
inspection.reflection.invocation.item.count={0,choice,0#Empty array is|1#Single-item array is|1<{0} array items are} expected
inspection.reflection.invocation.item.not.assignable=Array item is not assignable to ''{0}''
inspection.reflection.invocation.name=Reflective invocation arguments mismatch
inspection.reflection.member.access.cannot.resolve.constructor.arguments=Cannot resolve constructor with specified argument types
inspection.reflection.member.access.cannot.resolve.field=Cannot resolve field ''{0}''
inspection.reflection.member.access.cannot.resolve.method=Cannot resolve method ''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=Cannot resolve method ''{0}'' with specified argument types
inspection.reflection.member.access.check.exists=Check that field/method exists in non-final classes
inspection.reflection.member.access.check.exists.exclude=Exclude classes
inspection.reflection.member.access.check.exists.exclude.chooser=Class to exclude
inspection.reflection.member.access.constructor.not.public=Constructor is not public
inspection.reflection.member.access.field.not.in.class=Field ''{0}'' is not declared in class ''{1}''
inspection.reflection.member.access.field.not.public=Field ''{0}'' is not public
inspection.reflection.member.access.fix.family.name=Use appropriate reflection method
inspection.reflection.member.access.method.not.in.class=Method ''{0}'' is not declared in class ''{1}''
inspection.reflection.member.access.method.not.public=Method ''{0}'' is not public
inspection.reflection.member.access.name=Reflective access to nonexistent/not visible class member
inspection.reflection.visibility.name=Reflective access across modules issues
inspection.replace.methodref.ternary.quickfix=Replace with null-checking lambda
inspection.replace.ternary.quickfix=Replace with ''{0} != null ?:''
inspection.replace.with.bulk.fix.family.name=Replace with bulk method call
inspection.replace.with.bulk.fix.name=Replace iteration with bulk ''{0}'' call
inspection.replace.with.bulk.message=Iteration can be replaced with bulk ''{0}'' call
inspection.replace.with.bulk.wrap.arrays=Use Arrays.asList() to wrap arrays
inspection.replace.with.enhanced.switch.statement.fix.name=Replace with enhanced 'switch' statement
inspection.replace.with.old.style.switch.statement.fix.name=Replace with old style 'switch' statement
inspection.replace.with.regular.string.literal.fix=Replace with regular string literal
inspection.replace.with.switch.expression.fix.name=Replace with 'switch' expression
inspection.replace.with.text.block.fix=Replace with text block
inspection.replace.with.trivial.lambda.fix.family.name=Replace with trivial lambda
inspection.replace.with.trivial.lambda.fix.name=Replace with lambda returning ''{0}''
inspection.require.non.null=Replace null check with Objects/Stream static call
inspection.require.non.null.description=Null check can be replaced with method call
inspection.require.non.null.message=Replace condition with {0}
inspection.require.non.null.no.warning.replacement.bigger=Don't warn if length of replacement bigger than original
inspection.return.separated.from.computation.descriptor=Return separated from computation of value of ''{0}''
inspection.return.separated.from.computation.family.quickfix=Move 'return' closer to computation of the result
inspection.return.separated.from.computation.name='return' separated from the result computation
inspection.return.separated.from.computation.quickfix=Move ''return'' closer to computation of the value of ''{0}''
inspection.same.parameter.display.name=Actual method parameter is the same constant
inspection.same.parameter.fix.family.name=Inline parameter as constant value
inspection.same.parameter.fix.name=Inline value ''{1}'' for parameter ''{0}''
inspection.same.parameter.problem.descriptor=Actual value of parameter ''{0}'' is always ''{1}''
inspection.scope.for.title=Scope
inspection.simplifiable.comparator.comparing.message=Unnecessary ''{0}()'' call
inspection.simplifiable.comparator.display.name=Comparator can be simplified
inspection.simplifiable.comparator.entry.comparator.message=''{0}'' can be used instead
inspection.simplifiable.comparator.fix.comparing.family.name=Remove redundant call
inspection.simplifiable.comparator.fix.entry.comparator.family.name=Use predefined Map.Entry comparator
inspection.simplifiable.comparator.fix.remove.name=Remove ''{0}()'' call
inspection.simplifiable.comparator.fix.replace.name=Remove ''{0}()'' call and use ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=Simplify comparator replacing 'max' with 'min'
inspection.simplifiable.comparator.fix.reversed.name=Replace with ''{0}'' simplifying the comparator
inspection.simplifiable.comparator.reversed.message=Comparator can be simplified if ''{0}()'' call is replaced with ''{1}()''
inspection.simplify.collector.fix.family.name=Simplify cascaded collector
inspection.simplify.collector.fix.name=Use ''Collectors.{0}'' collector
inspection.simplify.collector.message=Can be simplified using ''{0}'' collector
inspection.simplify.foreach.display.name=Simplifiable forEach() call
inspection.sorted.collection.with.non.comparable.keys.display.name=Sorted collection with non-comparable elements
inspection.sorted.collection.with.non.comparable.keys.message=Construction of sorted collection with non-comparable elements
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=Don't report non-comparable type parameters
inspection.surround.if.family=Surround with if
inspection.surround.if.quickfix=Surround with ''if ({0}{1})''
inspection.suspicious.list.remove.display.name=Suspicious 'List.remove()' in the loop
inspection.switch.expression.backward.expression.migration.inspection.name='switch' expression can be replaced with old style 'switch' statement
inspection.switch.expression.backward.migration.inspection.name=New style 'switch' can be replaced with old style one
inspection.switch.expression.backward.statement.migration.inspection.name='switch' statement can be replaced with old style 'switch' statement
inspection.switch.expression.migration.inspection.name=Statement can be replaced with enhanced 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch statement can be replaced with enhanced 'switch'
inspection.switch.expression.migration.warn.only.on.expression=Show warning only if conversion to expression is possible
inspection.switch.labeled.rule.can.be.code.block.display.name=Labeled switch rule can have code block
inspection.switch.labeled.rule.can.be.code.block.expression.message=Labeled rule's result expression can be wrapped with code block
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=Wrap labeled rule's result expression with code block
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=Wrap labeled rule's statement with code block
inspection.switch.labeled.rule.can.be.code.block.statement.message=Labeled rule's statement can be wrapped with code block
inspection.text.block.backward.migration.message=Text block can be converted to regular string literal
inspection.text.block.backward.migration.name=Text block can be replaced with regular string literal
inspection.text.block.migration.message={0} can be replaced with text block
inspection.text.block.migration.name=Text block can be used
inspection.text.block.migration.suggest.literal.replacement=Suggest to replace string with line breaks
inspection.undeclared.service.usage.message=Usage of service ''{0}'' is not declared in module-info
inspection.undeclared.service.usage.name=Usage of service not declared in 'module-info'
inspection.unused.assignment.option=Report ++i when may be replaced with (i + 1)
inspection.unused.assignment.option1=Report i++ when changed value is not used afterwards
inspection.unused.assignment.option2=Report redundant initializers
inspection.unused.assignment.problem.descriptor1=Variable {0} is never used
inspection.unused.assignment.problem.descriptor2=Variable {0} initializer {1} is redundant
inspection.unused.assignment.problem.descriptor3=The value {0} assigned to {1} is never used
inspection.unused.assignment.problem.descriptor4=The value changed at {0} is never used
inspection.unused.assignment.remove.assignment.quickfix=Remove redundant assignment
inspection.unused.assignment.remove.quickfix=Remove redundant initializer
inspection.unused.parameter.composer=Parameter <code>#ref</code> is not used in any implementation
inspection.unused.parameter.composer1=Parameter <code>#ref</code> is not used in either this method or any of its derived methods
inspection.unused.parameter.delete.quickfix=Delete unused parameter(s)
inspection.unused.return.value.display.name=Method can be void
inspection.unused.return.value.make.void.quickfix=Make method 'void'
inspection.unused.return.value.problem.descriptor=Return value of the method is never used
inspection.unused.symbol.check.accessors=Getters/setters
inspection.unused.symbol.check.classes=Classes:
inspection.unused.symbol.check.fields=Fields:
inspection.unused.symbol.check.inner.classes=Inner classes:
inspection.unused.symbol.check.localvars=Local variables
inspection.unused.symbol.check.methods=Methods:
inspection.unused.symbol.check.parameters=Parameters in
inspection.variable.assigned.to.itself.display.name=Variable is assigned to itself
inspection.wrapper.type.may.be.primitive.fix.name=Convert wrapper type to primitive
inspection.wrapper.type.may.be.primitive.name=Type may be primitive
intention.family.edit.method.contract=Edit method contract
intention.family.edit.range=Edit range
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=Replace Optional.isPresent() condition with functional style expression
intention.family.unimplement.interface.class=Unimplement Interface/Class
intention.text.add.method.contract.to.0=Add method contract to ''{0}''
intention.text.add.range.to.0=Add range to ''{0}''
intention.text.edit.method.contract.of.0=Edit method contract of ''{0}''
intention.text.edit.range.of.0=Edit range of ''{0}''
intention.text.replace.implements.with.static.import=Replace implements with static import
intention.text.unimplement.0=Unimplement {0}
label.add.math.max.0.count.to.avoid.possible.semantics.change=Add Math.max(0, count) to avoid possible semantics change
label.class.filter.editor.add.dialog.filter.pattern=Enter the filter pattern:
label.contract=Contract:
label.entry.points=Entry points:
label.forbid.api.usages=Forbid API usages:
label.from.inclusive=From (inclusive):
label.maximal.reported.method.visibility=Maximal reported method visibility:
label.minimal.reported.method.usage.count=Minimal reported method usage count:
label.minimal.reported.method.visibility=Minimal reported method visibility:
label.mutates=Mutates:
label.to.inclusive=To (inclusive):
label.unused.declaration.reachable.from.tests.option=When entry points are in test sources, mark callees as:
module.not.in.requirements=The module ''{0}'' does not have the module ''{1}'' in requirements
module.package.not.exported=The module ''{0}'' does not export the package ''{1}'' to the module ''{2}''
module.package.not.open=The module ''{0}'' does not open the package ''{1}'' to the module ''{2}''
navigate.to.duplicate.fix=Navigate to duplicate
no.patterns=No class patterns configured
nullable.notnull.annotations.panel.title={0} annotations
nullable.notnull.annotations.runtime.instrumentation.tooltip=Add runtime assertions for notnull-annotated methods and parameters
nullable.notnull.configuration.dialog.title=Nullable/NotNull Configuration
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=Navigate to 'null' argument usages
nullable.stuff.inspection.navigate.null.argument.usages.view.name=''null'' argument usages for parameter {0}
offline.inspections.jdk.not.found={0} not found
offline.inspections.library.urls.were.not.resolved=Roots {0} of the library ''{1}'' from module ''{2}'' were not resolved
offline.inspections.library.was.not.resolved=Please configure library ''{0}'' which is used in module ''{1}''
offline.inspections.no.source.roots=No source roots detected for module ''{0}''
progress.title.check.applicability=Check Applicability...
progress.title.find.references.in.implement.extends.lists=Find References in Implement/Extends Lists...
progress.title.finding.cause=Finding Cause
progress.title.optimize.imports=Optimize Imports...
progress.title.preprocess.usages=Preprocess Usages
progress.title.search.for.overriding.methods=Search for Overriding Methods...
psi.search.overriding.progress=Searching for Overriding Methods...
quickfix.family.avoid.mutation.using.stream.api=Avoid mutation using Stream API
quickfix.family.change.javadoc.to=Change to ...
quickfix.family.find.cause=Find cause
quickfix.family.remove.javadoc.tag=Remove tag
quickfix.family.remove.redundant.parameter=Remove redundant parameter
quickfix.family.remove.redundant.parameter.types=Remove redundant parameter types
quickfix.family.replace.cast.type=Replace cast type
quickfix.family.replace.inefficient.stream.count=Replace inefficient Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=Replace Optional chain with if statements
quickfix.family.replace.stream.api.chain.with.loop=Replace Stream API chain with loop
quickfix.family.replace.with.java.stream.api.pipeline=Replace with Java Stream API pipeline
quickfix.family.replace.with.magic.constant=Replace with magic constant
quickfix.family.replace.with.method.reference=Replace with method reference
quickfix.family.replace.with.optional.of.nullable.chain=Replace with Optional.ofNullable() chain
quickfix.family.replace.with.stream.api.equivalent=Replace with Stream API equivalent
quickfix.family.simplify.foreach.lambda=Simplify forEach lambda
quickfix.family.simplify.stream.call.chain=Simplify stream call chain
quickfix.family.use.flatmap=Use 'flatMap'
quickfix.family.wrap.with.mutable.collection=Wrap with mutable collection
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (may not work before JDK 11.0.2)
quickfix.text.avoid.mutation.using.stream.api.0.operation=Avoid mutation using Stream API ''{0}'' operation
quickfix.text.remove.javadoc.0.1=Remove @{0} {1}
quickfix.text.remove.not.null.annotation=Remove not-null annotation
quickfix.text.replace.0.stream.with.1.2=Replace {0}.stream() with {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=Replace ''collect({0}())'' with ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=Replace ''filter().{0}().isPresent()'' with ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=Replace ''stream().{0}()'' with ''{1}()''{2}
quickfix.text.suffix.may.change.semantics=\ (may change semantics)
quickfix.text.wrap.0.with.1=Wrap ''{0}'' with ''{1}''
radio.button.higher.than=Higher than:
radio.button.respecting.to.project.language.level.settings=Respecting to project language level settings
radio.button.unused.declaration.unused.option=unused
radio.button.unused.declaration.used.option=used
section.title.inspection.suspicious.names.ignore.methods=Ignore methods
special.annotations.annotations.list=Additional Special Annotations
special.annotations.list.add.annotation.class=Add Annotation Class
special.annotations.list.annotation.class=Annotation Class
special.annotations.list.annotation.pattern=Add Annotations Pattern
tab.title.entry.points=Entry points
tab.title.members.to.report=Members to report
table.cell.constructors=constructors
wrong.package.statement=Wrong package statement
