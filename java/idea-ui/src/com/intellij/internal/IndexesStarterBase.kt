// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.internal

import com.fasterxml.jackson.databind.ObjectMapper
import com.intellij.openapi.application.ApplicationStarter
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.util.io.FileUtil
import com.intellij.openapi.util.text.StringUtil
import com.intellij.util.indexing.IndexInfrastructureVersion
import com.intellij.util.io.DigestUtil
import com.intellij.util.io.isFile
import com.intellij.util.io.sizeOrNull
import org.tukaani.xz.LZMA2Options
import org.tukaani.xz.XZOutputStream
import java.io.File
import java.nio.file.Files
import kotlin.system.exitProcess

abstract class IndexesStarterBase(
  private val commandName: String
) : ApplicationStarter {
  protected data class CommandLineKey(val name: String, private val usage: CommandLineKey.() -> Unit) {
    fun usage() = this.usage.invoke(this)
  }

  protected val tempKey = CommandLineKey("temp") {
    println("       --$name=<temp folder>       --- path where temp files can be created,")
    println("                                         (!) it will be cleared by the tool")
  }

  protected val outputKey = CommandLineKey("output") {
    println("       --$name=<output path>     --- location of the indexes CDN image,")
    println("                                         it will be updated with new data")
  }

  final override fun getCommandName() = commandName

  final override fun main(args: Array<out String>) {
    try {
      mainImpl(args)
    } catch (t: Throwable) {
      LOG.error("JDK Indexing failed unexpectedly. ${t.message}", t)
      exitProcess(1)
    }
  }

  protected abstract fun mainImpl(args: Array<out String>)

  protected fun packIndexes(indexKind: String,
                            indexName: String,
                            hash: String,
                            indexZip: File,
                            infraVersion: IndexInfrastructureVersion,
                            outputDir: File,
                            aliases: Collection<String> = setOf()) {
    LOG.info("Packing the indexes to XZ...")
    val indexZipXZ = File(indexZip.path + ".xz")
    xz(indexZip, indexZipXZ)

    LOG.info("Index.zip size    = ${StringUtil.formatFileSize(indexZip.totalSize())}")
    LOG.info("Index.zip.xz size = ${StringUtil.formatFileSize(indexZipXZ.totalSize())}")
    LOG.info("Generated index in $indexZip")

    val indexMetadata = runAndCatchNotNull("extract JSON metadata from $indexZip") {
      SharedIndexMetadata.writeIndexMetadata(indexName, indexKind, hash, infraVersion)
    }

    // we generate production layout here:
    // <kind>
    //   |
    //   | <hash>
    //       |
    //       | index.json    // contains the listing of all entries for a given hash,
    //       |                  is is generated by the intellij-shared-indexes tool
    //       |                  from a dedicated repo
    //       |
    //       | <entry>.ijx.xz // an entry that is listed
    //       | <entry>.json   // that entry metadata (same as in the metadata.json)
    //       | <entry>.sha256 // SHA-256 hash of the .ijx.xz entry
    //

    val indexDir = (outputDir / indexKind / hash).apply { mkdirs() }
    fun indexFile(nameSuffix: String) = indexDir / "${indexName}-${infraVersion.weakVersionHash}$nameSuffix"

    FileUtil.copy(indexZipXZ, indexFile(".ijx.xz"))
    FileUtil.writeToFile(indexFile(".json"), indexMetadata)
    FileUtil.writeToFile(indexFile(".sha256"), indexZipXZ.sha256())

    if (aliases.isNotEmpty()) {
      val om = ObjectMapper()
      val root = om.createObjectNode()
      val aliasesEl = root.putArray("aliases")
      aliases.map { it.toLowerCase() }.toSortedSet().forEach { aliasesEl.add(it) }

      val data = om.writerWithDefaultPrettyPrinter().writeValueAsBytes(root)
      FileUtil.writeToFile(indexFile(".alias"), data)
    }
  }

  private fun xz(file: File, output: File) {
    val bufferSize = 1024 * 1024
    FileUtil.createParentDirs(output)

    try {
      output.outputStream().buffered(bufferSize).use { outputStream ->
        XZOutputStream(outputStream, LZMA2Options()).use { output ->
          file.inputStream().copyTo(output, bufferSize = bufferSize)
        }
      }
    } catch (e: Exception) {
      LOG.error("Failed to generate index.zip.xz package from $file to $output. ${e.message}", e)
    }
  }

  protected operator fun File.div(x: String) = File(this, x)

  protected object LOG {
    fun info(message: String) {
      println(message)
    }

    fun error(message: String, cause: Throwable? = null) {
      Logger.getInstance(DumpJdkIndexStarter::class.java).error(message, cause)
      println("ERROR - $message")
      cause?.printStackTrace()
    }
  }

  protected fun Array<out String>.arg(arg: CommandLineKey, default: String? = null) = arg(arg.name, default)
  protected fun Array<out String>.arg(arg: String, default: String? = null): String {
    val values = args(arg)
    if (values.isEmpty() && default != null) {
      return default
    }

    require(values.size == 1) { "Commandline argument $arg is missing or defined multiple times" }
    return values.first()
  }

  protected fun Array<out String>.args(arg: String): List<String> {
    val key = "--$arg="
    return filter { it.startsWith(key) }.map { it.removePrefix(key) }
  }

  protected fun Array<out String>.argFile(arg: CommandLineKey, default: String? = null) = argFile(arg.name, default)
  protected fun Array<out String>.argFile(arg: String, default: String? = null) = File(arg(arg, default)).canonicalFile!!

  protected fun <Y: Any> runAndCatchNotNull(errorMessage: String, action: () -> Y?) : Y {
    try {
      return action() ?: error("<null> was returned!")
    }
    catch (t: Throwable) {
      throw Error("Failed to $errorMessage. ${t.message}", t)
    }
  }

  protected fun File.sha256(): String {
    val digest = DigestUtil.sha256()
    DigestUtil.updateContentHash(digest, this.toPath())
    return StringUtil.toHexString(digest.digest());
  }

  protected fun File.recreateDir() = apply {
    FileUtil.delete(this)
    FileUtil.createDirectory(this)
  }

  protected fun File.totalSize(): Long {
    if (isFile) return length()
    return Files.walk(this.toPath()).mapToLong {
      when {
        it.isFile() -> java.lang.Long.max(it.sizeOrNull(), 0L)
        else -> 0L
      }
    }.sum()
  }
}
