### Generic words ###
GNAME.function=function
GNAME.class=class
GNAME.var=variable
GNAME.item=item

### Actions: ACT ###
ACT.FAMILY.import=import

# Actions and associated commands
ACT.NAME.add.import=Add import
ACT.NAME.use.import=Import this name

ACT.CMD.use.import=Use an imported module
ACT.qualify.with.module=Qualify with an imported module
ACT.from.some.module.import=Import from ...

### Quick fixes ###
QFIX.add.parameter.self=Add parameter 'self'

QFIX.NAME.parameters=Parameters of functions and methods
QFIX.rename.parameter.to.$0=Rename to ''{0}''

QFIX.NAME.add.field.$0.to.class.$1=Add field ''{0}'' to class {1}
QFIX.added.constructor.$0.for.field.$1=Added a constructor to class <code>{0}</code><br/>to accommodate new field <code>{1}</code>
QFIX.failed.to.add.field=<br/>Failed to add a field!<br/><br/>

QFIX.NAME.add.method.$0.to.class.$1=Add method ''{0}''() to class {1}
QFIX.failed.to.add.method=<br/>Failed to add a method!<br/><br/>

QFIX.action.failed=Action failed

QFIX.remove.trailing.semicolon=Remove trailing semicolon

# Intentions: INTN
INTN.Family.convert.import.unqualify=Convert 'import' to 'from ... import'
INTN.Family.convert.import.qualify=Convert 'from ... import' to 'import'
INTN.Family.toggle.import.alias=Toggle import alias

INTN.convert.to.from.$0.import=Convert to ''from {0} import ...''

INTN.alias.for.$0.dialog.title=Alias for ''{0}''?

# Conflict checker
CONFLICT.name.$0.obscured=Name ''{0}'' obscured by local definitions
CONFLICT.name.$0.obscured.cannot.convert=Name ''{0}'' obscured. Cannot convert.
CONFLICT.occurrence.sing=occurrence
CONFLICT.occurrence.pl=occurrences

### Surround with templates ###
surround.with.whileelse.template=while / else
surround.with.return.template=return
surround.with.try.except.template=try / except

### Inspections: INSP ###
INSP.GROUP.python=Python

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Incorrect call arguments
INSP.duplicate.argument=Duplicate argument
INSP.duplicate.star.arg=Duplicate *arg
INSP.duplicate.doublestar.arg=Duplicate **arg
INSP.cannot.appear.past.keyword.arg=Cannot appear past keyword arguments
INSP.unexpected.arg=Unexpected argument
INSP.parameter.$0.unfilled=Parameter ''{0}'' unfilled
INSP.func.$0.lacks.first.arg=Function ''{0}'' lacks a positional argument
INSP.cannot.analyze=This argument list cannot be analyzed

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Methods having troubles with first parameter
INSP.must.have.first.parameter=Method must have a first parameter, usually called 'self'
INSP.probably.mistyped.self=Did not you mean 'self'?
INSP.usually.named.self=Usually first parameter of a method is named 'self'
INSP.usually.named.cls=Usually first parameter of a classmethod is named 'cls'
INSP.first.param.must.not.be.tuple=First parameter of a non-static method must not be a tuple

# PyRedeclarationInspection
INSP.NAME.redeclaration=Names redeclared without usage
INSP.shadows.same.named.$0.above=Shadows same-named {0} above

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Unresolved references
INSP.module.$0.not.found=Module ''{0}'' not found
INSP.unresolved.ref.$0=Unresolved reference ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Unresolved attribute reference ''{0}'' for class ''{1}''
INSP.cannot.find.$0.in.$1=Cannot find reference ''{0}'' in ''{1}''

# ReturnValueFromInitInspection
INSP.NAME.init.return=__init__ method that returns a value
INSP.cant.return.value.from.init=Cannot return a value from __init__

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=Unreachable code
INSP.unreachable.code=This code is unreachable

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=Reassignment of method's first argument
INSP.first.arg.$0.assigned=Method''s parameter ''{0}'' reassigned

# PyStringFormatInspection
INSP.NAME.str.format=Errors in string formatting operations

# PyMethodOverridingInspection
INSP.NAME.method.over=Method signature does not match signature of overridden method

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=Trailing semicolon in statement

# Refactoring
# introduce
refactoring.introduce.name.error=Incorrect name
refactoring.introduce.selection.error=Cannot perform refactoring using selected element(s)

# introduce variable
refactoring.introduce.variable.dialog.title=Introduce Variable
refactoring.introduce.variable.scope.error=Name clashes with existing variable or parameter

# introduce constant
refactoring.introduce.constant.dialog.title=Introduce Constant
refactoring.introduce.constant.scope.error=Name is already declared in scope

# pull up
refactoring.pull.up.dialog.title=Pull members up to
refactoring.pull.up.error.cannot.perform.refactoring.using.selected.elements=Cannot perform pull member up using selected element(s)
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=Cannot perform pull up member: not inside the class
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=Class {0} has no super classes

### Annotators ###
ANN.deleting.none=deleting None
ANN.assign.to.none=assignment to None
ANN.cant.assign.to.call=can't assign to function call
ANN.cant.delete.call=can't delete function call
ANN.cant.aug.assign.to.generator=augmented assign to generator expression not possible
ANN.cant.aug.assign.to.tuple.or.generator=augmented assign to tuple literal or generator expression not possible
ANN.cant.assign.to.generator=assign to generator expression not possible
ANN.cant.assign.to.operator=can't assign to operator
ANN.cant.assign.to.parens=can't assign to ()
ANN.cant.assign.to.brackets=can't assign to []
ANN.cant.aug.assign.to.list.or.comprh=augmented assign to list literal or comprehension not possible
ANN.cant.assign.to.comprh=assign to list comprehension not possible
ANN.cant.aug.assign.to.comprh=augmented assign to list comprehension not possible
ANN.cant.assign.to.literal=can't assign to literal
ANN.cant.delete.literal=can't delete literal
ANN.cant.assign.to.lambda=can't assign to lambda

ANN.break.outside.loop='break' outside loop
ANN.continue.outside.loop='continue' outside loop
ANN.cant.continue.in.finally='continue' not supported inside 'finally' clause
ANN.default.except.must.be.last=default 'except:' must be last

ANN.$0.both.global.and.param=Name ''{0}'' used both as a parameter and as a global
ANN.$0.assigned.before.global.decl=Name ''{0}'' is assigned before global declaration

ANN.duplicate.param.name=duplicate parameter name
ANN.starred.param.after.kwparam=* parameter after ** parameter
ANN.regular.param.after.vararg=regular parameter after * parameter
ANN.regular.param.after.keyword=regular parameter after ** parameter
ANN.non.default.param.after.default=non-default parameter follows default parameter

ANN.star.import.at.top.only='import *' only allowed at module level

### parsing
PARSE.expected.expression=expression expected
PARSE.expected.rbracket=']' expected
PARSE.expected.expr.or.comma.or.bracket=expected expression, ',' or ']'
PARSE.expected.in='in' expected
PARSE.expected.for.or.bracket=']' or 'for' expected
PARSE.expected.comma=',' expected
PARSE.expected.colon=':' expected
PARSE.expected.rpar=')' expected
PARSE.expected.lpar='(' expected
PARSE.expected.tick='`' (backtick) expected
PARSE.expected.name=name expected
PARSE.expected.colon.or.rbracket=':' or ']' expected
PARSE.expected.comma.or.rpar=',' or ')' expected
PARSE.expected.else='else' expected

PARSE.expected.func.name=function name expected
PARSE.expected.comma.lpar.rpar=',' or '(' or ')' expected
PARSE.expected.statement.break=Statement break expected
PARSE.expected.@.or.def='@' or 'def' expected
PARSE.expected.formal.param.name=formal parameter name expected

### qiuck doc generator
QDOC.copied.from.$0.$1=<i>Documentation is missing.</i> The following if copied from <code>{0}.{1}</code>.
QDOC.copied.from.builtin=<small>(copied from built-in description)</small>
QDOC.assigned.to.$0=Assigned to <code>{0}</code>
QDOC.wrapped.in.$0=Wrapped in <code>{0}</code>

### unittest run configuration
runcfg.unittest.display_name=Python's unittest
runcfg.unittest.description=Python's unittest run configuration
runcfg.unittest.no_script_name=Please, specify script name
runcfg.unittest.no_class_name=Please, specify class name
runcfg.unittest.no_method_name=Please, specify method name
runcfg.unittest.no_folder_name=Please, specify folder with tests
runcfg.unittest.dlg.tests_group_title=Tests:
runcfg.unittest.dlg.test_script_label=Script:
runcfg.unittest.dlg.class_label=Class:
runcfg.unittest.dlg.method_label=Method:
runcfg.unittest.dlg.folder_path=Folder:
runcfg.unittest.dlg.test_type_title=Type:
runcfg.unittest.dlg.all_in_folder_title=All tests in folder
runcfg.unittest.dlg.all_in_script_title=Tests in script
runcfg.unittest.dlg.test_class_title=Test class
runcfg.unittest.dlg.test_method_title=Test method
runcfg.unittest.dlg.folder_title=Tests folder:
runcfg.unittest.no_valid_sdk=Please select a valid Python interpeter
runcfg.unittest.no_module_sdk=Please select a module with a valid Python SDK
runcfg.unittest.no_sdk=Please specify Python SDK
runcfg.unittest.dlg.select.folder.path=Select folder path:
runcfg.unittest.dlg.select.script.path=Select script path:
runcfg.unittest.dlg.interpreter_options_title=Interpreter options:
runcfg.unittest.dlg.messages.working.dir=Working directory:
runcfg.labels.script_parameters=Script &parameters:
runcfg.labels.script=&Script:
runcfg.labels.environment_variables=&Environment variables:
runcfg.labels.interpreter=&Use specified interpreter:
runcfg.labels.interpreter_options=Interpreter &options:
runcfg.labels.working_directory=&Working directory:
runcfg.captions.script_parameters_dialog=Enter script parameters
runcfg.captions.interpreter_options_dialog=Enter interpreter options
