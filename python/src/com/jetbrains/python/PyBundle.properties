### Generic words ###
GNAME.function=function
GNAME.class=class
GNAME.var=variable
GNAME.item=item

### Actions: ACT ###
ACT.FAMILY.import=import

# AddImport
ACT.NAME.add.import=Add import

### Quick fixes ###
QFIX.add.parameter.self=Add parameter 'self'

QFIX.NAME.parameters=Parameters of functions and methods
QFIX.rename.parameter.to.self=Rename to 'self'

QFIX.NAME.add.field.$0.to.class.$1=Add field ''{0}'' to class {1}
QFIX.added.constructor.$0.for.field.$1=Added a constructor to class <code>{0}</code><br/>to accommodate new field <code>{1}</code>
QFIX.failed.to.add.field=<br/>Failed to add a field!<br/><br/>

QFIX.NAME.add.method.$0.to.class.$1=Add method ''{0}''() to class {1}
QFIX.failed.to.add.method=<br/>Failed to add a method!<br/><br/>


### Inspections: INSP ###
INSP.GROUP.python=Python

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Incorrect call arguments
INSP.duplicate.argument=Duplicate argument
INSP.duplicate.star.arg=Duplicate *arg
INSP.duplicate.doublestar.arg=Duplicate **arg
INSP.cannot.appear.past.keyword.arg=Cannot appear past keyword arguments
INSP.unexpected.arg=Unexpected argument
INSP.parameter.$0.unfilled=Parameter ''{0}'' unfilled
INSP.func.$0.lacks.first.arg=Function ''{0}'' lacks a positional argument

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Methods having troubles with first parameter
INSP.must.have.first.parameter=Method must have a first parameter, usually called 'self'
INSP.probably.mistyped.self=Did not you mean 'self'?
INSP.usually.named.self=Usually first parameter of a method is named 'self'
INSP.usually.named.cls=Usually first parameter of a classmethod is named 'cls'

# PyRedeclarationInspection
INSP.NAME.redeclaration=Names redeclared without usage
INSP.shadows.same.named.$0.above=Shadows same-named {0} above

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Unresolved references
INSP.module.$0.not.found=Module ''{0}'' not found
INSP.unresolved.ref.$0=Unresolved reference ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Unresolved attribute reference ''{0}'' for class ''{1}''

# ReturnValueFromInitInspection
INSP.NAME.init.return=__init__ method that returns a value
INSP.cant.return.value.from.init=Cannot return a value from __init__

### Annotators ###
ANN.deleting.none=deleting None
ANN.assign.to.none=assignment to None
ANN.cant.assign.to.call=can't assign to function call
ANN.cant.delete.call=can't delete function call
ANN.cant.aug.assign.to.generator=augmented assign to generator expression not possible
ANN.cant.aug.assign.to.tuple.or.generator=augmented assign to tuple literal or generator expression not possible
ANN.cant.assign.to.generator=assign to generator expression not possible
ANN.cant.assign.to.operator=can't assign to operator
ANN.cant.assign.to.parens=can't assign to ()
ANN.cant.assign.to.brackets=can't assign to []
ANN.cant.aug.assign.to.list.or.comprh=augmented assign to list literal or comprehension not possible
ANN.cant.assign.to.comprh=assign to list comprehension not possible
ANN.cant.aug.assign.to.comprh=augmented assign to list comprehension not possible
ANN.cant.assign.to.literal=can't assign to literal
ANN.cant.assign.to.lambda=can't assign to lambda

ANN.break.outside.loop='break' outside loop
ANN.continue.outside.loop='continue' outside loop
ANN.cant.continue.in.finally='continue' not supported inside 'finally' clause
ANN.default.except.must.be.last=default 'except:' must be last

### parsing
PARSE.expected.expression=expression expected
PARSE.expected.rbracket=']' expected
PARSE.expected.expr.or.comma.or.bracket=expected expression, ',' or ']'
PARSE.expected.in='in' expected
PARSE.expected.for.or.bracket=']' or 'for' expected
PARSE.expected.comma=',' expected
PARSE.expected.colon=':' expected
PARSE.expected.rpar=')' expected
PARSE.expected.lpar='(' expected
PARSE.expected.tick='`' (backtick) expected
PARSE.expected.name=name expected
PARSE.expected.colon.or.rbracket=':' or ']' expected
PARSE.expected.comma.or.rpar=',' or ')' expected
PARSE.expected.else='else' expected

PARSE.expected.func.name=function name expected
PARSE.expected.comma.lpar.rpar=',' or '(' or ')' expected
PARSE.expected.statement.break=Statement break expected
PARSE.expected.@.or.def='@' or 'def' expected
PARSE.expected.formal.param.name=formal parameter name expected

### unittest run configuration
runcfg.unittest.display_name=Python's unittest
runcfg.unittest.description=Python's unittest run configuration
runcfg.unittest.no_script_name=Please, specify script name
runcfg.unittest.no_class_name=Please, specify class name
runcfg.unittest.no_method_name=Please, specify method name
runcfg.unittest.no_folder_name=Please, specify folder with tests
runcfg.unittest.dlg.tests_group_title=Tests:
runcfg.unittest.dlg.test_script_label=Script:
runcfg.unittest.dlg.class_label=Class:
runcfg.unittest.dlg.method_label=Method:
runcfg.unittest.dlg.folder_path=Folder:
runcfg.unittest.dlg.test_type_title=Type:
runcfg.unittest.dlg.all_in_folder_title=All tests in folder
runcfg.unittest.dlg.all_in_script_title=Tests in script
runcfg.unittest.dlg.test_class_title=Test class
runcfg.unittest.dlg.test_method_title=Test method
runcfg.unittest.dlg.folder_title=Tests folder:
runcfg.unittest.no_valid_sdk=Please select a valid Python interpeter
runcfg.unittest.no_sdk=Please, specify Python SDK
runcfg.unittest.dlg.select.folder.path=Select folder path:
runcfg.unittest.dlg.select.script.path=Select script path:
runcfg.unittest.dlg.interpreter_options_title=Interpreter options:
runcfg.unittest.dlg.messages.working.dir=Working directory:
runcfg.labels.script_parameters=Script &parameters:
runcfg.labels.script=&Script:
runcfg.labels.environment_variables=&Environment variables:
runcfg.labels.interpreter=&Interpreter:
runcfg.labels.interpreter_options=Interpreter &options:
runcfg.labels.working_directory=&Working directory:
runcfg.captions.script_parameters_dialog=Enter script parameters
runcfg.captions.interpreter_options_dialog=Enter interpreter options