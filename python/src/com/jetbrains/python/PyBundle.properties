### Generic words ###
GNAME.function=function
GNAME.class=class
GNAME.var=variable
GNAME.item=item

### Actions: ACT ###
ACT.FAMILY.import=import

# Actions and associated commands
ACT.NAME.add.import=Add import
ACT.NAME.use.import=Import this name

ACT.CMD.use.import=Use an imported module
ACT.qualify.with.module=Qualify with an imported module
ACT.from.some.module.import=Import from ...

### Quick fixes ###
QFIX.add.parameter.self=Add parameter 'self'

QFIX.NAME.parameters=Parameters of functions and methods
QFIX.rename.parameter.to.$0=Rename to ''{0}''

QFIX.NAME.add.field.$0.to.class.$1=Add field ''{0}'' to class {1}
QFIX.added.constructor.$0.for.field.$1=Added a constructor to class <code>{0}</code><br/>to accommodate new field <code>{1}</code>
QFIX.failed.to.add.field=<br/>Failed to add a field!<br/><br/>

QFIX.NAME.add.method.$0.to.class.$1=Add method ''{0}''() to class {1}
QFIX.failed.to.add.method=<br/>Failed to add a method!<br/><br/>

QFIX.action.failed=Action failed

QFIX.remove.trailing.semicolon=Remove trailing semicolon

QFIX.replace.noteq.operator=Replace not equal operator

QFIX.replace.backquote.expression=Replace backquote expression

QFIX.replace.method=Replace method which is not supported in current Python version

QFIX.remove.leading.u=Remove leading U

QFIX.remove.trailing.l=Remove trailing L

QFIX.replace.raise.statement=Convert raise statement to supported form

QFIX.replace.except.part=Convert except clause to supported form

QFIX.replace.list.comprehensions=Convert list comprehensions to supported form

QFIX.replace.octal.numeric.literal=Convert octal numeric literal to supported form

QFIX.dict.creation=Replace dictionary creation

QFIX.classic.class.transform=Inherit from object

# Intentions: INTN
INTN.Family.convert.import.unqualify=Convert 'import module' to 'from module import'
INTN.Family.convert.import.qualify=Convert 'from module import' to 'import module'
INTN.Family.toggle.import.alias=Toggle import alias
INTN.Family.convert.except.part=Convert except part to supported form
INTN.Family.convert.set.literal=Convert set literal two supported forms
INTN.Family.convert.builtin=Convert builtin module import
INTN.Family.convert.dict.comp.expression=Convert dictionary comprehension expression

INTN.convert.to.from.$0.import.$1=Convert to ''from {0} import {1}''
INTN.convert.to.import.$0=Convert to ''import {0}''

INTN.alias.for.$0.dialog.title=Alias for ''{0}''?
INTN.add.alias.for.import.$0=Add alias to ''{0}''
INTN.remove.alias.for.import.$0=Remove alias ''{0}''

INTN.convert.except.to=Convert 'except exceptClass as Target' to 'except exceptClass, Target'

INTN.convert.set.literal.to=Convert set literal to 'set' method call

INTN.convert.builtin.import=Convert builtin module import to supported form

INTN.convert.dict.comp.to=Convert dictionary comprehension to 'dict' method call

# Conflict checker
CONFLICT.name.$0.obscured=Name ''{0}'' obscured by local definitions
CONFLICT.name.$0.obscured.cannot.convert=Name ''{0}'' obscured. Cannot convert.
CONFLICT.occurrence.sing=occurrence
CONFLICT.occurrence.pl=occurrences

### Surround with templates ###
surround.with.whileelse.template=while / else
surround.with.return.template=return
surround.with.try.except.template=try / except

### Inspections: INSP ###
INSP.GROUP.python=Python

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Incorrect call arguments
INSP.duplicate.argument=Duplicate argument
INSP.duplicate.star.arg=Duplicate *arg
INSP.duplicate.doublestar.arg=Duplicate **arg
INSP.cannot.appear.past.keyword.arg=Cannot appear past keyword arguments
INSP.unexpected.arg=Unexpected argument
INSP.parameter.$0.unfilled=Parameter ''{0}'' unfilled
INSP.func.$0.lacks.first.arg=Function ''{0}'' lacks a positional argument
INSP.cannot.analyze=This argument list cannot be analyzed

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Methods having troubles with first parameter
INSP.must.have.first.parameter=Method must have a first parameter, usually called 'self'
INSP.probably.mistyped.self=Did not you mean 'self'?
INSP.usually.named.self=Usually first parameter of a method is named 'self'
INSP.usually.named.cls=Usually first parameter of a classmethod is named 'cls'
INSP.first.param.must.not.be.tuple=First parameter of a non-static method must not be a tuple

# PyRedeclarationInspection
INSP.NAME.redeclaration=Names redeclared without usage
INSP.shadows.same.named.$0.above=Shadows same-named {0} above

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Unresolved references
INSP.module.$0.not.found=Module ''{0}'' not found
INSP.unresolved.ref.$0=Unresolved reference ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Unresolved attribute reference ''{0}'' for class ''{1}''
INSP.cannot.find.$0.in.$1=Cannot find reference ''{0}'' in ''{1}''

# ReturnValueFromInitInspection
INSP.NAME.init.return=__init__ method that returns a value
INSP.cant.return.value.from.init=Cannot return a value from __init__

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=Unreachable code
INSP.unreachable.code=This code is unreachable

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=Reassignment of method's first argument
INSP.first.arg.$0.assigned=Method''s parameter ''{0}'' reassigned

# PyStringFormatInspection
INSP.NAME.str.format=Errors in string formatting operations

# PyMethodOverridingInspection
INSP.NAME.method.over=Method signature does not match signature of overridden method

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=Trailing semicolon in statement

# PyUnusedLocalVariableInspection
INSP.NAME.unused=Unused local variable
INSP.unused.locals.parameter.isnot.used=Parameter ''{0}'' value is not used
INSP.unused.locals.local.variable.isnot.used=Local variable ''{0}'' value is not used

# PyUnsupportedFeaturesInspection
INSP.NAME.unsupported.features=Feature is not supported by Python 3
INSP.method.$0.removed.use.$1=Method ''{0}'' has been removed, use ''{1}'' instead
INSP.method.$0.removed=Method ''{0}'' removed

# PyDeprecatedModulesInspection
INSP.NAME.deprecated.modules=Module marked as deprecated
INSP.module.$0.is.deprecated.in.version=Module ''{0}'' is deprecated in current Python version

# PyDictCreationInspection
INSP.NAME.dict.creation=Dictionary creation could be rewritten by dictionary literal

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=Bad except clauses order
INSP.class.$0.already.caught=Exception class ''{0}'' has already been caught

# PyTupleAssignmentBalanceInspection
INSP.NAME.incorrect.assignment=Tuple assignment balance is incorrect

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=Classic style class usage

# PyAssigningFunctionCallInspection
INSP.NAME.assigning.function=Assigning to function call which doesn't return or returns only ''None''

# Refactoring
# introduce
refactoring.introduce.name.error=Incorrect name
refactoring.introduce.selection.error=Cannot perform refactoring using selected element(s)

# introduce variable
refactoring.introduce.variable.dialog.title=Introduce Variable
refactoring.introduce.variable.scope.error=Name clashes with existing variable or parameter

# introduce constant
refactoring.introduce.constant.dialog.title=Introduce Constant
refactoring.introduce.constant.scope.error=Name is already declared in scope

# pull up
refactoring.pull.up.dialog.title=Pull members up to
refactoring.pull.up.error.cannot.perform.refactoring.using.selected.elements=Cannot perform pull member up using selected element(s)
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=Cannot perform pull member up: not inside the class
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=Class {0} has no super classes

# push down
refactoring.push.down.dialog.title=Push members down from
refactoring.push.down.error.cannot.perform.refactoring.using.selected.elements=Cannot perform push member down using selected element(s)
refactoring.push.down.error.cannot.perform.refactoring.not.inside.class=Cannot perform pull member down: not inside the class

# inline
refactoring.inline.local.multiassignment=Definition is in multi-assign

# extract method
refactoring.extract.method.error.cannot.perform.refactoring.when.class.declaration.inside=Cannot perform refactoring with class declaration inside code block
refactoring.extract.method.error.cannot.perform.refactoring.when.function.declaration.inside=Cannot perform refactoring with function declaration inside code block
refactoring.extract.method.error.cannot.perform.refactoring.no.corresponding.loop.for.break=No corresponding loop for break statement inside code fragment
refactoring.extract.method.error.cannot.perform.refactoring.no.corresponding.loop.for.continue=No corresponding loop for continue statement inside code fragment
refactoring.extract.method.error.cannot.perform.refactoring.when.execution.flow.is.interrupted=Cannot perform refactoring when execution flow is interrupted
refactoring.extract.method.error.cannot.perform.refactoring.when.from.import.inside=Cannot perform refactoring with from import statement inside code block
refactoring.extract.method.error.cannot.perform.refactoring.using.selected.elements=Cannot perform extract method using selected element(s)
refactoring.extract.method.error.name.clash=Method name clashes with already existing method name

### Annotators ###
ANN.deleting.none=deleting None
ANN.assign.to.none=assignment to None
ANN.cant.assign.to.call=can't assign to function call
ANN.cant.delete.call=can't delete function call
ANN.cant.aug.assign.to.generator=augmented assign to generator expression not possible
ANN.cant.aug.assign.to.tuple.or.generator=augmented assign to tuple literal or generator expression not possible
ANN.cant.assign.to.generator=assign to generator expression not possible
ANN.cant.assign.to.operator=can't assign to operator
ANN.cant.assign.to.parens=can't assign to ()
ANN.cant.assign.to.brackets=can't assign to []
ANN.cant.aug.assign.to.list.or.comprh=augmented assign to list literal or comprehension not possible
ANN.cant.assign.to.comprh=can't assign to list comprehension
ANN.cant.assign.to.dict.comprh=can't assign to dict comprehension
ANN.cant.assign.to.set.comprh=can't assign to set comprehension
ANN.cant.aug.assign.to.comprh=augmented assign to list comprehension not possible
ANN.cant.aug.assign.to.dict.comprh=augmented assign to dict comprehension not possible
ANN.cant.aug.assign.to.set.comprh=augmented assign to set comprehension not possible
ANN.cant.assign.to.literal=can't assign to literal
ANN.cant.delete.literal=can't delete literal
ANN.cant.assign.to.lambda=can't assign to lambda

ANN.break.outside.loop='break' outside loop
ANN.continue.outside.loop='continue' outside loop
ANN.cant.continue.in.finally='continue' not supported inside 'finally' clause
ANN.default.except.must.be.last=default 'except:' must be last

ANN.$0.both.global.and.param=Name ''{0}'' used both as a parameter and as a global
ANN.$0.assigned.before.global.decl=Name ''{0}'' is assigned before global declaration

ANN.duplicate.param.name=duplicate parameter name
ANN.starred.param.after.kwparam=* parameter after ** parameter
ANN.regular.param.after.vararg=regular parameter after * parameter
ANN.regular.param.after.keyword=regular parameter after ** parameter
ANN.non.default.param.after.default=non-default parameter follows default parameter
ANN.named.arguments.after.star=named arguments must follow bare *
ANN.tuple.py3=tuple parameter unpacking is not supported in Python 3

ANN.star.import.at.top.only='import *' only allowed at module level

### parsing
PARSE.expected.expression=expression expected
PARSE.expected.rbracket=']' expected
PARSE.expected.expr.or.comma.or.bracket=expected expression, ',' or ']'
PARSE.expected.in='in' expected
PARSE.expected.for.or.bracket=']' or 'for' expected
PARSE.expected.comma=',' expected
PARSE.expected.colon=':' expected
PARSE.expected.rpar=')' expected
PARSE.expected.lpar='(' expected
PARSE.expected.tick='`' (backtick) expected
PARSE.expected.name=name expected
PARSE.expected.colon.or.rbracket=':' or ']' expected
PARSE.expected.comma.or.rpar=',' or ')' expected
PARSE.expected.else='else' expected

PARSE.expected.func.name=function name expected
PARSE.expected.comma.lpar.rpar=',' or '(' or ')' expected
PARSE.expected.statement.break=Statement break expected
PARSE.expected.@.or.def='@' or 'def' expected
PARSE.expected.formal.param.name=formal parameter name expected

### qiuck doc generator
QDOC.copied.from.$0.$1=<i>Documentation is missing.</i> The following if copied from <code>{0}.{1}</code>.
QDOC.copied.from.builtin=<small>(copied from built-in description)</small>
QDOC.assigned.to.$0=Assigned to <code>{0}</code>
QDOC.wrapped.in.$0=Wrapped in <code>{0}</code>

### unittest run configuration
runcfg.unittest.display_name=Python's unittest
runcfg.unittest.description=Python's unittest run configuration
runcfg.unittest.no_script_name=Please specify script name
runcfg.unittest.no_class_name=Please specify class name
runcfg.unittest.no_method_name=Please specify method name
runcfg.unittest.no_folder_name=Please specify folder with tests
runcfg.unittest.dlg.tests_group_title=Tests:
runcfg.unittest.dlg.test_script_label=Script:
runcfg.unittest.dlg.class_label=Class:
runcfg.unittest.dlg.method_label=Method:
runcfg.unittest.dlg.folder_path=Folder:
runcfg.unittest.dlg.test_type_title=Type:
runcfg.unittest.dlg.all_in_folder_title=All tests in folder
runcfg.unittest.dlg.all_in_script_title=Tests in script
runcfg.unittest.dlg.test_class_title=Test class
runcfg.unittest.dlg.test_method_title=Test method
runcfg.unittest.dlg.folder_title=Tests folder:
runcfg.unittest.no_valid_sdk=Please select a valid Python interpeter
runcfg.unittest.no_module_sdk=Please select a module with a valid Python SDK
runcfg.unittest.no_sdk=Please specify a Python SDK
runcfg.unittest.dlg.select.folder.path=Select folder path:
runcfg.unittest.dlg.select.script.path=Select script path:
runcfg.unittest.dlg.interpreter_options_title=Interpreter options:
runcfg.unittest.dlg.messages.working.dir=Working directory:
runcfg.labels.script_parameters=Script &parameters:
runcfg.labels.script=&Script:
runcfg.labels.environment_variables=&Environment variables:
runcfg.labels.interpreter=&Use specified interpreter:
runcfg.labels.interpreter_options=Interpreter &options:
runcfg.labels.working_directory=&Working directory:
runcfg.captions.script_parameters_dialog=Enter script parameters
runcfg.captions.interpreter_options_dialog=Enter interpreter options
sdk.error.invalid.interpreter.name.$0=Invalid Python interpeter name '{0}'!
sdk.select.path=Select Python Interpreter
python.console=Python Console