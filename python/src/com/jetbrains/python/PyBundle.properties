### Generic words ###
GNAME.function=function
GNAME.class=class
GNAME.var=variable
GNAME.item=item

### Actions: ACT ###
ACT.FAMILY.import=import

# AddImport
ACT.NAME.add.import=Add import


### Quick fixes ###
QFIX.add.parameter.self=Add parameter 'self'


### Inspections: INSP ###
INSP.GROUP.python=Python

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Incorrect call arguments
INSP.duplicate.argument=Duplicate argument
INSP.duplicate.star.arg=Duplicate *arg
INSP.duplicate.doublestar.arg=Duplicate **arg
INSP.cannot.appear.past.keyword.arg=Cannot appear past keyword arguments
INSP.unexpected.arg=Unexpected argument
INSP.parameter.$0.unfilled=Parameter ''{0}'' unfilled

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Methods having troubles with first parameter
INSP.must.have.first.parameter=Method must have a first parameter, usually called 'self'
INSP.probably.mistyped.self=Did not you mean 'self'?
INSP.usually.named.self=Usually first parameter of a method is named 'self'

# PyRedeclarationInspection
INSP.NAME.redeclaration=Names redeclared without usage
INSP.shadows.same.named.$0.above=Shadows same-named {0} above

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Unresolved references
INSP.module.$0.not.found=Module ''{0}'' not found
INSP.unresolved.ref.$0=Unresolved reference ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Unresolved attribute reference ''{0}'' for class ''{1}''

### Annotators ###
ANN.deleting.none=deleting None
ANN.assign.to.none=assignment to None
ANN.cant.assign.to.call=can't assign to function call
ANN.cant.delete.call=can't delete function call
ANN.cant.aug.assign.to.generator=augmented assign to generator expression not possible
ANN.cant.aug.assign.to.tuple.or.generator=augmented assign to tuple literal or generator expression not possible
ANN.cant.assign.to.generator=assign to generator expression not possible
ANN.cant.assign.to.operator=can't assign to operator
ANN.cant.assign.to.parens=can't assign to ()
ANN.cant.assign.to.brackets=can't assign to []
ANN.cant.aug.assign.to.list.or.comprh=augmented assign to list literal or comprehension not possible
ANN.cant.assign.to.comprh=assign to list comprehension not possible
ANN.cant.aug.assign.to.comprh=augmented assign to list comprehension not possible
ANN.cant.assign.to.literal=can't assign to literal
ANN.cant.assign.to.lambda=can't assign to lambda

ANN.break.outside.loop='break' outside loop
ANN.continue.outside.loop='continue' outside loop
ANN.cant.continue.in.finally='continue' not supported inside 'finally' clause

### parsing
PARSE.expected.expression=expression expected
PARSE.expected.rbracket=']' expected
PARSE.expected.expr.or.comma.or.bracket=expected expression, ',' or ']'
PARSE.expected.in='in' expected
PARSE.expected.for.or.bracket=']' or 'for' expected
PARSE.expected.comma=',' expected
PARSE.expected.colon=':' expected
PARSE.expected.rpar=')' expected
PARSE.expected.lpar='(' expected
PARSE.expected.tick='`' (backtick) expected
PARSE.expected.name=name expected
PARSE.expected.colon.or.rbracket=':' or ']' expected
PARSE.expected.comma.or.rpar=',' or ')' expected
PARSE.expected.else='else' expected

PARSE.expected.func.name=function name expected
PARSE.expected.comma.lpar.rpar=',' or '(' or ')' expected
PARSE.expected.statement.break=Statement break expected
PARSE.expected.@.or.def='@' or 'def' expected
PARSE.expected.formal.param.name=formal parameter name expected




