readonly.occurences.found=Occurrences found in read-only files
progress.text=Looking For Usages...
usageView.tabText=Refactoring preview
usageView.usagesText=usages
usageView.need.reRun=Cannot perform the refactoring operation.\nThere were changes in code after the usages have been found.\nPlease, perform the usage search again.
usageView.doAction=Do Refactor
statusBar.refactoring.result={0, choice, 1#1 occurence|2#{0,number} occurences} changed
statusBar.noUsages=No occurrences found
anonymousToInner.refactoring.name=Convert Anonymous to Inner
anonymousToInner.no.inner.class.name=Class name should be specified
inner.class.exists=Inner class named ''{0}'' is already defined\nin the class ''{1}''
anonymousToInner.class.name.label.text=Class name:
anonymousToInner.make.class.static.checkbox.text=Make class &static
anonymousToInner.parameters.panel.border.title=Constructor Parameters
error.wrong.caret.position=Cannot perform the refactoring.\nThe caret should be positioned inside {0} to be refactored.
refactor.string=refactor
error.cannot.resolve=Cannot resolve {0}
error.incorrect.data=Incorrect Data
error.wrong.name.input=Wrong name: {0}
error.not.supported.for.jsp={0} refactoring is not supported for JSP
changeClassSignature.refactoring.name=Change Class Signature
changeClassSignature.parameters.panel.border.title=Parameters
changeClassSignature.bad.default.value=Wrong default value: ''{0}'' for parameter {1}
changeClassSignature.class.label.text=Change signature of {0}
changeSignature.no.type.for.parameter=Specify a type for parameter ''{0}''
changeSignature.no.type.for.exception=Specify a type for exception
changeSignature.refactoring.name=Change Signature
changeSignature.name.column=Name
changeSignature.default.value.column=Default Value
changeSignature.parameters=Parameters
changeSignature.parameter=Parameter
changeSignature.exceptions=Exceptions
changeSignature.exception=Exception
changeSignature.propagate.button.text=Propagate {0}
changeSignature.caller.chooser.title=Select Methods To Propagate New {0}
name.prompt=&Name:
changeSignature.return.type.prompt=Return &type:
changeSignature.signature.preview=Signature Preview
changeSignature.wont.propagate=Recursive propagation of {0} changes won''t be performed
changeSignature.wrong.return.type=Wrong return type: ''{0}''
changeSignature.no.return.type=Specify return type
changeSignature.wrong.type.for.parameter=Wrong type: ''{0}'' for parameter {1}
changeSignature.wrong.type.for.exception=Wrong type: ''{0}'' for exception
changeSignature.vararg.not.last=Vararg parameter should be the last in method signature
changeSignature.no.default.value=New parameter {0} has been added.\nSpecify a default value to be used in all existing calls of this method.
changeSignature.not.throwable.type=Wrong type: ''{0}'' for exception, should extend java.lang.Throwable
changeSignature.cannot.resolve.type=Type ''{0}'' cannot be resolved.\nContinue?
search.in.comments.and.strings=Search in comments and &strings
search.for.text.occurences=Search for &text occurences
visibility.as.is=&As is
visibility.public=Pu&blic
visibility.protected=Pr&otected
visibility.private=Pri&vate
visibility.package.local=Pac&kage local
visibility.border.title=Visibility
row.add=&Add
row.remove=R&emove
row.move.up=Move &Up
row.move.down=Move &Down
moveInstanceMethod.select.an.instance.parameter=Select an &instance parameter:
destination.package=&Destination package:
choose.destination.package=Choose Destination Package
interface.name.prompt=&Interface name:
package.for.new.interface=&Package for new interface:
turnRefsToSuper.change.usages.to=&Change usages of {0} to:
turnRefsToSuper.use.superclass.in.instanceof=&Use interface/superclass in instanceof
class.name.prompt=Class &name:
parameter.name.prompt=Pa&rameter name:
no.class.name.specified=No class name specified
no.parameter.name.specified=No parameter name specified
pass.outer.class.instance.as.parameter=Pass &outer class' instance as a parameter
pull.up.members.to=&Pull up members of {0} to:
members.to.be.pulled.up=Members to be pulled up
make.abstract=Make abstract
javadoc.for.abstracts=JavaDoc for abstracts
extractIncludeFile.name=Extract Include File
name.for.extracted.include.file=&Name for extracted include file (without extension):
extract.to.directory=Extract to &directory:
select.target.directory.title=Select target directory
select.target.directory.description=The file will be created in this directory
create.directory=Create directory
replace.inheritance.from=&Replace with delegation inheritance from:
field.name=&Field name:
inner.class.name=&Inner class name:
superclass.name=&Super class name:
superinterface.name=&Super interface name:
delegate.members=Delegate members
generate.getter.for.delegated.component=Generate &getter for delegated component
package.for.new.superclass=&Package for new superclass:
ExtractSuperClass.superclass=Superclass
members.to.form.superclass=Members to Form Superclass
no.superclass.name.specified=No superclass name specified
extract.superclass.from=Extract superclass from:
extractSuper.extract=E&xtract {0}
extractSuper.rename.original.class=R&ename original class and use {0} where possible
extractSuper.rename.original.class.to=&Rename original class to:
extractSuperInterface.interface=Interface
members.to.form.interface=Members to Form Interface
extract.interface.from=Extract interface from:
rename.implementation.class.to=Rename implementation class to:
package.for.implementation.class=Package for implementation class:
extractSuperInterface.javadoc=JavaDoc
no.interface.name.specified=No interface name specified
replace.all.occurences=Replace &all occurences ({0} occurences)
declare.final=Declare &final
introduce.parameter.title=Introduce Parameter
parameter.of.type=Parameter of type:
delete.variable.definition=&Delete variable definition
use.variable.initializer.to.initialize.parameter=Use variable &initializer to initialize parameter
replace.fields.used.in.expressions.with.their.getters=Replace fields used in expressions with their getters
do.not.replace=Do &not replace
replace.fields.inaccessible.in.usage.context=Replace fields &inaccessible in usage context
replace.all.fields=&Replace all fields
class.does.not.exist.in.the.project=Class does not exist in the project
no.field.name.specified=No field name specified
field.exists=The field with the name {0}\nalready exists in class ''{1}''.\nContinue?
choose.destination.class=Choose Destination Class
replace.write.access.occurrences=Rep&lace write access occurrences
introduce.variable.title=Introduce Variable
variable.of.type=Variable of type:
anonymous.class=anonymous class
method=method
convert.to.instance.method.title=Convert To Instance Method
convertToInstanceMethod.method.is.not.static=Cannot perform the refactoring\nMethod {0} is not static.
convertToInstanceMethod.no.parameters.with.reference.type=There are no parameters that have a reference type
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=All reference type parametres have unknown types
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=All reference type parameters have types that are not in project
cannot.perform.refactoring=Cannot perform refactoring.
move.instance.method.title=Move Instance Method
move.method.is.not.supported.for.constructors=Move method is not supported for constructors
move.method.is.not.supported.for.generic.classes=Move method is not supported for generic classes
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=Move method is not supported when method is a part of inheritance hierarchy
synthetic.jsp.class.is.referenced.in.the.method=Synthetic jsp class is referenced in the method
there.are.no.variables.that.have.reference.type=There are no variables that have a reference type
all.candidate.variables.have.unknown.types=All candidate variables have unknown types
all.candidate.variables.have.types.not.in.project=All candidate variables have types that are not in project