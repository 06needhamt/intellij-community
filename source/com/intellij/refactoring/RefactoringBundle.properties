readonly.occurences.found=Occurrences found in read-only files
progress.text=Looking For Usages...
usageView.tabText=Refactoring preview
usageView.usagesText=usages
usageView.need.reRun=Cannot perform the refactoring operation.\nThere were changes in code after the usages have been found.\nPlease, perform the usage search again.
usageView.doAction=Do Refactor
statusBar.refactoring.result={0, choice, 1#1 occurence|2#{0,number} occurences} changed
statusBar.noUsages=No occurrences found
anonymousToInner.refactoring.name=Convert Anonymous to Inner
anonymousToInner.no.inner.class.name=Class name should be specified
inner.class.exists=Inner class named ''{0}'' is already defined\nin the class ''{1}''
anonymousToInner.class.name.label.text=Class name:
anonymousToInner.make.class.static.checkbox.text=Make class &static
anonymousToInner.parameters.panel.border.title=Constructor Parameters
error.wrong.caret.position.method=The caret should be positioned inside the method to be refactored.
error.wrong.caret.position.anonymous=The caret should be positioned inside the anonymous class to be refactored.
error.wrong.caret.position.class=The caret should be positioned inside the class to be refactored.
error.wrong.caret.position.method.or.local.name=The caret should be positioned at the name of\nthe method or local variable to be refactored..
to.refactor=to refactor
error.cannot.resolve=Cannot resolve {0}
error.incorrect.data=Incorrect Data
error.wrong.name.input=Wrong name: {0}
error.not.supported.for.jsp={0} refactoring is not supported for JSP
changeClassSignature.refactoring.name=Change Class Signature
changeClassSignature.parameters.panel.border.title=Parameters
changeClassSignature.bad.default.value=Wrong default value: ''{0}'' for parameter {1}
changeClassSignature.class.label.text=Change signature of {0}
changeSignature.no.type.for.parameter=Specify a type for parameter ''{0}''
changeSignature.no.type.for.exception=Specify a type for exception
changeSignature.refactoring.name=Change Signature
changeSignature.name.column=Name
changeSignature.default.value.column=Default Value
changeSignature.parameters.border.title=Parameters
changeSignature.exceptions.panel.border.title=Exceptions
changeSignature.propagate.parameters.title=Propagate Parameters
changeSignature.propagate.exceptions.title=Propagate Exceptions
changeSignature.parameter.caller.chooser=Select Methods To Propagate New Parameters
changeSignature.exception.caller.chooser=Select Methods To Propagate New Exceptions
name.prompt=&Name:
changeSignature.return.type.prompt=Return &type:
changeSignature.signature.preview=Signature Preview
changeSignature.parameters.wont.propagate=Recursive propagation of parameter changes won''t be performed
changeSignature.exceptions.wont.propagate=Recursive propagation of exception changes won''t be performed
changeSignature.wrong.return.type=Wrong return type: ''{0}''
changeSignature.no.return.type=Specify return type
changeSignature.wrong.type.for.parameter=Wrong type: ''{0}'' for parameter {1}
changeSignature.wrong.type.for.exception=Wrong type: ''{0}'' for exception
changeSignature.vararg.not.last=Vararg parameter should be the last in method signature
changeSignature.no.default.value=New parameter {0} has been added.\nSpecify a default value to be used in all existing calls of this method.
changeSignature.not.throwable.type=Wrong type: ''{0}'' for exception, should extend java.lang.Throwable
changeSignature.cannot.resolve.type=Type ''{0}'' cannot be resolved.\nContinue?
search.in.comments.and.strings=Search in comments and &strings
search.for.text.occurences=Search for &text occurences
visibility.as.is=&As is
visibility.public=Pu&blic
visibility.protected=Pr&otected
visibility.private=Pri&vate
visibility.package.local=Pac&kage local
visibility.border.title=Visibility
row.add=&Add
row.remove=R&emove
row.move.up=Move &Up
row.move.down=Move &Down
moveInstanceMethod.select.an.instance.parameter=Select an &instance parameter:
destination.package=&Destination package:
choose.destination.package=Choose Destination Package
interface.name.prompt=&Interface name:
package.for.new.interface=&Package for new interface:
turnRefsToSuper.change.usages.to=&Change usages of {0} to:
turnRefsToSuper.use.superclass.in.instanceof=&Use interface/superclass in instanceof
class.name.prompt=Class &name:
parameter.name.prompt=Pa&rameter name:
no.class.name.specified=No class name specified
no.parameter.name.specified=No parameter name specified
pass.outer.class.instance.as.parameter=Pass &outer class' instance as a parameter
pull.up.members.to=&Pull up members of {0} to:
members.to.be.pulled.up=Members to be pulled up
make.abstract=Make abstract
javadoc.for.abstracts=JavaDoc for abstracts
extractIncludeFile.name=Extract Include File
name.for.extracted.include.file=&Name for extracted include file (without extension):
extract.to.directory=Extract to &directory:
select.target.directory.title=Select target directory
select.target.directory.description=The file will be created in this directory
create.directory=Create directory
replace.inheritance.from=&Replace with delegation inheritance from:
field.name=&Field name:
inner.class.name=&Inner class name:
superclass.name=&Super class name:
superinterface.name=&Super interface name:
delegate.members=Delegate members
generate.getter.for.delegated.component=Generate &getter for delegated component
package.for.new.superclass=&Package for new superclass:
ExtractSuperClass.superclass=Superclass
members.to.form.superclass=Members to Form Superclass
no.superclass.name.specified=No superclass name specified
extract.superclass.from=Extract superclass from:
extractSuper.extract=E&xtract {0}
extractSuper.rename.original.class=R&ename original class and use {0} where possible
extractSuper.rename.original.class.to=&Rename original class to:
extractSuperInterface.interface=Interface
members.to.form.interface=Members to Form Interface
extract.interface.from=Extract interface from:
rename.implementation.class.to=Rename implementation class to:
package.for.implementation.class=Package for implementation class:
extractSuperInterface.javadoc=JavaDoc
no.interface.name.specified=No interface name specified
replace.all.occurences=Replace &all occurences ({0} occurences)
declare.final=Declare &final
introduce.parameter.title=Introduce Parameter
parameter.of.type=Parameter of &type:
delete.variable.definition=&Delete variable definition
use.variable.initializer.to.initialize.parameter=Use variable &initializer to initialize parameter
replace.fields.used.in.expressions.with.their.getters=Replace fields used in expressions with their getters
do.not.replace=Do &not replace
replace.fields.inaccessible.in.usage.context=Replace fields &inaccessible in usage context
replace.all.fields=&Replace all fields
class.does.not.exist.in.the.project=Class does not exist in the project
no.field.name.specified=No field name specified
field.exists=The field with the name {0}\nalready exists in class ''{1}''.\nContinue?
choose.destination.class=Choose Destination Class
replace.write.access.occurrences=Rep&lace write access occurrences
introduce.variable.title=Introduce Variable
variable.of.type=Variable of &type:
convert.to.instance.method.title=Convert To Instance Method
convertToInstanceMethod.method.is.not.static=Cannot perform the refactoring\nMethod {0} is not static.
convertToInstanceMethod.no.parameters.with.reference.type=There are no parameters that have a reference type
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=All reference type parametres have unknown types
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=All reference type parameters have types that are not in project
cannot.perform.refactoring=Cannot perform refactoring.
move.instance.method.title=Move Instance Method
move.method.is.not.supported.for.constructors=Move method is not supported for constructors
move.method.is.not.supported.for.generic.classes=Move method is not supported for generic classes
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=Move method is not supported when method is a part of inheritance hierarchy
synthetic.jsp.class.is.referenced.in.the.method=Synthetic jsp class is referenced in the method
there.are.no.variables.that.have.reference.type=There are no variables that have a reference type
all.candidate.variables.have.unknown.types=All candidate variables have unknown types
all.candidate.variables.have.types.not.in.project=All candidate variables have types that are not in project
use.interface.where.possible.title=Use Interface Where Possible
interface.does.not.have.base.interfaces=Interface {0} does not have base interfaces.
the.field.should.be.declared.in.a.class=The field should be declared in a class.
encapsulate.fields.title=Encapsulate Fields
fields.to.be.refactored.should.belong.to.the.same.class=Fields to be refactored should belong to the same class.
encapsulate.fields.refactoring.cannot.be.applied.to.interface=Encapsulate fields refactoring cannot be applied to interface
extract.interface.title=Extract Interface
extract.interface.command.name=Extracting interface {0} from {1}
extract.method.title=Extract Method
selected.block.contains.invocation.of.another.class.constructor=Selected block contains invocation of another class constructor.
selected.block.should.represent.a.set.of.statements.or.an.expression=Selected block should represent a set of statements or an expression.
press.escape.to.remove.the.highlighting=Press Escape to remove the highlighting
extract.superclass.title=Extract Superclass
extract.superclass.command.name=Extracting superclass {0} from {1}
superclass.cannot.be.extracted.from.an.interface=Superclass cannot be extracted from an interface.
superclass.cannot.be.extracted.from.an.enum=Superclass cannot be extracted from an enum.
replace.inheritance.with.delegation.title=Replace Inheritance With Delegation
class.is.interface={0} is an interface.
class.does.not.have.base.classes.or.interfaces=Class {0} does not have base classes or interfaces.
inline.title=Inline
introduce.constant.title=Introduce Constant
selected.expression.cannot.be.a.constant.initializer=Selected expression cannot be a constant initializer.
variable.does.not.have.an.initializer=Variable {0} does not have an initializer.
initializer.for.variable.cannot.be.a.constant.initializer=Initializer for variable {0} cannot be a constant initializer.
cannot.introduce.field.in.interface=Cannot introduce field in interface
introduce.field.title=Introduce Field
selected.block.should.represent.an.expression=Selected block should represent an expression.
is.not.supported.in.the.current.context={0} is not supported in the current context.
type.of.the.selected.expression.cannot.be.determined=Type of the selected expression cannot be determined.
selected.expression.has.void.type=Selected expression has void type.
to.rename=to rename
to.delete.with.usage.search=to delete (with usage search)