readonly.occurences.found=Occurrences found in read-only files
progress.text=Looking For Usages...
usageView.tabText=Refactoring preview
usageView.usagesText=usages
usageView.need.reRun=Cannot perform the refactoring operation.\nThere were changes in code after the usages have been found.\nPlease, perform the usage search again.
usageView.doAction=&Do Refactor
statusBar.refactoring.result={0, choice, 1#1 occurence|2#{0,number} occurences} changed
statusBar.noUsages=No occurrences found
anonymousToInner.refactoring.name=Convert Anonymous to Inner
anonymousToInner.no.inner.class.name=Class name should be specified
inner.class.exists=Inner class named ''{0}'' is already defined\nin the class ''{1}''
anonymousToInner.class.name.label.text=Class name:
anonymousToInner.make.class.static.checkbox.text=Make class &static
anonymousToInner.parameters.panel.border.title=Constructor Parameters
error.wrong.caret.position.method=The caret should be positioned inside the method to be refactored.
error.wrong.caret.position.constructor=The caret should be positioned inside the constructor to be refactored.
error.wrong.caret.position.method.or.class.name=The caret should be positioned at the name of the method or class to be refactored.
error.wrong.caret.position.anonymous=The caret should be positioned inside the anonymous class to be refactored.
error.wrong.caret.position.class=The caret should be positioned inside the class to be refactored.
error.wrong.caret.position.method.or.local.name=The caret should be positioned at the name of\nthe method or local variable to be refactored..
error.wrong.caret.position.local.name=The caret should be positioned at the name of the local variable to be refactored.
error.wrong.caret.position.symbol=The caret should be positioned at the symbol to be renamed.
to.refactor=to refactor
error.cannot.resolve=Cannot resolve {0}
error.incorrect.data=Incorrect Data
error.wrong.name.input=Wrong name: {0}
error.not.supported.for.jsp={0} refactoring is not supported for JSP
changeClassSignature.refactoring.name=Change Class Signature
changeClassSignature.parameters.panel.border.title=Parameters
changeClassSignature.bad.default.value=Wrong default value: ''{0}'' for parameter {1}
changeClassSignature.class.label.text=Change signature of {0}
changeSignature.no.type.for.parameter=Specify a type for parameter ''{0}''
changeSignature.no.type.for.exception=Specify a type for exception
changeSignature.refactoring.name=Change Signature
column.name.name=Name
changeSignature.default.value.column=Default Value
parameters.border.title=Parameters
changeSignature.exceptions.panel.border.title=Exceptions
changeSignature.propagate.parameters.title=Propagate Parameters
changeSignature.propagate.exceptions.title=Propagate Exceptions
changeSignature.parameter.caller.chooser=Select Methods To Propagate New Parameters
changeSignature.exception.caller.chooser=Select Methods To Propagate New Exceptions
name.prompt=&Name:
changeSignature.return.type.prompt=Return &type:
signature.preview.border.title=Signature Preview
changeSignature.parameters.wont.propagate=Recursive propagation of parameter changes won''t be performed
changeSignature.exceptions.wont.propagate=Recursive propagation of exception changes won''t be performed
changeSignature.wrong.return.type=Wrong return type: ''{0}''
changeSignature.no.return.type=Specify return type
changeSignature.wrong.type.for.parameter=Wrong type: ''{0}'' for parameter {1}
changeSignature.wrong.type.for.exception=Wrong type: ''{0}'' for exception
changeSignature.vararg.not.last=Vararg parameter should be the last in method signature
changeSignature.no.default.value=New parameter {0} has been added.\nSpecify a default value to be used in all existing calls of this method.
changeSignature.not.throwable.type=Wrong type: ''{0}'' for exception, should extend java.lang.Throwable
changeSignature.cannot.resolve.type=Type ''{0}'' cannot be resolved.\nContinue?
search.in.comments.and.strings=Search in comments and &strings
search.for.text.occurences=Search for &text occurences
visibility.as.is=&As is
visibility.public=Pu&blic
visibility.protected=Pr&otected
visibility.private=Pri&vate
visibility.package.local=Pac&kage local
visibility.border.title=Visibility
row.add=&Add
row.remove=R&emove
row.move.up=Move &Up
row.move.down=Move &Down
moveInstanceMethod.select.an.instance.parameter=Select an &instance parameter:
destination.package=&Destination package:
choose.destination.package=Choose Destination Package
interface.name.prompt=&Interface name:
package.for.new.interface=&Package for new interface:
turnRefsToSuper.change.usages.to=&Change usages of {0} to:
turnRefsToSuper.use.superclass.in.instanceof=&Use interface/superclass in instanceof
class.name.prompt=Class &name:
parameter.name.prompt=Pa&rameter name:
no.class.name.specified=No class name specified
no.parameter.name.specified=No parameter name specified
pass.outer.class.instance.as.parameter=Pass &outer class' instance as a parameter
pull.up.members.to=&Pull up members of {0} to:
members.to.be.pulled.up=Members to be pulled up
make.abstract=Make abstract
javadoc.for.abstracts=JavaDoc for abstracts
extractIncludeFile.name=Extract Include File
name.for.extracted.include.file=&Name for extracted include file (without extension):
extract.to.directory=Extract to &directory:
select.target.directory=Select target directory
select.target.directory.description=The file will be created in this directory
create.directory=Create directory
replace.inheritance.from=&Replace with delegation inheritance from:
field.name=&Field name:
inner.class.name=&Inner class name:
superclass.name=&Super class name:
superinterface.name=&Super interface name:
delegate.members=Delegate members
generate.getter.for.delegated.component=Generate &getter for delegated component
package.for.new.superclass=&Package for new superclass:
ExtractSuperClass.superclass=Superclass
members.to.form.superclass=Members to Form Superclass
no.superclass.name.specified=No superclass name specified
extract.superclass.from=Extract superclass from:
extractSuper.extract=E&xtract {0}
extractSuper.rename.original.class=R&ename original class and use {0} where possible
extractSuper.rename.original.class.to=&Rename original class to:
extractSuperInterface.interface=Interface
members.to.form.interface=Members to Form Interface
extract.interface.from=Extract interface from:
rename.implementation.class.to=Rename implementation class to:
package.for.implementation.class=Package for implementation class:
extractSuperInterface.javadoc=JavaDoc
no.interface.name.specified=No interface name specified
replace.all.occurences=Replace &all occurences ({0} occurences)
declare.final=Declare &final
introduce.parameter.title=Introduce Parameter
parameter.of.type=Parameter of &type:
delete.variable.definition=&Delete variable definition
use.variable.initializer.to.initialize.parameter=Use variable &initializer to initialize parameter
replace.fields.used.in.expressions.with.their.getters=Replace fields used in expressions with their getters
do.not.replace=Do &not replace
replace.fields.inaccessible.in.usage.context=Replace fields &inaccessible in usage context
replace.all.fields=&Replace all fields
class.does.not.exist.in.the.project=Class does not exist in the project
no.field.name.specified=No field name specified
field.exists=The field with the name {0}\nalready exists in class ''{1}''.\nContinue?
choose.destination.class=Choose Destination Class
replace.write.access.occurrences=Rep&lace write access occurrences
introduce.variable.title=Introduce Variable
variable.of.type=Variable of &type:
convert.to.instance.method.title=Convert To Instance Method
convertToInstanceMethod.method.is.not.static=Cannot perform the refactoring\nMethod {0} is not static.
convertToInstanceMethod.no.parameters.with.reference.type=There are no parameters that have a reference type
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=All reference type parametres have unknown types
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=All reference type parameters have types that are not in project
cannot.perform.refactoring=Cannot perform refactoring.
move.instance.method.title=Move Instance Method
move.method.is.not.supported.for.constructors=Move method is not supported for constructors
move.method.is.not.supported.for.generic.classes=Move method is not supported for generic classes
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=Move method is not supported when method is a part of inheritance hierarchy
synthetic.jsp.class.is.referenced.in.the.method=Synthetic jsp class is referenced in the method
there.are.no.variables.that.have.reference.type=There are no variables that have a reference type
all.candidate.variables.have.unknown.types=All candidate variables have unknown types
all.candidate.variables.have.types.not.in.project=All candidate variables have types that are not in project
use.interface.where.possible.title=Use Interface Where Possible
interface.does.not.have.base.interfaces=Interface {0} does not have base interfaces.
the.field.should.be.declared.in.a.class=The field should be declared in a class.
encapsulate.fields.title=Encapsulate Fields
fields.to.be.refactored.should.belong.to.the.same.class=Fields to be refactored should belong to the same class.
encapsulate.fields.refactoring.cannot.be.applied.to.interface=Encapsulate fields refactoring cannot be applied to interface
extract.interface.title=Extract Interface
extract.interface.command.name=Extracting interface {0} from {1}
extract.method.title=Extract Method
selected.block.contains.invocation.of.another.class.constructor=Selected block contains invocation of another class constructor.
selected.block.should.represent.a.set.of.statements.or.an.expression=Selected block should represent a set of statements or an expression.
press.escape.to.remove.the.highlighting=Press Escape to remove the highlighting
extract.superclass.title=Extract Superclass
extract.superclass.command.name=Extracting superclass {0} from {1}
superclass.cannot.be.extracted.from.an.interface=Superclass cannot be extracted from an interface.
superclass.cannot.be.extracted.from.an.enum=Superclass cannot be extracted from an enum.
replace.inheritance.with.delegation.title=Replace Inheritance With Delegation
class.is.interface={0} is an interface.
class.does.not.have.base.classes.or.interfaces=Class {0} does not have base classes or interfaces.
inline.title=Inline
introduce.constant.title=Introduce Constant
selected.expression.cannot.be.a.constant.initializer=Selected expression cannot be a constant initializer.
variable.does.not.have.an.initializer=Variable {0} does not have an initializer.
initializer.for.variable.cannot.be.a.constant.initializer=Initializer for variable {0} cannot be a constant initializer.
cannot.introduce.field.in.interface=Cannot introduce field in interface
introduce.field.title=Introduce Field
selected.block.should.represent.an.expression=Selected block should represent an expression.
is.not.supported.in.the.current.context={0} is not supported in current context.
type.of.the.selected.expression.cannot.be.determined=Type of the selected expression cannot be determined.
selected.expression.has.void.type=Selected expression has void type.
to.rename=to rename
to.delete.with.usage.search=to delete (with usage search)
unknown.expression.type=Unknown expression type.
invalid.expression.context=Invalid expression context.
refactoring.is.not.supported.in.the.current.context={0} refactoring is not supported in the current context
cannot.introduce.variable.in.super.constructor.call=Cannot introduce variable in super constructor call
is.modified.in.loop.body={0} is modified in loop body.\n
introducing.variable.may.break.code.logic=Introducing variable may break code logic.
no.selection=No selection.
selection.does.not.form.a.fragment.for.extraction=Selection does not form a fragment for extraction.
cannot.extract.selected.elements.into.include.file=Cannot extract selected elements into include file.
the.language.for.selected.elements.has.no.associated.file.type=The language for selected elements has no associated file type
extract.include.file.title=Extract include file
replace.fragment=Replace Fragment
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0} has found fragments that can be replaced with include directive\nDo you want to review them?
remove.duplicates.command=Remove Duplicates
make.method.static.title=Make Method Static
constructor.cannot.be.made.static=Constructor cannot be made static.
this.member.does.not.seem.to.belong.to.any.class=This member does not seem to belong to any class.
member.is.already.static=Member is already static.
cannot.make.abstract.method.static=Cannot make abstract method static.
inner.classes.cannot.have.static.members=Inner classes cannot have static members.
pull.members.up.title=Pull Members Up
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=The caret should be positioned inside a class to pull members from.
class.does.not.have.base.classes.interfaces.in.current.project={0} does not have base classes/interfaces in current project.
pullUp.command=Pulling members up from {0}
push.members.down.title=Push Members Down
the.caret.should.be.positioned.inside.a.class.to.push.members.from=The caret should be positioned inside a class to push members from
move.tilte=Move
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=The caret should be positioned at the class, method or field to be refactored.
select.refactoring.title=Select Refactoring
what.would.you.like.to.do=What would you like to do?
move.packages.to.another.package=Move {0} &packages to another package
move.package.to.another.package=Move &package ''{0}'' to another package
move.directories.to.another.source.root=Move {0} directories to another source &root
move.directory.to.another.source.root=Move directory {0} to another source &root
move.inner.class.to.upper.level=Move &inner class {0} to upper level
move.inner.class.to.another.class=&Move inner class {0} to another class
package.occurs.in.package.prefixes.of.the.following.source.folders.n=Package {0} occurs in package prefixes of the following source folders:\n
these.package.prefixes.will.be.changed=These package prefixes will be changed.
rename.title=Rename
multiple.directories.correspond.to.package=Multiple directories correspond to package\n
directories.and.all.references.to.package.will.be.renamed=\n\nAll these directories and all references to package \n{0}\nwill be renamed.\nDo you wish to continue?
warning.tilte=Warning
constructor.cannot.be.renamed.would.you.like.to.rename.class=Constructor cannot be renamed.\nWould you like to rename {0} {1}?
replace.constructor.with.factory.method.title=Replace Constructor With Factory Method
class.does.not.have.implicit.default.consructor=Class {0} does not have implicit default consructor.
would.you.like.to.replace.default.constructor.of.0.with.factory.method=Would you like to replace default constructor of {0} with factory method?
refactoring.is.not.supported.for.local.and.jsp.classes=Refactoring is not supported for local and JSP classes.
class.is.abstract={0} is abstract.
method.is.not.a.constructor=Method is not a constructor.
safe.delete.title=Safe Delete
replace.temp.with.query.title=Replace Temp with Query
cannot.replace.temp.with.query.in.interface=Cannot replace temp with query in interface.
variable.has.no.initializer=Variable {0} has no initializer.
variable.is.never.used=Variable {0} is never used
variable.is.accessed.for.writing=Variable {0} is accessed for writing.
only.fields.variables.of.methods.of.valid.type.can.be.added=Only fields, variables of methods of valid type can be added.
unable.to.add.migration.root=Unable to add migration root
only.fields.variables.of.methods.of.valid.type.can.be.considered=Only fields, variables of methods of valid type can be considered.
unable.to.start.type.migration=Unable to start type migration
replace.method.code.duplicates.title=Replace Method Code Duplicates
locate.caret.inside.a.method=Locate caret inside a method.
replace.with.method.call.does.not.work.for.constructors=Replace With Method Call does not work for constructors
method.does.not.have.a.body=Method {0} does not have a body.
method.has.an.empty.body=Method {0} has an empty body.
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} has not found any code that can be replaced with method call
method.duplicates.found.message={0, choice, 1#1 code fragment|2#{0,number} code fragments} found
0.with.1.visibility.is.not.accesible.from.2={0} with {1} visibility is not accesible from {2}
0.contains.call.with.null.argument.for.parameter.1={0} contains call with null argument for parameter {1}
no.members.selected=No members selected
0.already.exists.in.the.target.class={0} already exists in the target class.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} is {1} and will not be accessible from {2} in the target class.
renamed.class.will.hide.0.in.1=Renamed class will hide {0} in {1}
there.is.already.a.0.it.will.conflict.with.the.renamed.1=There is already a {0}. It will conflict with the renamed {1}
0.already.exists={0} already exists.
0.will.override.renamed.1={0} will override renamed {1}
0.will.hide.renamed.1={0} will hide renamed {1}
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter=There is already a {0} in the {1}. It will conflict with the renamed parameter.
do.you.want.to.process.overriding.methods.with.covariant.return.type=Do you want to process overriding methods\nwith covariant return type?
changing.signature.of.0=Changing signature of {0}
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter=There is already a {0} in {1}. It will conflict with the new parameter.
0.to.change.signature={0} to change signature
references.to.be.changed=References to be changed {0}
source.folder.0.has.package.prefix.1=Source folder {0} has package prefix ''{1}''\nPackage ''{2}'' cannot be created there.
javadoc.as.is=&As is
javadoc.copy=&Copy
javadoc.move=&Move
replace.instance.qualifiers.with.class.references=Replace instance qualifiers with class references
make.0.static=Make {0} Static
0.already.has.parameter.named.1.use.this.name.anyway={0} already has parameter named ''{1}''.\nUse this name anyway?
this.method=This method
add.object.as.a.parameter.with.name=Add &object as a parameter with name:
add.object.as.a.parameter.to.constructors.with.name=Add &object as a parameter to constructors with name:
add.parameters.for.fields=Add parameters for &fields:
add.parameters.for.fields.to.constructors=Add parameters for &fields to constructors:
0.already.contains.field.1={0} already contains field {1}.
0.is.already.overridden.in.1={0} is already overridden in {1}. Method will not be pushed down to that class.
0.already.contains.inner.class.named.1={0} already contains inner class named {1}.
0.uses.1.which.is.pushed.down={0} uses {1}, which is pushed down
refactoring.cannot.be.performed=Refactoring cannot be performed
inline.pointcut.title=Inline Pointcut
pointcut.designator.0.does.not.have.an.associated.pointcutdef=Pointcut designator {0} does not have an associated pointcutDef.
pointcut.0.is.never.used=Pointcut {0} is never used
inline.pointcut.0=Inline pointcut {0}
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=There is already a {0}. It will conflict with an introduced parameter
introduce.parameter.command=Introducing parameter to {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=Parameter initializer contains {0}, but not all calls to method are in its class.
0.is.not.accesible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} is not accesible from {1}. Value for introduced parameter in that method call will be incorrect.
use.interface.superclass.in.instanceof=Use interface/superclass in instanceof
introduce.parameter.to.method=Introduce parameter to method:
introduced.variable.will.conflict.with.0=Introduced variable will conflict with {0}
column.name.type=Type
column.name.any.var=Any var
column.name.default.value=Default value
caller.chooser.caller.method=Caller Method
caller.chooser.callee.method=Callee Method
caller.chooser.looking.for.callers=Looking For Callers...
copy.class.clone.0.1=Clone {0} {1}
copy.class.copy.0.1=Copy {0} {1}
invalid.target.package.name.specified=Invalid target package name specified
error.title=Error
cannot.create.directory=Cannot create directory
no.target.directory.specified=No target directory specified
copy.files.new.name.label=New name:
no.new.name.specified=No new name specified
copy.files.copy.specified.files.label=Copy specified files
copy.files.copy.specified.directories.label=Copy specified directories
copy.files.to.directory.label=To directory:
the.file.will.be.copied.to.this.directory=The file will be copied to this directory
copy.files.clone.title=Clone
copy.files.copy.title=Copy
copy.files.clone.file.0=Clone file {0}
copy.files.copy.file.0=Copy file {0}
copy.files.clone.directory.0=Clone directory{0}
copy.files.copy.directory.0=Copy directory {0}
copy.handler.copy.class=Copy Class
copy.handler.clone.class=Clone Class
copy,handler.clone.files.directories=Clone files/directories
copy.handler.copy.files.directories=Copy files/directories
encapsulate.fields.get.access.checkbox=&Get access
encapsulate.fields.set.access.checkbox=&Set access
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=&Use accessors even when field is accessible
encapsulate.fields.private.radio=Pr&ivate
encapsulate.fields.protected.radio=Pro&tected
encapsulate.fields..package.local.radio=Package lo&cal
encapsulate.fields.encapsulate.border.title=Encapsulate
encapsulate.fields.options.border.title=Options
encapsulate.fields..encapsulated.fields.visibility.border.title=Encapsulated Fields' Visibility
encapsulate.fields.accessors.visibility.border.title=Accessors' Visibility
encapsulate.fields..fields.to.encapsulate.border.title=Fields to Encapsulate
encapsulate.fields.field.column.name=Field
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.no.fields.selected=No fields selected
encapsulate.fields.command.name=Encapsulating fields in {0}
encapsulate.fields.getter.exists=There already is a method {0} which differs from getter {1} by return type only.
encapsulate.fields.setter.exists=There already is a method {0} which differs from setter {1} by return type only.
encapsulate.fields.fields.to.be.encapsulated=Fields to be encapsulated
invocations.to.be.inlined=Invocations to be inlined {0}
classes.to.push.down.members.to=Classes to push down members to {0}
references.in.code.to.elements.from.migration.map=References in code to elements from migration map "{0}" {1}
press.the.do.migrate.button=Press the "Do Migrate" button at the bottom of the search results panel\nto migrate using the migration map "{0}"\n
declaration.s.to.be.generified=Declaration(s) to be generified {0}
occurences.to.be.migrated=Occurences to be migrated {0}
references.in.code=References in code {0}
safe.delete.comment.occurences.header=Occurrences found in comments, strings and non-java files {0}. Those occurrences will not be changed
move.single.element.elements.header={0} to be moved to {1}
references.in.code.to.0.1=References in code to {0} {1}
move.classes.elements.header=Classes to be moved to {0}
move.packages.elements.header=Packages to be moved to {0}
references.found.in.code=References found in code
comments.elements.header=Occurrences found in comments, strings and non-java files {0}
move.files.elements.header=Files to be moved to {0}
move.directories.elements.header=Directories to be moved to {0}
make.static.description.label=Make {0} {1} static
there.is.already.a.0.in.1=There is already a {0} in {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} uses non-static {1}, which is not passed as a parameter
0.uses.1.which.needs.class.instance={0} uses {1}, which needs class instance.
method.0.is.overridden.by.1=Method {0} is overridden by {1}.
make.static.command=Making {0} static
introduce.parameter.elements.header=Adding parameter to a method
annotate.field.as.nonnls.checkbox=Annotate field as @NonNls
delete.variable.declaration.checkbox=&Delete variable declaration
replace.all.occurences.checkbox=Replace &all occurences
introduce.constant.introduce.to.class=Introduce to class (fully qualified name):
introduce.field.static.field.of.type=Static field of &type:
introduce.field.field.of.type=Field of &type:
replace.all.occurrences.of.expression.0.occurrences=Replace &all occurrences of expression ({0} occurrences)
delete.variable.declaration=&Delete variable declaration
initialize.in.border.title=Initialize in
setup.method.radio=&setUp method
current.method.radio=Current method
field.declaration.radio=Field &declaration
class.constructors.radio=Class &constructor(s)
convert.local.to.field.title=Convert Local to Field
introduce.constant.field.of.type=Constant (static final field) of &type:
extract.subclass.command=Extract Subclass
extract.superclass.elements.header=Extract superclass with members to directory
declare.static.checkbox=Declare &static
extract.method.method.panel.border=Method
there.are.multiple.exit.points.in.the.selected.code.fragment=There are multiple exit points in the selected code fragment.
move.members.elements.header=Members to be moved
move.members.move.members.from.label=Move members from:
move.members.to.fully.qualified.name.label=To (fully qualified name):
move.members.members.to.be.moved.border.title=Members to be moved (static only)
no.destination.class.specified=No destination class specified
0.is.not.a.legal.fq.name=''{0}'' is not a legal FQ-name
create.class.command=Create class {0}
source.and.destination.classes.should.be.different=Source and destination classes should be different
cannot.move.inner.class.0.into.itself=Cannot move inner class {0} into itself.
class.0.does.not.exist=Class {0} does not exist.\nDo you want to create it?
move.members.title=Move Members
members.to.be.moved.should.belong.to.the.same.class=Members to be moved should belong to the same class.
field.0.is.not.static=Field {0} is not static.\n{1} refactoring is supported for static members only.
0.refactoring.cannot.be.applied.to.constructors={0} refactoring cannot be applied to constructors
method.0.is.not.static=Method {0} is not static.\n{1} refactoring is supported for static members only.
inner.class.0.is.not.static=Inner class {0} is not static.\n{1} refactoring is supported for static members only.
inline.field.title=Inline Field
0.refactoring.is.supported.only.for.final.fields={0} refactoring is supported only for final fields
no.initializer.present.for.the.field=No initializer present for the field
field.0.is.never.used=Field {0} is never used
inline.field.command=Inline field {0}
0.is.used.for.writing.in.1={0} is used for writing in {1}
0.will.not.be.accessible.from.1.after.inlining={0} will not be accessible from {1} after inlining
inline.field.field.name.label=Field {0}
inline.field.border.title=Inline
all.references.and.remove.the.field=&All references and remove the field
this.reference.only.and.keep.the.field=&This reference only and keep the field
inline.variable.title=Inline Variable
variable.is.referenced.in.multiple.files=Variable {0} is referenced in multiple files
variable.is.never.used.before.modification=Variable {0} is never used before modification
variable.initializer.does.not.dominate.its.usages=Variable initializer does not dominate its usages.
inline.local.command=Inline {0}
inline.local.variable.prompt=Inline local variable {0}?
occurences.string=({0,choice,1#1 occurence|2#{0,number} occurences})
inline.method.title=Inline Method
inline.method.method.label=Method {0}
inline.method.border.title=Inline
all.invocations.and.remove.the.method=&All invocations and remove the method
all.invocations.in.project=&All invocations in project
this.invocation.only.and.keep.the.method=&This invocation only and keep the method
refactoring.cannot.be.applied.to.abstract.methods={0} refactoring cannot be applied to abstract methods
refactoring.cannot.be.applied.no.sources.attached={0} refactoring cannot be applied: no sources attached
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow={0} refactoring is not supported when return statement interrupts the execution flow
refactoring.is.not.supported.for.recursive.methods={0} refactoring is not supported for recursive methods
refactoring.cannot.be.applied.to.vararg.constructors={0} refactoring cannot be applied to vararg constructors
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} refactoring cannot be applied to inline non-chaining constructors
inline.method.command=Inlining method {0}
inlined.method.implements.method.from.0=Inlined method implements method from {0}
inlined.method.overrides.method.from.0=Inlined method overrides method from {0}
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1={0} that is used in inlined method is not accessible from call site(s) in {1}
inline.pointcut.prompt=Inline pointcut {0}?
inline.method.elements.header=Method to inline
inline.field.elements.header=Field to inline
interface.has.been.successfully.created=Interface {0} has been successfully created.
class.has.been.successfully.created=Class {0} has been successfully created.
use.super.references.prompt=At this stage {0} can analyze usages of {1}\nand replace them with usages of {2} where possible.\nDo you want to proceed?
analyze.and.replace.usages=Analyze and Replace Usages
there.are.multiple.output.values.for.the.selected.code.fragment=There are multiple output values for the selected code fragment:
expression.result=expression result
instances.of.0.upcasted.to.1.were.found=Instances of {0} upcasted to {1} were found. If you continue, they will be shown in a separate Find tab.
0.uses.1.of.an.instance.of.a.2={0} uses {1} of an instance of a {2}.
0.upcasts.an.instance.of.1.to.2={0} upcasts an instance of {1} to {2}.
0.will.no.longer.override.1={0} will no longer override {1}
replacing.inheritance.with.delegation=Replacing inheritance with delegation
instances.casted.to.java.lang.object=Instances casted to java.lang.Object
instances.upcasted.to.object=Instances upcasted to Object
instances.upcasted.to.java.lang.object.found=Instances upcasted to java.lang.Object found
replace.inheritance.with.delegation.command=Replacing inheritance with delegation in {0}
replace.inheritance.with.delegation.elements.header=Replace inheritance with delegation