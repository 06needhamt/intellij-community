/* The following code was generated by JFlex 1.4 on 3/14/05 5:43 PM */

/* It's an automatically generated code. Do not modify it. */
 package com.intellij.lexer;

 import com.intellij.psi.tree.IElementType;
 import com.intellij.psi.*;
 import com.intellij.psi.xml.*;


 /**
* This class is a scanner generated by
* <a href="http://www.jflex.de/">JFlex</a> 1.4
* on 3/14/05 5:43 PM from the specification file
* <tt>_XmlLexer.flex</tt>
*/
 public class _XmlLexer implements Lexer, Cloneable {
 /** initial size of the lookahead buffer */
 private static final int ZZ_BUFFERSIZE = 16384;

 /** lexical states */
 public static final int PROCESSING_INSTRUCTION = 2;
 public static final int ATTR_LIST = 5;
 public static final int END_TAG = 3;
 public static final int ATTR_VALUE_DQ = 8;
 public static final int DTD_MARKUP = 7;
 public static final int CDATA = 11;
 public static final int ATTR = 6;
 public static final int TAG = 1;
 public static final int YYINITIAL = 0;
 public static final int ATTR_VALUE_START = 7;
 public static final int COMMENT = 4;
 public static final int DOCTYPE = 10;
 public static final int ATTR_VALUE_SQ = 9;

 /**
  * Translates characters to character classes
  */
 private static final String ZZ_CMAP_PACKED =
   "\11\0\2\3\1\0\2\3\22\0\1\3\1\12\1\54\1\37\1\4"+
   "\1\0\1\22\1\55\5\0\1\10\1\7\1\57\12\2\1\1\1\25"+
   "\1\11\1\60\1\21\1\56\1\0\1\16\1\51\1\14\1\15\1\45"+
   "\1\41\2\1\1\53\2\1\1\52\1\47\1\1\1\42\1\44\2\1"+
   "\1\46\1\17\1\50\3\1\1\43\1\1\1\13\1\0\1\20\1\0"+
   "\1\1\1\0\1\26\1\35\4\41\1\23\4\1\1\23\1\36\1\34"+
   "\1\30\1\27\1\32\1\1\1\31\1\24\1\33\2\1\1\40\2\1"+
   "\1\5\1\0\1\6\uff82\0";

 /**
  * Translates characters to character classes
  */
 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

 /**
  * Translates DFA states to action switch labels.
  */
 private static final int [] ZZ_ACTION = zzUnpackAction();

 private static final String ZZ_ACTION_PACKED_0 =
   "\1\1\3\0\1\2\3\0\2\3\2\0\1\1\1\4"+
   "\1\1\1\5\2\6\1\7\1\6\1\10\1\6\1\11"+
   "\1\6\1\12\1\2\1\0\1\13\3\14\1\15\1\16"+
   "\1\17\4\3\1\20\3\3\1\21\1\6\1\22\2\21"+
   "\2\6\4\1\1\0\1\23\1\24\7\0\1\25\1\26"+
   "\2\0\2\3\1\0\4\3\1\0\1\27\1\0\2\21"+
   "\1\0\1\3\3\0\1\1\1\30\3\0\1\31\10\0"+
   "\1\32\1\33\4\3\2\21\1\34\1\30\1\35\2\0"+
   "\1\36\2\0\1\35\1\3\1\35\1\3\2\21\2\0"+
   "\2\3\2\21\2\0\2\3\1\37\1\40\2\0\2\3"+
   "\2\0\2\3\1\41\1\42\2\41";

 private static int [] zzUnpackAction() {
   int [] result = new int[144];
   int offset = 0;
   offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackAction(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }


 /**
  * Translates a state to a row index in the transition table
  */
 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

 private static final String ZZ_ROWMAP_PACKED_0 =
   "\0\0\0\61\0\142\0\223\0\304\0\365\0\u0126\0\u0157"+
   "\0\u0188\0\u01b9\0\u01ea\0\u021b\0\u024c\0\u027d\0\u02ae\0\u02df"+
   "\0\u0310\0\u0341\0\u0372\0\u03a3\0\u0341\0\u03d4\0\u0405\0\u0436"+
   "\0\u0467\0\u0498\0\u04c9\0\u04fa\0\u0341\0\u03a3\0\u0310\0\u0341"+
   "\0\u0341\0\u0341\0\u052b\0\u055c\0\u058d\0\u0310\0\u0341\0\u05be"+
   "\0\u05ef\0\u0620\0\u0651\0\u0682\0\u0341\0\u06b3\0\u06e4\0\u0715"+
   "\0\u0746\0\u0341\0\u0777\0\u07a8\0\u07d9\0\u080a\0\u0341\0\u0341"+
   "\0\u083b\0\u086c\0\u089d\0\u08ce\0\u08ff\0\u0930\0\u0961\0\u0341"+
   "\0\u0341\0\u0992\0\u09c3\0\u09f4\0\u0a25\0\u0a56\0\u0a87\0\u0ab8"+
   "\0\u0ae9\0\u0b1a\0\u0682\0\u0341\0\u0b4b\0\u0b7c\0\u0bad\0\u0715"+
   "\0\u0341\0\u0746\0\u0bde\0\u0c0f\0\u0c40\0\u024c\0\u0c71\0\u0ca2"+
   "\0\u0cd3\0\u0341\0\u0d04\0\u0d35\0\u0d66\0\u0d97\0\u0dc8\0\u0df9"+
   "\0\u0e2a\0\u0e5b\0\u0341\0\u0341\0\u0e8c\0\u0ebd\0\u0eee\0\u0f1f"+
   "\0\u0f50\0\u0f81\0\u0341\0\u0341\0\u0341\0\u0fb2\0\u0fe3\0\u0341"+
   "\0\u1014\0\u1045\0\u052b\0\u1076\0\u05be\0\u10a7\0\u10d8\0\u1109"+
   "\0\u113a\0\u116b\0\u119c\0\u11cd\0\u11fe\0\u122f\0\u1260\0\u1291"+
   "\0\u12c2\0\u12f3\0\u0651\0\u0651\0\u1324\0\u1355\0\u1386\0\u13b7"+
   "\0\u13e8\0\u1419\0\u144a\0\u147b\0\u0341\0\u0341\0\u052b\0\u05be";

 private static int [] zzUnpackRowMap() {
   int [] result = new int[144];
   int offset = 0;
   offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
   int i = 0;  /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int high = packed.charAt(i++) << 16;
     result[j++] = high | packed.charAt(i++);
   }
   return j;
 }

 /**
  * The transition table of the DFA
  */
 private static final int [] ZZ_TRANS = zzUnpackTrans();

 private static final String ZZ_TRANS_PACKED_0 =
   "\3\15\1\16\1\17\4\15\1\20\10\15\1\21\36\15"+
   "\1\22\1\23\1\22\1\16\5\22\1\24\2\22\4\23"+
   "\1\22\1\25\1\21\2\23\1\22\11\23\1\22\14\23"+
   "\3\22\1\26\2\22\1\27\7\22\1\24\2\22\4\27"+
   "\2\22\1\21\2\27\1\22\11\27\1\22\14\27\2\22"+
   "\1\30\3\22\1\31\1\22\1\16\5\22\1\24\2\22"+
   "\4\31\1\22\1\25\1\21\2\31\1\22\11\31\1\22"+
   "\14\31\5\22\10\32\1\33\50\32\1\22\1\34\1\22"+
   "\1\16\5\22\1\24\2\22\4\34\2\22\1\21\2\34"+
   "\1\22\11\34\1\22\14\34\5\22\3\35\1\16\5\35"+
   "\1\36\10\35\1\37\31\35\1\40\1\41\2\35\1\42"+
   "\11\22\1\24\10\22\1\21\36\22\4\43\1\44\4\43"+
   "\1\45\10\43\1\46\31\43\1\47\4\43\4\50\1\51"+
   "\4\50\1\52\10\50\1\46\32\50\1\47\3\50\1\22"+
   "\1\53\1\22\1\16\5\22\1\24\1\22\1\54\4\53"+
   "\1\22\1\55\1\21\2\53\1\22\11\53\1\22\4\53"+
   "\1\56\1\53\1\57\5\53\1\60\1\61\3\22\20\62"+
   "\1\63\40\62\3\15\1\0\1\64\4\15\1\0\10\15"+
   "\1\0\36\15\3\0\1\16\55\0\4\15\1\64\1\65"+
   "\3\15\1\0\10\15\1\0\36\15\12\0\1\66\43\0"+
   "\1\67\1\70\2\0\1\71\12\0\4\71\3\0\1\72"+
   "\1\71\1\0\1\73\3\71\1\74\1\71\1\75\2\71"+
   "\1\76\14\71\67\0\2\23\4\0\2\23\3\0\4\23"+
   "\3\0\2\23\1\0\11\23\1\0\14\23\17\0\1\77"+
   "\67\0\1\100\40\0\2\27\4\0\2\27\3\0\4\27"+
   "\3\0\2\27\1\0\11\27\1\0\14\27\26\0\1\101"+
   "\40\0\2\31\4\0\2\31\3\0\4\31\3\0\2\31"+
   "\1\0\11\31\1\0\14\31\5\0\10\32\1\102\60\32"+
   "\1\103\50\32\1\0\2\34\4\0\2\34\3\0\4\34"+
   "\3\0\2\34\1\0\11\34\1\0\14\34\5\0\4\43"+
   "\1\0\15\43\1\0\31\43\1\0\4\43\4\104\1\105"+
   "\1\106\14\104\1\0\31\104\1\0\4\104\4\43\1\0"+
   "\5\43\1\107\7\43\1\0\31\43\1\0\4\43\4\50"+
   "\1\0\15\50\1\0\32\50\1\0\3\50\4\110\1\111"+
   "\1\106\14\110\1\0\32\110\1\0\3\110\4\50\1\0"+
   "\5\50\1\112\7\50\1\0\32\50\1\0\3\50\1\0"+
   "\2\53\4\0\2\53\3\0\4\53\3\0\2\53\1\0"+
   "\11\53\1\0\14\53\5\0\20\113\1\114\33\113\1\115"+
   "\4\113\1\0\2\53\4\0\2\53\3\0\4\53\3\0"+
   "\2\53\1\0\11\53\1\0\10\53\1\116\3\53\6\0"+
   "\2\53\4\0\2\53\3\0\4\53\3\0\2\53\1\0"+
   "\11\53\1\0\3\53\1\117\10\53\5\0\54\120\1\121"+
   "\4\120\55\122\1\121\3\122\20\0\1\123\40\0\4\15"+
   "\1\64\4\15\1\0\10\15\1\0\36\15\3\65\1\124"+
   "\1\125\1\65\1\126\2\65\1\124\10\65\1\124\36\65"+
   "\10\0\1\127\2\0\1\130\1\0\1\131\44\0\2\71"+
   "\4\0\2\71\3\0\4\71\3\0\2\71\1\132\11\71"+
   "\1\0\14\71\6\0\2\71\4\0\2\71\3\0\4\71"+
   "\3\0\1\71\1\133\1\132\11\71\1\0\14\71\6\0"+
   "\2\71\4\0\2\71\3\0\4\71\3\0\2\71\1\132"+
   "\1\71\1\134\6\71\1\135\1\0\14\71\6\0\2\71"+
   "\4\0\2\71\3\0\4\71\3\0\2\71\1\132\5\71"+
   "\1\136\3\71\1\0\14\71\6\0\2\71\4\0\2\71"+
   "\3\0\4\71\3\0\2\71\1\132\7\71\1\137\1\71"+
   "\1\0\14\71\7\0\1\140\35\0\1\141\30\0\1\127"+
   "\2\0\1\130\45\0\10\32\1\142\71\32\1\143\37\32"+
   "\4\0\1\105\54\0\4\104\1\105\1\0\14\104\1\0"+
   "\31\104\1\0\4\104\6\106\1\144\52\106\4\43\1\0"+
   "\3\43\1\145\2\43\1\146\6\43\1\0\31\43\1\0"+
   "\4\43\4\0\1\111\54\0\4\110\1\111\1\0\14\110"+
   "\1\0\32\110\1\0\3\110\4\50\1\0\3\50\1\147"+
   "\2\50\1\150\6\50\1\0\32\50\1\0\3\50\54\115"+
   "\1\113\4\115\1\0\2\53\4\0\2\53\3\0\4\53"+
   "\3\0\2\53\1\0\11\53\1\0\11\53\1\151\2\53"+
   "\6\0\2\53\4\0\2\53\3\0\4\53\3\0\2\53"+
   "\1\0\11\53\1\0\6\53\1\152\5\53\26\0\1\153"+
   "\37\0\6\124\1\154\52\124\4\65\1\125\1\65\1\126"+
   "\2\65\1\124\10\65\1\124\36\65\10\0\1\155\64\0"+
   "\1\156\106\0\1\157\17\0\2\71\4\0\2\71\3\0"+
   "\4\71\3\0\2\71\1\160\11\71\1\0\14\71\6\0"+
   "\2\71\4\0\2\71\3\0\4\71\3\0\2\71\1\132"+
   "\2\71\1\161\6\71\1\0\14\71\6\0\2\71\4\0"+
   "\2\71\3\0\4\71\3\0\2\71\1\132\1\71\1\133"+
   "\7\71\1\0\14\71\6\0\2\71\4\0\2\71\3\0"+
   "\4\71\3\0\2\71\1\132\2\71\1\72\6\71\1\0"+
   "\14\71\6\0\2\71\4\0\2\71\3\0\4\71\3\0"+
   "\2\71\1\132\3\71\1\135\5\71\1\0\14\71\7\0"+
   "\1\140\22\0\1\160\35\0\1\162\11\0\3\162\7\0"+
   "\1\162\6\0\1\162\3\0\1\162\3\0\1\162\3\0"+
   "\1\162\7\0\21\32\1\0\37\32\4\43\1\0\3\43"+
   "\1\163\11\43\1\0\31\43\1\0\10\43\1\0\7\43"+
   "\1\164\5\43\1\0\31\43\1\0\4\43\4\50\1\0"+
   "\3\50\1\165\11\50\1\0\32\50\1\0\7\50\1\0"+
   "\7\50\1\166\5\50\1\0\32\50\1\0\3\50\1\0"+
   "\2\53\4\0\2\53\3\0\4\53\3\0\2\53\1\0"+
   "\11\53\1\0\12\53\1\167\1\53\6\0\2\53\4\0"+
   "\2\53\3\0\3\53\1\170\3\0\2\53\1\0\11\53"+
   "\1\0\14\53\22\0\1\171\57\0\1\172\45\0\2\71"+
   "\4\0\2\71\3\0\4\71\3\0\2\71\1\132\3\71"+
   "\1\133\5\71\1\0\14\71\7\0\1\162\11\0\3\162"+
   "\6\0\1\160\1\162\6\0\1\162\3\0\1\162\3\0"+
   "\1\162\3\0\1\162\7\0\4\43\1\0\10\43\1\173"+
   "\4\43\1\0\31\43\1\0\4\43\4\50\1\0\10\50"+
   "\1\174\4\50\1\0\32\50\1\0\3\50\1\0\2\53"+
   "\4\0\2\53\3\0\4\53\3\0\2\53\1\0\11\53"+
   "\1\0\13\53\1\175\6\0\2\53\4\0\2\53\3\0"+
   "\4\53\3\0\2\53\1\0\11\53\1\0\5\53\1\176"+
   "\6\53\23\0\1\177\61\0\1\200\41\0\4\43\1\0"+
   "\11\43\1\201\3\43\1\0\31\43\1\0\4\43\4\50"+
   "\1\0\11\50\1\202\3\50\1\0\32\50\1\0\3\50"+
   "\1\0\2\53\4\0\2\53\3\0\1\203\3\53\3\0"+
   "\2\53\1\0\11\53\1\0\14\53\6\0\2\53\4\0"+
   "\2\53\3\0\4\53\3\0\2\53\1\0\11\53\1\0"+
   "\7\53\1\204\4\53\24\0\1\205\104\0\1\206\15\0"+
   "\4\43\1\0\12\43\1\207\2\43\1\0\31\43\1\0"+
   "\4\43\4\50\1\0\12\50\1\210\2\50\1\0\32\50"+
   "\1\0\3\50\16\0\1\211\106\0\1\212\14\0\4\43"+
   "\1\0\11\43\1\213\3\43\1\0\31\43\1\0\4\43"+
   "\4\50\1\0\11\50\1\214\3\50\1\0\32\50\1\0"+
   "\3\50\13\0\1\215\112\0\1\216\13\0\4\43\1\0"+
   "\6\43\1\217\6\43\1\0\31\43\1\0\4\43\4\50"+
   "\1\0\6\50\1\220\6\50\1\0\32\50\1\0\3\50";

 private static int [] zzUnpackTrans() {
   int [] result = new int[5292];
   int offset = 0;
   offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackTrans(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     value--;
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }


 /* error codes */
 private static final int ZZ_UNKNOWN_ERROR = 0;
 private static final int ZZ_NO_MATCH = 1;
 private static final int ZZ_PUSHBACK_2BIG = 2;
 private static final char[] EMPTY_BUFFER = new char[0];
 private static final int YYEOF = -1;

 /* error messages for the codes above */
 private static final String ZZ_ERROR_MSG[] = {
   "Unkown internal scanner error",
   "Error: could not match input",
   "Error: pushback value was too large"
 };

 /**
  * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
  */
 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

 private static final String ZZ_ATTRIBUTE_PACKED_0 =
   "\1\1\3\0\1\1\3\0\2\1\2\0\5\1\1\11"+
   "\2\1\1\11\5\1\1\0\1\1\1\11\2\1\3\11"+
   "\4\1\1\11\5\1\1\11\4\1\1\11\3\1\1\0"+
   "\2\11\7\0\2\11\2\0\2\1\1\0\4\1\1\0"+
   "\1\11\1\0\2\1\1\0\1\11\3\0\2\1\3\0"+
   "\1\11\10\0\2\11\6\1\3\11\2\0\1\11\2\0"+
   "\6\1\2\0\4\1\2\0\4\1\2\0\2\1\2\0"+
   "\2\1\2\11\2\1";

 private static int [] zzUnpackAttribute() {
   int [] result = new int[144];
   int offset = 0;
   offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }

 /** the current state of the DFA */
 private int zzState;

 /** the current lexical state */
 private int zzLexicalState = YYINITIAL;

 /** this buffer contains the current text to be matched and is
     the source of the yytext() string */
 private char zzBuffer[] = EMPTY_BUFFER;

 /** the textposition at the last accepting state */
 private int zzMarkedPos;

 /** the textposition at the last state to be included in yytext */
 private int zzPushbackPos;

 /** the current text position in the buffer */
 private int zzCurrentPos;

 /** startRead marks the beginning of the yytext() string in the buffer */
 private int zzStartRead;

 /** endRead marks the last character in the buffer, that has been read
     from input */
 private int zzEndRead;

 /**
  * zzAtBOL == true <=> the scanner is currently at the beginning of a line
  */
 private boolean zzAtBOL = true;

 /** zzAtEOF == true <=> the scanner is at the EOF */
 private boolean zzAtEOF;

 /** denotes if the user-EOF-code has already been executed */
 private boolean zzEOFDone;

 /* user code: */
 private IElementType elTokenType = XmlTokenType.XML_DATA_CHARACTERS;
 private IElementType elTokenType2 = XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;

 public void setElTypes(IElementType _elTokenType,IElementType _elTokenType2) {
   elTokenType = _elTokenType;
   elTokenType2 = _elTokenType2;
 }

 private IElementType myTokenType;
 private int myPrevState = YYINITIAL;
 private int myState = YYINITIAL;
 private final int myLastState;

 {
   // code assumes that
   // - PROCESSING_INSTRUCTION state is the last from previous states with number 2
   // - CDATA state is the last state and its number < 16
   myLastState = (CDATA + 1) + (PROCESSING_INSTRUCTION << 4);
   assert myLastState < 64;
 }

 public _XmlLexer(){
   this((java.io.Reader)null);
 }

 public final void start(char[] buffer){
   start(buffer, 0, buffer.length);
 }

 public final void start(char[] buffer, int startOffset, int endOffset){
   start(buffer, startOffset, endOffset, (short)YYINITIAL);
 }

 public final void start(char[] buffer, int startOffset, int endOffset, int initialState){
   zzBuffer = buffer;
   zzCurrentPos = zzMarkedPos = zzStartRead = startOffset;
   zzPushbackPos = 0;
   zzAtEOF  = false;
   zzEndRead = endOffset;
   myTokenType = null;
   yybegin(initialState & 15);
   myPrevState = (initialState >> 4) & 15;
   packState();
 }

 public final int getState(){
   return myState;
 }

 private void packState() {
   myState = ((myPrevState & 15) << 4) | (zzLexicalState & 15);
 }

 public final int getLastState() {
   return myLastState;
 }

 public final IElementType getTokenType(){
   locateToken();
   return myTokenType;
 }

 public final int getTokenStart(){
   locateToken();
   return zzStartRead - zzPushbackPos;
 }

 public final int getTokenEnd(){
   return getTokenStart() + yylength();
 }

 public final void advance(){
   locateToken();
   myTokenType = null;
   packState();
 }

 public final char[] getBuffer(){
   return zzBuffer;
 }

 public final int getBufferEnd(){
   return zzEndRead;
 }

 protected final void locateToken(){
   if (myTokenType != null) return;
   try{
   _locateToken();
   }
   catch(java.io.IOException ioe){}
 }

 public int getSmartUpdateShift() {
   return 10;
 }

 private int popState(){
   final int prev = myPrevState;
   myPrevState = YYINITIAL;
   return prev;
 }

 private void pushState(int state){
   myPrevState = state;
 }

 public Object clone() {
   try{
     return super.clone();
   }
   catch(CloneNotSupportedException e){
     return null;
   }
 }


 /**
  * Creates a new scanner
  * There is also a java.io.InputStream version of this constructor.
  *
  * @param   in  the java.io.Reader to read input from.
  */
 public _XmlLexer(java.io.Reader in) {
     myTokenType = null;
 }

 /**
  * Creates a new scanner.
  * There is also java.io.Reader version of this constructor.
  *
  * @param   in  the java.io.Inputstream to read input from.
  */
 public _XmlLexer(java.io.InputStream in) {
   this(new java.io.InputStreamReader(in));
 }

 /**
  * Unpacks the compressed character translation table.
  *
  * @param packed   the packed character translation table
  * @return         the unpacked character translation table
  */
 private static char [] zzUnpackCMap(String packed) {
   char [] map = new char[0x10000];
   int i = 0;  /* index in packed string  */
   int j = 0;  /* index in unpacked array */
   while (i < 148) {
     int  count = packed.charAt(i++);
     char value = packed.charAt(i++);
     do map[j++] = value; while (--count > 0);
   }
   return map;
 }


 /**
  * Refills the input buffer.
  *
  * @return      <code>false</code>, iff there was new input.
  *
  * @exception   java.io.IOException  if any I/O-Error occurs
  */
 private boolean zzRefill() throws java.io.IOException {
   return true;
 }


 /**
  * Closes the input stream.
  */
 public final void yyclose() throws java.io.IOException {
   zzAtEOF = true;            /* indicate end of file */
   zzEndRead = zzStartRead;  /* invalidate buffer    */
 }


 /**
  * Resets the scanner to read from a new input stream.
  * Does not close the old reader.
  *
  * All internal variables are reset, the old input stream
  * <b>cannot</b> be reused (internal buffer is discarded and lost).
  * Lexical state is set to <tt>ZZ_INITIAL</tt>.
  *
  * @param reader   the new input stream
  */
 public final void yyreset(java.io.Reader reader) {
   zzAtBOL  = true;
   zzAtEOF  = false;
   zzEndRead = zzStartRead = 0;
   zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
   zzLexicalState = YYINITIAL;
 }


 /**
  * Returns the current lexical state.
  */
 public final int yystate() {
   return zzLexicalState;
 }


 /**
  * Enters a new lexical state
  *
  * @param newState the new lexical state
  */
 public final void yybegin(int newState) {
   zzLexicalState = newState;
 }


 /**
  * Returns the text matched by the current regular expression.
  */
 public final String yytext() {
   return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
 }


 /**
  * Returns the character at position <tt>pos</tt> from the
  * matched text.
  *
  * It is equivalent to yytext().charAt(pos), but faster
  *
  * @param pos the position of the character to fetch.
  *            A value from 0 to yylength()-1.
  *
  * @return the character at position pos
  */
 public final char yycharat(int pos) {
   return zzBuffer[zzStartRead+pos];
 }


 /**
  * Returns the length of the matched text region.
  */
 public final int yylength() {
   return zzMarkedPos-zzStartRead;
 }


 /**
  * Reports an error that occured while scanning.
  *
  * In a wellformed scanner (no or only correct usage of
  * yypushback(int) and a match-all fallback rule) this method
  * will only be called with things that "Can't Possibly Happen".
  * If this method is called, something is seriously wrong
  * (e.g. a JFlex bug producing a faulty scanner etc.).
  *
  * Usual syntax/scanner level error handling should be done
  * in error fallback rules.
  *
  * @param   errorCode  the code of the errormessage to display
  */
 private void zzScanError(int errorCode) {
   String message;
   try {
     message = ZZ_ERROR_MSG[errorCode];
   }
   catch (ArrayIndexOutOfBoundsException e) {
     message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
   }

   throw new Error(message);
 }


 /**
  * Pushes the specified amount of characters back into the input stream.
  *
  * They will be read again by then next call of the scanning method
  *
  * @param number  the number of characters to be read again.
  *                This number must not be greater than yylength()!
  */
 public void yypushback(int number)  {
   if ( number > yylength() )
     zzScanError(ZZ_PUSHBACK_2BIG);

   zzMarkedPos -= number;
 }


 /**
  * Contains user EOF-code, which will be executed exactly once,
  * when the end of file is reached
  */
 private void zzDoEOF() {
   if (!zzEOFDone) {
     zzEOFDone = true;

   }
 }


 /**
  * Resumes scanning until the next regular expression is matched,
  * the end of input is encountered or an I/O-Error occurs.
  *
  * @return      the next token
  * @exception   java.io.IOException  if any I/O-Error occurs
  */
 public void _locateToken() throws java.io.IOException {
   int zzInput;
   int zzAction;

   // cached fields:
   int zzCurrentPosL;
   int zzMarkedPosL;
   int zzEndReadL = zzEndRead;
   char [] zzBufferL = zzBuffer;
   char [] zzCMapL = ZZ_CMAP;

   int [] zzTransL = ZZ_TRANS;
   int [] zzRowMapL = ZZ_ROWMAP;
   int [] zzAttrL = ZZ_ATTRIBUTE;

   while (true) {
     zzMarkedPosL = zzMarkedPos;

     zzAction = -1;

     zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

     zzState = zzLexicalState;


     zzForAction: {
       while (true) {

         if (zzCurrentPosL < zzEndReadL)
           zzInput = zzBufferL[zzCurrentPosL++];
         else if (zzAtEOF) {
           zzInput = YYEOF;
           break zzForAction;
         }
         else {
           // store back cached positions
           zzCurrentPos  = zzCurrentPosL;
           zzMarkedPos   = zzMarkedPosL;
           boolean eof = zzRefill();
           // get translated positions and possibly new buffer
           zzCurrentPosL  = zzCurrentPos;
           zzMarkedPosL   = zzMarkedPos;
           zzBufferL      = zzBuffer;
           zzEndReadL     = zzEndRead;
           if (eof) {
             zzInput = YYEOF;
             break zzForAction;
           }
           else {
             zzInput = zzBufferL[zzCurrentPosL++];
           }
         }
         int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
         if (zzNext == -1) break zzForAction;
         zzState = zzNext;

         int zzAttributes = zzAttrL[zzState];
         if ( (zzAttributes & 1) == 1 ) {
           zzAction = zzState;
           zzMarkedPosL = zzCurrentPosL;
           if ( (zzAttributes & 8) == 8 ) break zzForAction;
         }

       }
     }

     // store back cached position
     zzMarkedPos = zzMarkedPosL;

     switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
       case 32:
         { myTokenType = XmlTokenType.XML_DOCTYPE_SYSTEM;  return;
         }
       case 35: break;
       case 25:
         { myTokenType = XmlTokenType.XML_ENTITY_REF_TOKEN; return;
         }
       case 36: break;
       case 21:
         { myTokenType = XmlTokenType.XML_EMPTY_ELEMENT_END; yybegin(YYINITIAL); return;
         }
       case 37: break;
       case 29:
         { myTokenType = XmlTokenType.XML_COMMENT_START; yybegin(COMMENT); return;
         }
       case 38: break;
       case 11:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR); return;
         }
       case 39: break;
       case 30:
         { myTokenType = XmlTokenType.XML_CHAR_ENTITY_REF; return;
         }
       case 40: break;
       case 28:
         { myTokenType = XmlTokenType.XML_CDATA_END; yybegin(YYINITIAL); return;
         }
       case 41: break;
       case 2:
         { myTokenType = XmlTokenType.XML_COMMENT_CHARACTERS; return;
         }
       case 42: break;
       case 31:
         { myTokenType = XmlTokenType.XML_DOCTYPE_PUBLIC;  return;
         }
       case 43: break;
       case 14:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER; yybegin(ATTR_VALUE_SQ); return;
         }
       case 44: break;
       case 13:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER; yybegin(ATTR_VALUE_DQ); return;
         }
       case 45: break;
       case 6:
         { if(yystate() == YYINITIAL){
       myTokenType = XmlTokenType.XML_BAD_CHARACTER;
       return;
     }
     else yybegin(popState()); yypushback(yylength());
         }
       case 46: break;
       case 34:
         { myTokenType = XmlTokenType.XML_DOCTYPE_START; yybegin(DOCTYPE); return;
         }
       case 47: break;
       case 9:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR_LIST); pushState(PROCESSING_INSTRUCTION); return;
         }
       case 48: break;
       case 8:
         { myTokenType = XmlTokenType.XML_TAG_END; yybegin(YYINITIAL); return;
         }
       case 49: break;
       case 15:
         { myTokenType = XmlTokenType.XML_EQ; return;
         }
       case 50: break;
       case 33:
         { myTokenType = XmlTokenType.XML_CDATA_START; yybegin(CDATA); return;
         }
       case 51: break;
       case 5:
         { myTokenType = XmlTokenType.XML_START_TAG_START; yybegin(TAG); return;
         }
       case 52: break;
       case 18:
         { myTokenType = XmlTokenType.XML_DOCTYPE_END;  yybegin(YYINITIAL); return;
         }
       case 53: break;
       case 7:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR_LIST); pushState(TAG); return;
         }
       case 54: break;
       case 26:
         { myTokenType = XmlTokenType.XML_COMMENT_END; yybegin(YYINITIAL); return;
         }
       case 55: break;
       case 10:
         { myTokenType = XmlTokenType.XML_NAME; return;
         }
       case 56: break;
       case 27:
         { myTokenType = elTokenType2;
 return;
         }
       case 57: break;
       case 19:
         { myTokenType = XmlTokenType.XML_PI_START; yybegin(PROCESSING_INSTRUCTION); return;
         }
       case 58: break;
       case 12:
         { yybegin(ATTR_LIST); yypushback(yylength());
         }
       case 59: break;
       case 3:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN; return;
         }
       case 60: break;
       case 4:
         { myTokenType = XmlTokenType.XML_WHITE_SPACE; return;
         }
       case 61: break;
       case 16:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER; yybegin(ATTR_LIST); return;
         }
       case 62: break;
       case 17:
         { myTokenType = XmlTokenType.XML_NAME;  return;
         }
       case 63: break;
       case 1:
         { myTokenType = XmlTokenType.XML_DATA_CHARACTERS; return;
         }
       case 64: break;
       case 23:
         { myTokenType = XmlElementType.XML_MARKUP; return;
         }
       case 65: break;
       case 22:
         { myTokenType = XmlTokenType.XML_PI_END; yybegin(YYINITIAL); return;
         }
       case 66: break;
       case 24:
         { myTokenType = elTokenType;
 return;
         }
       case 67: break;
       case 20:
         { myTokenType = XmlTokenType.XML_END_TAG_START; yybegin(END_TAG); return;
         }
       case 68: break;
       default:
         if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
           zzAtEOF = true;
           zzDoEOF();
           return;
         }
         else {
           zzScanError(ZZ_NO_MATCH);
         }
     }
   }
 }


 }
