/* The following code was generated by JFlex 1.4 on 3/1/05 6:01 PM */

/* It's an automatically generated code. Do not modify it. */
 package com.intellij.lexer;

 import com.intellij.psi.tree.IElementType;
 import com.intellij.psi.*;
 import com.intellij.psi.xml.*;


 /**
* This class is a scanner generated by
* <a href="http://www.jflex.de/">JFlex</a> 1.4
* on 3/1/05 6:01 PM from the specification file
* <tt>_XmlLexer.flex</tt>
*/
 public class _XmlLexer implements Lexer, Cloneable {
 /** initial size of the lookahead buffer */
 private static final int ZZ_BUFFERSIZE = 16384;

 /** lexical states */
 public static final int PROCESSING_INSTRUCTION = 2;
 public static final int ATTR_LIST = 5;
 public static final int END_TAG = 3;
 public static final int ATTR_VALUE_DQ = 8;
 public static final int DTD_MARKUP = 7;
 public static final int CDATA = 11;
 public static final int ATTR = 6;
 public static final int TAG = 1;
 public static final int YYINITIAL = 0;
 public static final int ATTR_VALUE_START = 7;
 public static final int COMMENT = 4;
 public static final int DOCTYPE = 10;
 public static final int ATTR_VALUE_SQ = 9;

 /**
  * Translates characters to character classes
  */
 private static final String ZZ_CMAP_PACKED =
   "\11\0\2\3\1\0\2\3\22\0\1\3\1\12\1\54\1\37\1\4"+
   "\1\0\1\22\1\55\5\0\1\10\1\7\1\57\12\2\1\1\1\25"+
   "\1\11\1\60\1\21\1\56\1\0\1\16\1\51\1\14\1\15\1\45"+
   "\1\41\2\1\1\53\2\1\1\52\1\47\1\1\1\42\1\44\2\1"+
   "\1\46\1\17\1\50\3\1\1\43\1\1\1\13\1\61\1\20\1\0"+
   "\1\1\1\0\1\26\1\35\4\41\1\23\4\1\1\23\1\36\1\34"+
   "\1\30\1\27\1\32\1\1\1\31\1\24\1\33\2\1\1\40\2\1"+
   "\1\5\1\0\1\6\uff82\0";

 /**
  * Translates characters to character classes
  */
 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

 /**
  * Translates DFA states to action switch labels.
  */
 private static final int [] ZZ_ACTION = zzUnpackAction();

 private static final String ZZ_ACTION_PACKED_0 =
   "\1\1\3\0\1\2\3\0\2\3\2\0\1\1\1\4"+
   "\1\5\1\6\1\5\1\1\1\5\1\7\1\5\1\10"+
   "\1\5\1\11\1\5\1\12\1\2\1\0\1\13\3\14"+
   "\1\15\1\16\1\17\4\3\1\20\3\3\1\21\1\5"+
   "\1\22\2\21\2\5\2\1\3\0\1\23\1\24\6\0"+
   "\1\1\1\0\1\25\1\26\2\0\2\3\1\0\4\3"+
   "\1\0\1\27\1\0\2\21\1\0\1\3\2\0\1\30"+
   "\3\0\1\31\10\0\1\32\1\33\4\3\2\21\1\34"+
   "\1\35\2\0\1\36\2\0\1\35\1\3\1\35\1\3"+
   "\2\21\2\0\2\3\2\21\2\0\2\3\1\37\1\40"+
   "\2\0\2\3\2\0\2\3\1\41\1\42\2\41";

 private static int [] zzUnpackAction() {
   int [] result = new int[143];
   int offset = 0;
   offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackAction(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }


 /**
  * Translates a state to a row index in the transition table
  */
 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

 private static final String ZZ_ROWMAP_PACKED_0 =
   "\0\0\0\62\0\144\0\226\0\310\0\372\0\u012c\0\u015e"+
   "\0\u0190\0\u01c2\0\u01f4\0\u0226\0\u0258\0\u028a\0\u02bc\0\u02ee"+
   "\0\u0320\0\u0352\0\u0384\0\u03b6\0\u03e8\0\u0384\0\u041a\0\u044c"+
   "\0\u047e\0\u04b0\0\u04e2\0\u0514\0\u0546\0\u0384\0\u03e8\0\u0320"+
   "\0\u0384\0\u0384\0\u0384\0\u0578\0\u05aa\0\u05dc\0\u0320\0\u0384"+
   "\0\u060e\0\u0640\0\u0672\0\u06a4\0\u06d6\0\u0384\0\u0708\0\u073a"+
   "\0\u076c\0\u079e\0\u0384\0\u07d0\0\u0802\0\u0834\0\u0866\0\u0384"+
   "\0\u0384\0\u0898\0\u08ca\0\u08fc\0\u092e\0\u0960\0\u0992\0\u09c4"+
   "\0\u09f6\0\u0384\0\u0384\0\u0a28\0\u0a5a\0\u0a8c\0\u0abe\0\u0af0"+
   "\0\u0b22\0\u0b54\0\u0b86\0\u0bb8\0\u06d6\0\u0384\0\u0bea\0\u0c1c"+
   "\0\u0c4e\0\u076c\0\u0384\0\u079e\0\u0c80\0\u0384\0\u0cb2\0\u0ce4"+
   "\0\u0d16\0\u0384\0\u0d48\0\u0d7a\0\u0dac\0\u0dde\0\u0e10\0\u0e42"+
   "\0\u0e74\0\u0ea6\0\u0384\0\u0384\0\u0ed8\0\u0f0a\0\u0f3c\0\u0f6e"+
   "\0\u0fa0\0\u0fd2\0\u0384\0\u0384\0\u1004\0\u1036\0\u0384\0\u1068"+
   "\0\u109a\0\u0578\0\u10cc\0\u060e\0\u10fe\0\u1130\0\u1162\0\u1194"+
   "\0\u11c6\0\u11f8\0\u122a\0\u125c\0\u128e\0\u12c0\0\u12f2\0\u1324"+
   "\0\u1356\0\u06a4\0\u06a4\0\u1388\0\u13ba\0\u13ec\0\u141e\0\u1450"+
   "\0\u1482\0\u14b4\0\u14e6\0\u0384\0\u0384\0\u0578\0\u060e";

 private static int [] zzUnpackRowMap() {
   int [] result = new int[143];
   int offset = 0;
   offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
   int i = 0;  /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int high = packed.charAt(i++) << 16;
     result[j++] = high | packed.charAt(i++);
   }
   return j;
 }

 /**
  * The transition table of the DFA
  */
 private static final int [] ZZ_TRANS = zzUnpackTrans();

 private static final String ZZ_TRANS_PACKED_0 =
   "\3\15\1\16\1\17\4\15\1\20\10\15\1\21\36\15"+
   "\1\22\1\23\1\24\1\23\1\16\5\23\1\25\2\23"+
   "\4\24\1\23\1\26\1\21\2\24\1\23\11\24\1\23"+
   "\14\24\3\23\1\27\3\23\1\30\7\23\1\25\2\23"+
   "\4\30\2\23\1\21\2\30\1\23\11\30\1\23\14\30"+
   "\2\23\1\31\4\23\1\32\1\23\1\16\5\23\1\25"+
   "\2\23\4\32\1\23\1\26\1\21\2\32\1\23\11\32"+
   "\1\23\14\32\6\23\10\33\1\34\51\33\1\23\1\35"+
   "\1\23\1\16\5\23\1\25\2\23\4\35\2\23\1\21"+
   "\2\35\1\23\11\35\1\23\14\35\6\23\3\36\1\16"+
   "\5\36\1\37\10\36\1\40\31\36\1\41\1\42\2\36"+
   "\1\43\1\36\11\23\1\25\10\23\1\21\37\23\4\44"+
   "\1\45\4\44\1\46\10\44\1\47\31\44\1\50\5\44"+
   "\4\51\1\52\4\51\1\53\10\51\1\47\32\51\1\50"+
   "\4\51\1\23\1\54\1\23\1\16\5\23\1\25\1\23"+
   "\1\55\4\54\1\23\1\56\1\21\2\54\1\23\11\54"+
   "\1\23\4\54\1\57\1\54\1\60\5\54\1\61\1\62"+
   "\4\23\20\63\1\64\41\63\3\15\1\0\1\65\4\15"+
   "\1\0\10\15\1\0\36\15\1\22\3\0\1\16\56\0"+
   "\5\15\1\66\54\15\12\0\1\67\43\0\1\70\1\71"+
   "\3\0\1\72\12\0\4\72\3\0\1\73\1\72\1\0"+
   "\1\74\3\72\1\75\1\72\1\76\2\72\1\77\14\72"+
   "\6\0\3\15\1\0\1\100\4\15\1\0\10\15\1\0"+
   "\36\15\1\22\63\0\2\24\4\0\2\24\3\0\4\24"+
   "\3\0\2\24\1\0\11\24\1\0\14\24\20\0\1\101"+
   "\70\0\1\102\41\0\2\30\4\0\2\30\3\0\4\30"+
   "\3\0\2\30\1\0\11\30\1\0\14\30\27\0\1\103"+
   "\41\0\2\32\4\0\2\32\3\0\4\32\3\0\2\32"+
   "\1\0\11\32\1\0\14\32\6\0\10\33\1\104\61\33"+
   "\1\105\51\33\1\0\2\35\4\0\2\35\3\0\4\35"+
   "\3\0\2\35\1\0\11\35\1\0\14\35\6\0\4\44"+
   "\1\0\15\44\1\0\31\44\1\0\5\44\4\106\1\107"+
   "\1\110\14\106\1\0\31\106\1\0\5\106\4\44\1\0"+
   "\5\44\1\111\7\44\1\0\31\44\1\0\5\44\4\51"+
   "\1\0\15\51\1\0\32\51\1\0\4\51\4\112\1\113"+
   "\1\110\14\112\1\0\32\112\1\0\4\112\4\51\1\0"+
   "\5\51\1\114\7\51\1\0\32\51\1\0\4\51\1\0"+
   "\2\54\4\0\2\54\3\0\4\54\3\0\2\54\1\0"+
   "\11\54\1\0\14\54\6\0\20\115\1\116\33\115\1\117"+
   "\5\115\1\0\2\54\4\0\2\54\3\0\4\54\3\0"+
   "\2\54\1\0\11\54\1\0\10\54\1\120\3\54\7\0"+
   "\2\54\4\0\2\54\3\0\4\54\3\0\2\54\1\0"+
   "\11\54\1\0\3\54\1\121\10\54\6\0\54\122\1\123"+
   "\5\122\55\124\1\123\4\124\20\0\1\125\41\0\5\15"+
   "\1\0\54\15\6\66\1\126\53\66\10\0\1\127\2\0"+
   "\1\130\1\0\1\131\45\0\2\72\4\0\2\72\3\0"+
   "\4\72\3\0\2\72\1\132\11\72\1\0\14\72\7\0"+
   "\2\72\4\0\2\72\3\0\4\72\3\0\1\72\1\133"+
   "\1\132\11\72\1\0\14\72\7\0\2\72\4\0\2\72"+
   "\3\0\4\72\3\0\2\72\1\132\1\72\1\134\6\72"+
   "\1\135\1\0\14\72\7\0\2\72\4\0\2\72\3\0"+
   "\4\72\3\0\2\72\1\132\5\72\1\136\3\72\1\0"+
   "\14\72\7\0\2\72\4\0\2\72\3\0\4\72\3\0"+
   "\2\72\1\132\7\72\1\137\1\72\1\0\14\72\10\0"+
   "\1\140\35\0\1\141\21\0\4\15\1\100\54\15\1\22"+
   "\10\0\1\127\2\0\1\130\46\0\10\33\1\142\72\33"+
   "\1\143\40\33\4\0\1\107\55\0\4\106\1\107\1\0"+
   "\14\106\1\0\31\106\1\0\5\106\6\110\1\144\53\110"+
   "\4\44\1\0\3\44\1\145\2\44\1\146\6\44\1\0"+
   "\31\44\1\0\5\44\4\0\1\113\55\0\4\112\1\113"+
   "\1\0\14\112\1\0\32\112\1\0\4\112\4\51\1\0"+
   "\3\51\1\147\2\51\1\150\6\51\1\0\32\51\1\0"+
   "\4\51\54\117\1\115\5\117\1\0\2\54\4\0\2\54"+
   "\3\0\4\54\3\0\2\54\1\0\11\54\1\0\11\54"+
   "\1\151\2\54\7\0\2\54\4\0\2\54\3\0\4\54"+
   "\3\0\2\54\1\0\11\54\1\0\6\54\1\152\5\54"+
   "\27\0\1\153\50\0\1\154\65\0\1\155\107\0\1\156"+
   "\20\0\2\72\4\0\2\72\3\0\4\72\3\0\2\72"+
   "\1\157\11\72\1\0\14\72\7\0\2\72\4\0\2\72"+
   "\3\0\4\72\3\0\2\72\1\132\2\72\1\160\6\72"+
   "\1\0\14\72\7\0\2\72\4\0\2\72\3\0\4\72"+
   "\3\0\2\72\1\132\1\72\1\133\7\72\1\0\14\72"+
   "\7\0\2\72\4\0\2\72\3\0\4\72\3\0\2\72"+
   "\1\132\2\72\1\73\6\72\1\0\14\72\7\0\2\72"+
   "\4\0\2\72\3\0\4\72\3\0\2\72\1\132\3\72"+
   "\1\135\5\72\1\0\14\72\10\0\1\140\22\0\1\157"+
   "\36\0\1\161\11\0\3\161\7\0\1\161\6\0\1\161"+
   "\3\0\1\161\3\0\1\161\3\0\1\161\10\0\21\33"+
   "\1\0\40\33\4\44\1\0\3\44\1\162\11\44\1\0"+
   "\31\44\1\0\11\44\1\0\7\44\1\163\5\44\1\0"+
   "\31\44\1\0\5\44\4\51\1\0\3\51\1\164\11\51"+
   "\1\0\32\51\1\0\10\51\1\0\7\51\1\165\5\51"+
   "\1\0\32\51\1\0\4\51\1\0\2\54\4\0\2\54"+
   "\3\0\4\54\3\0\2\54\1\0\11\54\1\0\12\54"+
   "\1\166\1\54\7\0\2\54\4\0\2\54\3\0\3\54"+
   "\1\167\3\0\2\54\1\0\11\54\1\0\14\54\23\0"+
   "\1\170\60\0\1\171\46\0\2\72\4\0\2\72\3\0"+
   "\4\72\3\0\2\72\1\132\3\72\1\133\5\72\1\0"+
   "\14\72\10\0\1\161\11\0\3\161\6\0\1\157\1\161"+
   "\6\0\1\161\3\0\1\161\3\0\1\161\3\0\1\161"+
   "\10\0\4\44\1\0\10\44\1\172\4\44\1\0\31\44"+
   "\1\0\5\44\4\51\1\0\10\51\1\173\4\51\1\0"+
   "\32\51\1\0\4\51\1\0\2\54\4\0\2\54\3\0"+
   "\4\54\3\0\2\54\1\0\11\54\1\0\13\54\1\174"+
   "\7\0\2\54\4\0\2\54\3\0\4\54\3\0\2\54"+
   "\1\0\11\54\1\0\5\54\1\175\6\54\24\0\1\176"+
   "\62\0\1\177\42\0\4\44\1\0\11\44\1\200\3\44"+
   "\1\0\31\44\1\0\5\44\4\51\1\0\11\51\1\201"+
   "\3\51\1\0\32\51\1\0\4\51\1\0\2\54\4\0"+
   "\2\54\3\0\1\202\3\54\3\0\2\54\1\0\11\54"+
   "\1\0\14\54\7\0\2\54\4\0\2\54\3\0\4\54"+
   "\3\0\2\54\1\0\11\54\1\0\7\54\1\203\4\54"+
   "\25\0\1\204\105\0\1\205\16\0\4\44\1\0\12\44"+
   "\1\206\2\44\1\0\31\44\1\0\5\44\4\51\1\0"+
   "\12\51\1\207\2\51\1\0\32\51\1\0\4\51\16\0"+
   "\1\210\107\0\1\211\15\0\4\44\1\0\11\44\1\212"+
   "\3\44\1\0\31\44\1\0\5\44\4\51\1\0\11\51"+
   "\1\213\3\51\1\0\32\51\1\0\4\51\13\0\1\214"+
   "\113\0\1\215\14\0\4\44\1\0\6\44\1\216\6\44"+
   "\1\0\31\44\1\0\5\44\4\51\1\0\6\51\1\217"+
   "\6\51\1\0\32\51\1\0\4\51";

 private static int [] zzUnpackTrans() {
   int [] result = new int[5400];
   int offset = 0;
   offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackTrans(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     value--;
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }


 /* error codes */
 private static final int ZZ_UNKNOWN_ERROR = 0;
 private static final int ZZ_NO_MATCH = 1;
 private static final int ZZ_PUSHBACK_2BIG = 2;
 private static final char[] EMPTY_BUFFER = new char[0];
 private static final int YYEOF = -1;

 /* error messages for the codes above */
 private static final String ZZ_ERROR_MSG[] = {
   "Unkown internal scanner error",
   "Error: could not match input",
   "Error: pushback value was too large"
 };

 /**
  * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
  */
 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

 private static final String ZZ_ATTRIBUTE_PACKED_0 =
   "\1\1\3\0\1\1\3\0\2\1\2\0\6\1\1\11"+
   "\2\1\1\11\5\1\1\0\1\1\1\11\2\1\3\11"+
   "\4\1\1\11\5\1\1\11\4\1\1\11\1\1\3\0"+
   "\2\11\6\0\1\1\1\0\2\11\2\0\2\1\1\0"+
   "\4\1\1\0\1\11\1\0\2\1\1\0\1\11\2\0"+
   "\1\11\3\0\1\11\10\0\2\11\6\1\2\11\2\0"+
   "\1\11\2\0\6\1\2\0\4\1\2\0\4\1\2\0"+
   "\2\1\2\0\2\1\2\11\2\1";

 private static int [] zzUnpackAttribute() {
   int [] result = new int[143];
   int offset = 0;
   offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }

 /** the current state of the DFA */
 private int zzState;

 /** the current lexical state */
 private int zzLexicalState = YYINITIAL;

 /** this buffer contains the current text to be matched and is
     the source of the yytext() string */
 private char zzBuffer[] = EMPTY_BUFFER;

 /** the textposition at the last accepting state */
 private int zzMarkedPos;

 /** the textposition at the last state to be included in yytext */
 private int zzPushbackPos;

 /** the current text position in the buffer */
 private int zzCurrentPos;

 /** startRead marks the beginning of the yytext() string in the buffer */
 private int zzStartRead;

 /** endRead marks the last character in the buffer, that has been read
     from input */
 private int zzEndRead;

 /**
  * zzAtBOL == true <=> the scanner is currently at the beginning of a line
  */
 private boolean zzAtBOL = true;

 /** zzAtEOF == true <=> the scanner is at the EOF */
 private boolean zzAtEOF;

 /** denotes if the user-EOF-code has already been executed */
 private boolean zzEOFDone;

 /* user code: */
 private IElementType elTokenType = XmlTokenType.XML_DATA_CHARACTERS;
 private IElementType elTokenType2 = XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;

 public void setElTypes(IElementType _elTokenType,IElementType _elTokenType2) {
   elTokenType = _elTokenType;
   elTokenType2 = _elTokenType2;
 }

 private IElementType myTokenType;
 private int myPrevState = YYINITIAL;
 private int myState = YYINITIAL;
 private final int myLastState;

 {
   // code assumes that
   // - PROCESSING_INSTRUCTION state is the last from previous states with number 2
   // - CDATA state is the last state and its number < 16
   myLastState = (CDATA + 1) + (PROCESSING_INSTRUCTION << 4);
   assert myLastState < 64;
 }

 public _XmlLexer(){
   this((java.io.Reader)null);
 }

 public final void start(char[] buffer){
   start(buffer, 0, buffer.length);
 }

 public final void start(char[] buffer, int startOffset, int endOffset){
   start(buffer, startOffset, endOffset, (short)YYINITIAL);
 }

 public final void start(char[] buffer, int startOffset, int endOffset, int initialState){
   zzBuffer = buffer;
   zzCurrentPos = zzMarkedPos = zzStartRead = startOffset;
   zzPushbackPos = 0;
   zzAtEOF  = false;
   zzEndRead = endOffset;
   myTokenType = null;
   yybegin(initialState & 15);
   myPrevState = (initialState >> 4) & 15;
   packState();
 }

 public final int getState(){
   return myState;
 }

 private void packState() {
   myState = ((myPrevState & 15) << 4) | (zzLexicalState & 15);
 }

 public final int getLastState() {
   return myLastState;
 }

 public final IElementType getTokenType(){
   locateToken();
   return myTokenType;
 }

 public final int getTokenStart(){
   locateToken();
   return zzStartRead - zzPushbackPos;
 }

 public final int getTokenEnd(){
   return getTokenStart() + yylength();
 }

 public final void advance(){
   locateToken();
   myTokenType = null;
   packState();
 }

 public final char[] getBuffer(){
   return zzBuffer;
 }

 public final int getBufferEnd(){
   return zzEndRead;
 }

 protected final void locateToken(){
   if (myTokenType != null) return;
   try{
   _locateToken();
   }
   catch(java.io.IOException ioe){}
 }

 public int getSmartUpdateShift() {
   return 10;
 }

 private int popState(){
   final int prev = myPrevState;
   myPrevState = YYINITIAL;
   return prev;
 }

 private void pushState(int state){
   myPrevState = state;
 }

 public Object clone() {
   try{
     return super.clone();
   }
   catch(CloneNotSupportedException e){
     return null;
   }
 }


 /**
  * Creates a new scanner
  * There is also a java.io.InputStream version of this constructor.
  *
  * @param   in  the java.io.Reader to read input from.
  */
 public _XmlLexer(java.io.Reader in) {
     myTokenType = null;
 }

 /**
  * Creates a new scanner.
  * There is also java.io.Reader version of this constructor.
  *
  * @param   in  the java.io.Inputstream to read input from.
  */
 public _XmlLexer(java.io.InputStream in) {
   this(new java.io.InputStreamReader(in));
 }

 /**
  * Unpacks the compressed character translation table.
  *
  * @param packed   the packed character translation table
  * @return         the unpacked character translation table
  */
 private static char [] zzUnpackCMap(String packed) {
   char [] map = new char[0x10000];
   int i = 0;  /* index in packed string  */
   int j = 0;  /* index in unpacked array */
   while (i < 148) {
     int  count = packed.charAt(i++);
     char value = packed.charAt(i++);
     do map[j++] = value; while (--count > 0);
   }
   return map;
 }


 /**
  * Refills the input buffer.
  *
  * @return      <code>false</code>, iff there was new input.
  *
  * @exception   java.io.IOException  if any I/O-Error occurs
  */
 private boolean zzRefill() throws java.io.IOException {
   return true;
 }


 /**
  * Closes the input stream.
  */
 public final void yyclose() throws java.io.IOException {
   zzAtEOF = true;            /* indicate end of file */
   zzEndRead = zzStartRead;  /* invalidate buffer    */
 }


 /**
  * Resets the scanner to read from a new input stream.
  * Does not close the old reader.
  *
  * All internal variables are reset, the old input stream
  * <b>cannot</b> be reused (internal buffer is discarded and lost).
  * Lexical state is set to <tt>ZZ_INITIAL</tt>.
  *
  * @param reader   the new input stream
  */
 public final void yyreset(java.io.Reader reader) {
   zzAtBOL  = true;
   zzAtEOF  = false;
   zzEndRead = zzStartRead = 0;
   zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
   zzLexicalState = YYINITIAL;
 }


 /**
  * Returns the current lexical state.
  */
 public final int yystate() {
   return zzLexicalState;
 }


 /**
  * Enters a new lexical state
  *
  * @param newState the new lexical state
  */
 public final void yybegin(int newState) {
   zzLexicalState = newState;
 }


 /**
  * Returns the text matched by the current regular expression.
  */
 public final String yytext() {
   return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
 }


 /**
  * Returns the character at position <tt>pos</tt> from the
  * matched text.
  *
  * It is equivalent to yytext().charAt(pos), but faster
  *
  * @param pos the position of the character to fetch.
  *            A value from 0 to yylength()-1.
  *
  * @return the character at position pos
  */
 public final char yycharat(int pos) {
   return zzBuffer[zzStartRead+pos];
 }


 /**
  * Returns the length of the matched text region.
  */
 public final int yylength() {
   return zzMarkedPos-zzStartRead;
 }


 /**
  * Reports an error that occured while scanning.
  *
  * In a wellformed scanner (no or only correct usage of
  * yypushback(int) and a match-all fallback rule) this method
  * will only be called with things that "Can't Possibly Happen".
  * If this method is called, something is seriously wrong
  * (e.g. a JFlex bug producing a faulty scanner etc.).
  *
  * Usual syntax/scanner level error handling should be done
  * in error fallback rules.
  *
  * @param   errorCode  the code of the errormessage to display
  */
 private void zzScanError(int errorCode) {
   String message;
   try {
     message = ZZ_ERROR_MSG[errorCode];
   }
   catch (ArrayIndexOutOfBoundsException e) {
     message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
   }

   throw new Error(message);
 }


 /**
  * Pushes the specified amount of characters back into the input stream.
  *
  * They will be read again by then next call of the scanning method
  *
  * @param number  the number of characters to be read again.
  *                This number must not be greater than yylength()!
  */
 public void yypushback(int number)  {
   if ( number > yylength() )
     zzScanError(ZZ_PUSHBACK_2BIG);

   zzMarkedPos -= number;
 }


 /**
  * Contains user EOF-code, which will be executed exactly once,
  * when the end of file is reached
  */
 private void zzDoEOF() {
   if (!zzEOFDone) {
     zzEOFDone = true;

   }
 }


 /**
  * Resumes scanning until the next regular expression is matched,
  * the end of input is encountered or an I/O-Error occurs.
  *
  * @return      the next token
  * @exception   java.io.IOException  if any I/O-Error occurs
  */
 public void _locateToken() throws java.io.IOException {
   int zzInput;
   int zzAction;

   // cached fields:
   int zzCurrentPosL;
   int zzMarkedPosL;
   int zzEndReadL = zzEndRead;
   char [] zzBufferL = zzBuffer;
   char [] zzCMapL = ZZ_CMAP;

   int [] zzTransL = ZZ_TRANS;
   int [] zzRowMapL = ZZ_ROWMAP;
   int [] zzAttrL = ZZ_ATTRIBUTE;

   while (true) {
     zzMarkedPosL = zzMarkedPos;

     zzAction = -1;

     zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

     zzState = zzLexicalState;


     zzForAction: {
       while (true) {

         if (zzCurrentPosL < zzEndReadL)
           zzInput = zzBufferL[zzCurrentPosL++];
         else if (zzAtEOF) {
           zzInput = YYEOF;
           break zzForAction;
         }
         else {
           // store back cached positions
           zzCurrentPos  = zzCurrentPosL;
           zzMarkedPos   = zzMarkedPosL;
           boolean eof = zzRefill();
           // get translated positions and possibly new buffer
           zzCurrentPosL  = zzCurrentPos;
           zzMarkedPosL   = zzMarkedPos;
           zzBufferL      = zzBuffer;
           zzEndReadL     = zzEndRead;
           if (eof) {
             zzInput = YYEOF;
             break zzForAction;
           }
           else {
             zzInput = zzBufferL[zzCurrentPosL++];
           }
         }
         int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
         if (zzNext == -1) break zzForAction;
         zzState = zzNext;

         int zzAttributes = zzAttrL[zzState];
         if ( (zzAttributes & 1) == 1 ) {
           zzAction = zzState;
           zzMarkedPosL = zzCurrentPosL;
           if ( (zzAttributes & 8) == 8 ) break zzForAction;
         }

       }
     }

     // store back cached position
     zzMarkedPos = zzMarkedPosL;

     switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
       case 32:
         { myTokenType = XmlTokenType.XML_DOCTYPE_SYSTEM;  return;
         }
       case 35: break;
       case 25:
         { myTokenType = XmlTokenType.XML_ENTITY_REF_TOKEN; return;
         }
       case 36: break;
       case 21:
         { myTokenType = XmlTokenType.XML_EMPTY_ELEMENT_END; yybegin(YYINITIAL); return;
         }
       case 37: break;
       case 29:
         { myTokenType = XmlTokenType.XML_COMMENT_START; yybegin(COMMENT); return;
         }
       case 38: break;
       case 11:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR); return;
         }
       case 39: break;
       case 30:
         { myTokenType = XmlTokenType.XML_CHAR_ENTITY_REF; return;
         }
       case 40: break;
       case 28:
         { myTokenType = XmlTokenType.XML_CDATA_END; yybegin(YYINITIAL); return;
         }
       case 41: break;
       case 2:
         { myTokenType = XmlTokenType.XML_COMMENT_CHARACTERS; return;
         }
       case 42: break;
       case 31:
         { myTokenType = XmlTokenType.XML_DOCTYPE_PUBLIC;  return;
         }
       case 43: break;
       case 14:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER; yybegin(ATTR_VALUE_SQ); return;
         }
       case 44: break;
       case 13:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER; yybegin(ATTR_VALUE_DQ); return;
         }
       case 45: break;
       case 5:
         { if(yystate() == YYINITIAL){
       myTokenType = XmlTokenType.XML_BAD_CHARACTER;
       return;
     }
     else yybegin(popState()); yypushback(yylength());
         }
       case 46: break;
       case 34:
         { myTokenType = XmlTokenType.XML_DOCTYPE_START; yybegin(DOCTYPE); return;
         }
       case 47: break;
       case 23:
         { myTokenType = XmlElementType.XML_MARKUP; return;
         }
       case 48: break;
       case 9:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR_LIST); pushState(PROCESSING_INSTRUCTION); return;
         }
       case 49: break;
       case 8:
         { myTokenType = XmlTokenType.XML_TAG_END; yybegin(YYINITIAL); return;
         }
       case 50: break;
       case 15:
         { myTokenType = XmlTokenType.XML_EQ; return;
         }
       case 51: break;
       case 33:
         { myTokenType = XmlTokenType.XML_CDATA_START; yybegin(CDATA); return;
         }
       case 52: break;
       case 6:
         { myTokenType = XmlTokenType.XML_START_TAG_START; yybegin(TAG); return;
         }
       case 53: break;
       case 18:
         { myTokenType = XmlTokenType.XML_DOCTYPE_END;  yybegin(YYINITIAL); return;
         }
       case 54: break;
       case 7:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR_LIST); pushState(TAG); return;
         }
       case 55: break;
       case 26:
         { myTokenType = XmlTokenType.XML_COMMENT_END; yybegin(YYINITIAL); return;
         }
       case 56: break;
       case 10:
         { myTokenType = XmlTokenType.XML_NAME; return;
         }
       case 57: break;
       case 27:
         { myTokenType = elTokenType2;
 return;
         }
       case 58: break;
       case 19:
         { myTokenType = XmlTokenType.XML_PI_START; yybegin(PROCESSING_INSTRUCTION); return;
         }
       case 59: break;
       case 12:
         { yybegin(ATTR_LIST); yypushback(yylength());
         }
       case 60: break;
       case 3:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN; return;
         }
       case 61: break;
       case 4:
         { myTokenType = XmlTokenType.XML_WHITE_SPACE; return;
         }
       case 62: break;
       case 16:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER; yybegin(ATTR_LIST); return;
         }
       case 63: break;
       case 17:
         { myTokenType = XmlTokenType.XML_NAME;  return;
         }
       case 64: break;
       case 1:
         { myTokenType = XmlTokenType.XML_DATA_CHARACTERS; return;
         }
       case 65: break;
       case 22:
         { myTokenType = XmlTokenType.XML_PI_END; yybegin(YYINITIAL); return;
         }
       case 66: break;
       case 24:
         { myTokenType = elTokenType;
 return;
         }
       case 67: break;
       case 20:
         { myTokenType = XmlTokenType.XML_END_TAG_START; yybegin(END_TAG); return;
         }
       case 68: break;
       default:
         if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
           zzAtEOF = true;
           zzDoEOF();
           return;
         }
         else {
           zzScanError(ZZ_NO_MATCH);
         }
     }
   }
 }


 }
