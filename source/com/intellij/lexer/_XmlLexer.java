/* The following code was generated by JFlex 1.4 on 1/29/05 10:40 PM */

/* It's an automatically generated code. Do not modify it. */
 package com.intellij.lexer;

 import com.intellij.psi.tree.IElementType;
 import com.intellij.psi.*;
 import com.intellij.psi.xml.*;


 /**
* This class is a scanner generated by
* <a href="http://www.jflex.de/">JFlex</a> 1.4
* on 1/29/05 10:40 PM from the specification file
* <tt>_XmlLexer.flex</tt>
*/
 public class _XmlLexer implements Lexer, Cloneable {
 /** initial size of the lookahead buffer */
 private static final int ZZ_BUFFERSIZE = 16384;

 /** lexical states */
 public static final int PROCESSING_INSTRUCTION = 9;
 public static final int ATTR_LIST = 4;
 public static final int EL_ATTR_VALUE = 12;
 public static final int END_TAG = 2;
 public static final int ATTR_VALUE_DQ = 7;
 public static final int EL_ATTR_VALUE2 = 13;
 public static final int DTD_MARKUP = 6;
 public static final int CDATA = 14;
 public static final int ATTR = 5;
 public static final int TAG = 1;
 public static final int EL = 11;
 public static final int YYINITIAL = 0;
 public static final int ATTR_VALUE_START = 6;
 public static final int COMMENT = 3;
 public static final int DOCTYPE = 10;
 public static final int ATTR_VALUE_SQ = 8;

 /**
  * Translates characters to character classes
  */
 private static final String ZZ_CMAP_PACKED =
   "\11\0\2\3\1\0\2\3\22\0\1\57\1\7\1\51\1\34\1\54"+
   "\1\0\1\17\1\52\5\0\1\5\1\4\1\60\12\2\1\1\1\22"+
   "\1\6\1\61\1\16\1\53\1\0\1\13\1\46\1\11\1\12\1\42"+
   "\1\36\2\1\1\50\2\1\1\47\1\44\1\1\1\37\1\41\2\1"+
   "\1\43\1\14\1\45\3\1\1\40\1\1\1\10\1\62\1\15\1\0"+
   "\1\1\1\0\1\23\1\32\4\36\1\20\4\1\1\20\1\33\1\31"+
   "\1\25\1\24\1\27\1\1\1\26\1\21\1\30\2\1\1\35\2\1"+
   "\1\55\1\0\1\56\uff82\0";

 /**
  * Translates characters to character classes
  */
 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

 /**
  * Translates DFA states to action switch labels.
  */
 private static final int [] ZZ_ACTION = zzUnpackAction();

 private static final String ZZ_ACTION_PACKED_0 =
   "\1\1\2\0\1\2\3\0\2\3\2\0\3\4\1\0"+
   "\1\1\1\5\1\6\2\7\1\1\1\7\1\10\1\7"+
   "\1\11\1\7\1\12\1\2\1\0\1\13\3\14\1\15"+
   "\1\16\1\17\3\3\1\20\1\7\2\3\1\7\1\21"+
   "\1\7\1\22\1\7\1\23\2\22\2\7\4\4\1\24"+
   "\3\4\1\25\1\26\2\1\1\0\1\27\1\30\6\0"+
   "\1\31\1\1\1\0\1\32\2\0\2\3\1\33\2\3"+
   "\1\34\1\35\1\0\1\36\1\0\2\22\1\0\1\3"+
   "\1\0\16\4\4\0\1\37\11\0\1\40\2\3\1\0"+
   "\2\3\1\0\2\22\2\4\1\37\11\4\1\37\7\4"+
   "\1\41\1\42\2\0\1\43\2\0\1\42\1\3\1\42"+
   "\1\3\2\22\1\42\1\4\1\43\2\4\1\42\1\4"+
   "\1\43\2\4\2\0\2\3\2\22\2\4\2\0\2\3"+
   "\1\44\1\45\2\4\2\0\2\3\2\4\2\0\2\3"+
   "\2\4\1\46\1\47\4\46";

 private static int [] zzUnpackAction() {
   int [] result = new int[209];
   int offset = 0;
   offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackAction(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }


 /**
  * Translates a state to a row index in the transition table
  */
 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

 private static final String ZZ_ROWMAP_PACKED_0 =
   "\0\0\0\63\0\146\0\231\0\314\0\377\0\u0132\0\u0165"+
   "\0\u0198\0\u01cb\0\u01fe\0\u0231\0\u0264\0\u0297\0\u02ca\0\u02fd"+
   "\0\u0330\0\u0363\0\u0396\0\u03c9\0\u03fc\0\u042f\0\u0462\0\u0495"+
   "\0\u042f\0\u04c8\0\u04fb\0\u052e\0\u0561\0\u0594\0\u042f\0\u0495"+
   "\0\u0396\0\u042f\0\u042f\0\u042f\0\u05c7\0\u05fa\0\u0396\0\u042f"+
   "\0\u062d\0\u0660\0\u0693\0\u06c6\0\u06f9\0\u072c\0\u075f\0\u0792"+
   "\0\u042f\0\u07c5\0\u07f8\0\u082b\0\u085e\0\u0891\0\u08c4\0\u08f7"+
   "\0\u092a\0\u042f\0\u095d\0\u0990\0\u09c3\0\u042f\0\u042f\0\u042f"+
   "\0\u09f6\0\u0a29\0\u042f\0\u042f\0\u0a5c\0\u0a8f\0\u0ac2\0\u0af5"+
   "\0\u0b28\0\u0b5b\0\u042f\0\u0b8e\0\u0bc1\0\u042f\0\u0bf4\0\u0c27"+
   "\0\u0c5a\0\u0c8d\0\u042f\0\u0cc0\0\u0cf3\0\u042f\0\u042f\0\u0792"+
   "\0\u042f\0\u0d26\0\u0d59\0\u0d8c\0\u082b\0\u042f\0\u085e\0\u0dbf"+
   "\0\u0df2\0\u0e25\0\u0e58\0\u0e8b\0\u0ebe\0\u0ef1\0\u0f24\0\u0f57"+
   "\0\u0f8a\0\u0fbd\0\u0ff0\0\u1023\0\u1056\0\u1089\0\u10bc\0\u10ef"+
   "\0\u1122\0\u042f\0\u1155\0\u1188\0\u11bb\0\u11ee\0\u1221\0\u1254"+
   "\0\u1287\0\u12ba\0\u12ed\0\u042f\0\u1320\0\u1353\0\u1386\0\u13b9"+
   "\0\u13ec\0\u141f\0\u1452\0\u1485\0\u14b8\0\u14eb\0\u0891\0\u151e"+
   "\0\u1551\0\u1584\0\u15b7\0\u15ea\0\u161d\0\u1650\0\u1683\0\u16b6"+
   "\0\u095d\0\u16e9\0\u171c\0\u174f\0\u1782\0\u17b5\0\u17e8\0\u181b"+
   "\0\u042f\0\u042f\0\u184e\0\u1881\0\u042f\0\u18b4\0\u18e7\0\u05c7"+
   "\0\u191a\0\u0660\0\u194d\0\u1980\0\u19b3\0\u0891\0\u19e6\0\u0891"+
   "\0\u1a19\0\u1a4c\0\u095d\0\u1a7f\0\u095d\0\u1ab2\0\u1ae5\0\u1b18"+
   "\0\u1b4b\0\u1b7e\0\u1bb1\0\u1be4\0\u1c17\0\u1c4a\0\u1c7d\0\u1cb0"+
   "\0\u1ce3\0\u1d16\0\u1d49\0\u075f\0\u075f\0\u1d7c\0\u1daf\0\u1de2"+
   "\0\u1e15\0\u1e48\0\u1e7b\0\u1eae\0\u1ee1\0\u1f14\0\u1f47\0\u1f7a"+
   "\0\u1fad\0\u1fe0\0\u2013\0\u042f\0\u042f\0\u05c7\0\u0660\0\u0891"+
   "\0\u095d";

 private static int [] zzUnpackRowMap() {
   int [] result = new int[209];
   int offset = 0;
   offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
   int i = 0;  /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int high = packed.charAt(i++) << 16;
     result[j++] = high | packed.charAt(i++);
   }
   return j;
 }

 /**
  * The transition table of the DFA
  */
 private static final int [] ZZ_TRANS = zzUnpackTrans();

 private static final String ZZ_TRANS_PACKED_0 =
   "\3\20\1\21\2\20\1\22\10\20\1\23\34\20\1\24"+
   "\2\20\1\21\2\20\1\25\1\26\1\27\1\26\1\21"+
   "\2\26\1\30\2\26\4\27\1\26\1\31\1\23\2\27"+
   "\1\26\11\27\1\26\14\27\6\26\1\21\1\32\3\26"+
   "\1\33\1\26\1\21\2\26\1\30\2\26\4\33\1\26"+
   "\1\31\1\23\2\33\1\26\11\33\1\26\14\33\6\26"+
   "\1\21\3\26\5\34\1\35\55\34\1\26\1\36\1\26"+
   "\1\21\2\26\1\30\2\26\4\36\2\26\1\23\2\36"+
   "\1\26\11\36\1\26\14\36\6\26\1\21\3\26\3\37"+
   "\1\21\2\37\1\40\10\37\1\41\31\37\1\42\1\43"+
   "\4\37\1\21\1\37\1\44\1\37\6\26\1\30\10\26"+
   "\1\23\43\26\6\45\1\46\10\45\1\47\31\45\1\50"+
   "\2\45\1\51\6\45\6\52\1\53\10\52\1\47\32\52"+
   "\1\50\1\52\1\54\6\52\1\26\1\55\4\26\1\30"+
   "\2\26\4\55\2\26\1\23\2\55\1\26\11\55\1\26"+
   "\14\55\2\26\1\56\10\26\1\57\1\26\1\21\2\26"+
   "\1\30\1\26\1\60\4\57\1\26\1\61\1\23\2\57"+
   "\1\26\11\57\1\26\4\57\1\62\1\57\1\63\5\57"+
   "\1\64\1\65\4\26\1\21\3\26\3\66\1\67\2\66"+
   "\1\70\10\66\1\71\36\66\1\72\1\21\3\66\6\73"+
   "\1\74\10\73\1\75\36\73\1\76\12\73\1\74\10\73"+
   "\1\75\36\73\1\77\4\73\15\100\1\101\45\100\3\20"+
   "\1\0\2\20\1\0\10\20\1\0\34\20\1\0\2\20"+
   "\1\0\3\20\3\0\1\21\53\0\1\21\12\0\1\102"+
   "\43\0\1\103\4\0\1\104\3\0\1\105\7\0\4\105"+
   "\3\0\1\106\1\105\1\0\1\107\3\105\1\110\1\105"+
   "\1\111\2\105\1\112\14\105\67\0\1\113\5\0\3\20"+
   "\1\0\2\20\1\0\10\20\1\0\34\20\1\114\2\20"+
   "\1\0\3\20\64\0\2\27\1\0\2\27\3\0\4\27"+
   "\3\0\2\27\1\0\11\27\1\0\14\27\21\0\1\115"+
   "\71\0\1\116\45\0\2\33\1\0\2\33\3\0\4\33"+
   "\3\0\2\33\1\0\11\33\1\0\14\33\12\0\5\34"+
   "\1\117\62\34\1\120\55\34\1\0\2\36\1\0\2\36"+
   "\3\0\4\36\3\0\2\36\1\0\11\36\1\0\14\36"+
   "\12\0\17\45\1\0\31\45\1\0\2\45\1\0\15\45"+
   "\1\121\7\45\1\0\31\45\1\0\2\45\1\0\6\45"+
   "\17\122\1\0\31\122\1\0\3\122\1\123\5\122\17\52"+
   "\1\0\32\52\1\0\1\52\1\0\15\52\1\124\7\52"+
   "\1\0\32\52\1\0\1\52\1\0\6\52\17\125\1\0"+
   "\32\125\1\0\2\125\1\126\5\125\1\0\2\55\1\0"+
   "\2\55\3\0\4\55\3\0\2\55\1\0\11\55\1\0"+
   "\14\55\30\0\1\127\45\0\2\57\1\0\2\57\3\0"+
   "\4\57\3\0\2\57\1\0\11\57\1\0\14\57\12\0"+
   "\15\130\1\131\33\130\1\132\11\130\1\0\2\57\1\0"+
   "\2\57\3\0\4\57\3\0\2\57\1\0\11\57\1\0"+
   "\10\57\1\133\3\57\13\0\2\57\1\0\2\57\3\0"+
   "\4\57\3\0\2\57\1\0\11\57\1\0\3\57\1\134"+
   "\10\57\12\0\51\135\1\136\11\135\52\137\1\136\10\137"+
   "\56\66\2\0\6\66\1\67\52\66\1\0\1\21\12\66"+
   "\1\140\46\66\2\0\4\66\1\141\7\66\4\141\3\66"+
   "\1\142\1\141\1\66\1\143\3\141\1\144\1\141\1\145"+
   "\2\141\1\146\14\141\5\66\2\0\3\66\56\73\1\0"+
   "\13\73\1\147\46\73\1\0\5\73\1\150\7\73\4\150"+
   "\3\73\1\151\1\150\1\73\1\152\3\150\1\153\1\150"+
   "\1\154\2\150\1\155\14\150\5\73\1\0\4\73\15\0"+
   "\1\156\52\0\1\157\2\0\1\160\1\0\1\161\51\0"+
   "\2\105\1\0\2\105\3\0\4\105\3\0\2\105\1\162"+
   "\11\105\1\0\14\105\13\0\2\105\1\0\2\105\3\0"+
   "\4\105\3\0\1\105\1\163\1\162\11\105\1\0\14\105"+
   "\13\0\2\105\1\0\2\105\3\0\4\105\3\0\2\105"+
   "\1\162\1\105\1\164\6\105\1\165\1\0\14\105\13\0"+
   "\2\105\1\0\2\105\3\0\4\105\3\0\2\105\1\162"+
   "\5\105\1\166\3\105\1\0\14\105\13\0\2\105\1\0"+
   "\2\105\3\0\4\105\3\0\2\105\1\162\7\105\1\167"+
   "\1\105\1\0\14\105\14\0\1\170\32\0\1\171\107\0"+
   "\1\172\5\0\1\157\2\0\1\160\52\0\5\34\1\173"+
   "\73\34\1\174\44\34\5\45\1\175\2\45\1\176\6\45"+
   "\1\0\31\45\1\0\2\45\1\0\6\45\54\0\1\177"+
   "\6\0\5\52\1\200\2\52\1\201\6\52\1\0\32\52"+
   "\1\0\1\52\1\0\6\52\54\0\1\202\6\0\51\132"+
   "\1\130\11\132\1\0\2\57\1\0\2\57\3\0\4\57"+
   "\3\0\2\57\1\0\11\57\1\0\11\57\1\203\2\57"+
   "\13\0\2\57\1\0\2\57\3\0\4\57\3\0\2\57"+
   "\1\0\11\57\1\0\6\57\1\204\5\57\12\0\5\66"+
   "\1\205\2\66\1\206\45\66\2\0\4\66\2\141\1\66"+
   "\2\141\3\66\4\141\3\66\2\141\1\207\11\141\1\66"+
   "\14\141\5\66\2\0\4\66\2\141\1\66\2\141\3\66"+
   "\4\141\3\66\1\141\1\210\1\207\11\141\1\66\14\141"+
   "\5\66\2\0\4\66\2\141\1\66\2\141\3\66\4\141"+
   "\3\66\2\141\1\207\1\141\1\211\6\141\1\212\1\66"+
   "\14\141\5\66\2\0\4\66\2\141\1\66\2\141\3\66"+
   "\4\141\3\66\2\141\1\207\5\141\1\213\3\141\1\66"+
   "\14\141\5\66\2\0\4\66\2\141\1\66\2\141\3\66"+
   "\4\141\3\66\2\141\1\207\7\141\1\214\1\141\1\66"+
   "\14\141\5\66\2\0\5\66\1\215\32\66\1\216\20\66"+
   "\2\0\3\66\5\73\1\217\2\73\1\220\45\73\1\0"+
   "\5\73\2\150\1\73\2\150\3\73\4\150\3\73\2\150"+
   "\1\221\11\150\1\73\14\150\5\73\1\0\5\73\2\150"+
   "\1\73\2\150\3\73\4\150\3\73\1\150\1\222\1\221"+
   "\11\150\1\73\14\150\5\73\1\0\5\73\2\150\1\73"+
   "\2\150\3\73\4\150\3\73\2\150\1\221\1\150\1\223"+
   "\6\150\1\224\1\73\14\150\5\73\1\0\5\73\2\150"+
   "\1\73\2\150\3\73\4\150\3\73\2\150\1\221\5\150"+
   "\1\225\3\150\1\73\14\150\5\73\1\0\5\73\2\150"+
   "\1\73\2\150\3\73\4\150\3\73\2\150\1\221\7\150"+
   "\1\226\1\150\1\73\14\150\5\73\1\0\6\73\1\227"+
   "\32\73\1\230\20\73\1\0\4\73\16\0\1\231\51\0"+
   "\1\232\66\0\1\233\110\0\1\234\24\0\2\105\1\0"+
   "\2\105\3\0\4\105\3\0\2\105\1\235\11\105\1\0"+
   "\14\105\13\0\2\105\1\0\2\105\3\0\4\105\3\0"+
   "\2\105\1\162\2\105\1\236\6\105\1\0\14\105\13\0"+
   "\2\105\1\0\2\105\3\0\4\105\3\0\2\105\1\162"+
   "\1\105\1\163\7\105\1\0\14\105\13\0\2\105\1\0"+
   "\2\105\3\0\4\105\3\0\2\105\1\162\2\105\1\106"+
   "\6\105\1\0\14\105\13\0\2\105\1\0\2\105\3\0"+
   "\4\105\3\0\2\105\1\162\3\105\1\165\5\105\1\0"+
   "\14\105\14\0\1\170\17\0\1\235\42\0\1\237\6\0"+
   "\3\237\7\0\1\237\6\0\1\237\3\0\1\237\3\0"+
   "\1\237\3\0\1\237\70\0\1\114\6\0\16\34\1\0"+
   "\44\34\5\45\1\240\11\45\1\0\31\45\1\0\2\45"+
   "\1\0\17\45\1\241\5\45\1\0\31\45\1\0\2\45"+
   "\1\0\6\45\17\122\1\0\31\122\1\0\3\122\1\0"+
   "\5\122\5\52\1\242\11\52\1\0\32\52\1\0\1\52"+
   "\1\0\17\52\1\243\5\52\1\0\32\52\1\0\1\52"+
   "\1\0\6\52\17\125\1\0\32\125\1\0\2\125\1\0"+
   "\5\125\1\0\2\57\1\0\2\57\3\0\4\57\3\0"+
   "\2\57\1\0\11\57\1\0\12\57\1\244\1\57\13\0"+
   "\2\57\1\0\2\57\3\0\3\57\1\245\3\0\2\57"+
   "\1\0\11\57\1\0\14\57\12\0\5\66\1\246\50\66"+
   "\2\0\14\66\1\247\44\66\2\0\4\66\2\141\1\66"+
   "\2\141\3\66\4\141\3\66\2\141\1\250\11\141\1\66"+
   "\14\141\5\66\2\0\4\66\2\141\1\66\2\141\3\66"+
   "\4\141\3\66\2\141\1\207\2\141\1\251\6\141\1\66"+
   "\14\141\5\66\2\0\4\66\2\141\1\66\2\141\3\66"+
   "\4\141\3\66\2\141\1\207\1\141\1\210\7\141\1\66"+
   "\14\141\5\66\2\0\4\66\2\141\1\66\2\141\3\66"+
   "\4\141\3\66\2\141\1\207\2\141\1\142\6\141\1\66"+
   "\14\141\5\66\2\0\4\66\2\141\1\66\2\141\3\66"+
   "\4\141\3\66\2\141\1\207\3\141\1\212\5\141\1\66"+
   "\14\141\5\66\2\0\5\66\1\215\17\66\1\250\33\66"+
   "\2\0\5\66\1\252\6\66\3\252\7\66\1\252\6\66"+
   "\1\252\3\66\1\252\3\66\1\252\3\66\1\252\7\66"+
   "\2\0\3\66\5\73\1\253\50\73\1\0\15\73\1\254"+
   "\44\73\1\0\5\73\2\150\1\73\2\150\3\73\4\150"+
   "\3\73\2\150\1\255\11\150\1\73\14\150\5\73\1\0"+
   "\5\73\2\150\1\73\2\150\3\73\4\150\3\73\2\150"+
   "\1\221\2\150\1\256\6\150\1\73\14\150\5\73\1\0"+
   "\5\73\2\150\1\73\2\150\3\73\4\150\3\73\2\150"+
   "\1\221\1\150\1\222\7\150\1\73\14\150\5\73\1\0"+
   "\5\73\2\150\1\73\2\150\3\73\4\150\3\73\2\150"+
   "\1\221\2\150\1\151\6\150\1\73\14\150\5\73\1\0"+
   "\5\73\2\150\1\73\2\150\3\73\4\150\3\73\2\150"+
   "\1\221\3\150\1\224\5\150\1\73\14\150\5\73\1\0"+
   "\6\73\1\227\17\73\1\255\33\73\1\0\6\73\1\257"+
   "\6\73\3\257\7\73\1\257\6\73\1\257\3\73\1\257"+
   "\3\73\1\257\3\73\1\257\7\73\1\0\4\73\12\0"+
   "\1\260\61\0\1\261\52\0\2\105\1\0\2\105\3\0"+
   "\4\105\3\0\2\105\1\162\3\105\1\163\5\105\1\0"+
   "\14\105\14\0\1\237\6\0\3\237\6\0\1\235\1\237"+
   "\6\0\1\237\3\0\1\237\3\0\1\237\3\0\1\237"+
   "\14\0\12\45\1\262\4\45\1\0\31\45\1\0\2\45"+
   "\1\0\6\45\12\52\1\263\4\52\1\0\32\52\1\0"+
   "\1\52\1\0\6\52\1\0\2\57\1\0\2\57\3\0"+
   "\4\57\3\0\2\57\1\0\11\57\1\0\13\57\1\264"+
   "\13\0\2\57\1\0\2\57\3\0\4\57\3\0\2\57"+
   "\1\0\11\57\1\0\5\57\1\265\6\57\12\0\12\66"+
   "\1\266\43\66\2\0\4\66\2\141\1\66\2\141\3\66"+
   "\4\141\3\66\2\141\1\207\3\141\1\210\5\141\1\66"+
   "\14\141\5\66\2\0\5\66\1\252\6\66\3\252\6\66"+
   "\1\250\1\252\6\66\1\252\3\66\1\252\3\66\1\252"+
   "\3\66\1\252\7\66\2\0\3\66\12\73\1\267\43\73"+
   "\1\0\5\73\2\150\1\73\2\150\3\73\4\150\3\73"+
   "\2\150\1\221\3\150\1\222\5\150\1\73\14\150\5\73"+
   "\1\0\6\73\1\257\6\73\3\257\6\73\1\255\1\257"+
   "\6\73\1\257\3\73\1\257\3\73\1\257\3\73\1\257"+
   "\7\73\1\0\4\73\13\0\1\270\63\0\1\271\46\0"+
   "\13\45\1\272\3\45\1\0\31\45\1\0\2\45\1\0"+
   "\6\45\13\52\1\273\3\52\1\0\32\52\1\0\1\52"+
   "\1\0\6\52\1\0\2\57\1\0\2\57\3\0\1\274"+
   "\3\57\3\0\2\57\1\0\11\57\1\0\14\57\13\0"+
   "\2\57\1\0\2\57\3\0\4\57\3\0\2\57\1\0"+
   "\11\57\1\0\7\57\1\275\4\57\12\0\13\66\1\276"+
   "\42\66\2\0\3\66\13\73\1\277\42\73\1\0\4\73"+
   "\14\0\1\300\106\0\1\301\22\0\14\45\1\302\2\45"+
   "\1\0\31\45\1\0\2\45\1\0\6\45\14\52\1\303"+
   "\2\52\1\0\32\52\1\0\1\52\1\0\6\52\14\66"+
   "\1\304\41\66\2\0\3\66\14\73\1\305\41\73\1\0"+
   "\4\73\13\0\1\306\110\0\1\307\21\0\13\45\1\310"+
   "\3\45\1\0\31\45\1\0\2\45\1\0\6\45\13\52"+
   "\1\311\3\52\1\0\32\52\1\0\1\52\1\0\6\52"+
   "\13\66\1\312\42\66\2\0\3\66\13\73\1\313\42\73"+
   "\1\0\4\73\10\0\1\314\114\0\1\315\20\0\10\45"+
   "\1\316\6\45\1\0\31\45\1\0\2\45\1\0\6\45"+
   "\10\52\1\317\6\52\1\0\32\52\1\0\1\52\1\0"+
   "\6\52\10\66\1\320\45\66\2\0\3\66\10\73\1\321"+
   "\45\73\1\0\4\73";

 private static int [] zzUnpackTrans() {
   int [] result = new int[8262];
   int offset = 0;
   offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackTrans(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     value--;
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }


 /* error codes */
 private static final int ZZ_UNKNOWN_ERROR = 0;
 private static final int ZZ_NO_MATCH = 1;
 private static final int ZZ_PUSHBACK_2BIG = 2;
 private static final char[] EMPTY_BUFFER = new char[0];
 private static final int YYEOF = -1;

 /* error messages for the codes above */
 private static final String ZZ_ERROR_MSG[] = {
   "Unkown internal scanner error",
   "Error: could not match input",
   "Error: pushback value was too large"
 };

 /**
  * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
  */
 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

 private static final String ZZ_ATTRIBUTE_PACKED_0 =
   "\1\1\2\0\1\1\3\0\2\1\2\0\3\1\1\0"+
   "\6\1\1\11\2\1\1\11\3\1\1\0\1\1\1\11"+
   "\2\1\3\11\3\1\1\11\10\1\1\11\10\1\1\11"+
   "\3\1\3\11\1\1\1\0\2\11\6\0\1\11\1\1"+
   "\1\0\1\11\2\0\2\1\1\11\2\1\2\11\1\0"+
   "\1\11\1\0\2\1\1\0\1\11\1\0\16\1\4\0"+
   "\1\11\11\0\1\11\2\1\1\0\2\1\1\0\26\1"+
   "\2\11\2\0\1\11\2\0\20\1\2\0\6\1\2\0"+
   "\6\1\2\0\4\1\2\0\4\1\2\11\4\1";

 private static int [] zzUnpackAttribute() {
   int [] result = new int[209];
   int offset = 0;
   offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
   return result;
 }

 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
   int i = 0;       /* index in packed string  */
   int j = offset;  /* index in unpacked array */
   int l = packed.length();
   while (i < l) {
     int count = packed.charAt(i++);
     int value = packed.charAt(i++);
     do result[j++] = value; while (--count > 0);
   }
   return j;
 }

 /** the current state of the DFA */
 private int zzState;

 /** the current lexical state */
 private int zzLexicalState = YYINITIAL;

 /** this buffer contains the current text to be matched and is
     the source of the yytext() string */
 private char zzBuffer[] = EMPTY_BUFFER;

 /** the textposition at the last accepting state */
 private int zzMarkedPos;

 /** the textposition at the last state to be included in yytext */
 private int zzPushbackPos;

 /** the current text position in the buffer */
 private int zzCurrentPos;

 /** startRead marks the beginning of the yytext() string in the buffer */
 private int zzStartRead;

 /** endRead marks the last character in the buffer, that has been read
     from input */
 private int zzEndRead;

 /**
  * zzAtBOL == true <=> the scanner is currently at the beginning of a line
  */
 private boolean zzAtBOL = true;

 /** zzAtEOF == true <=> the scanner is at the EOF */
 private boolean zzAtEOF;

 /** denotes if the user-EOF-code has already been executed */
 private boolean zzEOFDone;

 /* user code: */
 private boolean elEnabled;
 private IElementType elStartType = XmlTokenType.XML_DATA_CHARACTERS;
 private IElementType elEndType = XmlTokenType.XML_DATA_CHARACTERS;
 private IElementType elValueType = XmlTokenType.XML_DATA_CHARACTERS;

 public void setElTypes(IElementType _elStartType,IElementType _elValueType,IElementType _elEndType) {
   elStartType = _elStartType;
   elEndType = _elEndType;
   elValueType = _elValueType;
   elEnabled = true;
 }

 private IElementType myTokenType;
 private int myPrevState = YYINITIAL;
 private int myState = YYINITIAL;

 public _XmlLexer(){
   this((java.io.Reader)null);
 }

 public final void start(char[] buffer){
   start(buffer, 0, buffer.length);
 }

 public final void start(char[] buffer, int startOffset, int endOffset){
   start(buffer, startOffset, endOffset, (short)YYINITIAL);
 }

 public final void start(char[] buffer, int startOffset, int endOffset, int initialState){
   zzBuffer = buffer;
   zzCurrentPos = zzMarkedPos = zzStartRead = startOffset;
   zzPushbackPos = 0;
   zzAtEOF  = false;
   zzEndRead = endOffset;
   myTokenType = null;
   yybegin(initialState & 15);
   myPrevState = (initialState >> 4) & 15;
   packState();
 }

 public final int getState(){
   return myState;
 }

 private void packState() {
   myState = ((myPrevState & 15) << 4) | (zzLexicalState & 15);
 }

 public final int getLastState() {
   return 14;
 }

 public final IElementType getTokenType(){
   locateToken();
   return myTokenType;
 }

 public final int getTokenStart(){
   locateToken();
   return zzStartRead - zzPushbackPos;
 }

 public final int getTokenEnd(){
   return getTokenStart() + yylength();
 }

 public final void advance(){
   locateToken();
   myTokenType = null;
   packState();
 }

 public final char[] getBuffer(){
   return zzBuffer;
 }

 public final int getBufferEnd(){
   return zzEndRead;
 }

 protected final void locateToken(){
   if (myTokenType != null) return;
   try{
   _locateToken();
   }
   catch(java.io.IOException ioe){}
 }

 public int getSmartUpdateShift() {
   return 10;
 }

 private int popState(){
   final int prev = myPrevState;
   myPrevState = YYINITIAL;
   return prev;
 }

 private void pushState(int state){
   myPrevState = state;
 }

 public Object clone() {
   try{
     return super.clone();
   }
   catch(CloneNotSupportedException e){
     return null;
   }
 }


 /**
  * Creates a new scanner
  * There is also a java.io.InputStream version of this constructor.
  *
  * @param   in  the java.io.Reader to read input from.
  */
 public _XmlLexer(java.io.Reader in) {
     myTokenType = null;
 }

 /**
  * Creates a new scanner.
  * There is also java.io.Reader version of this constructor.
  *
  * @param   in  the java.io.Inputstream to read input from.
  */
 public _XmlLexer(java.io.InputStream in) {
   this(new java.io.InputStreamReader(in));
 }

 /**
  * Unpacks the compressed character translation table.
  *
  * @param packed   the packed character translation table
  * @return         the unpacked character translation table
  */
 private static char [] zzUnpackCMap(String packed) {
   char [] map = new char[0x10000];
   int i = 0;  /* index in packed string  */
   int j = 0;  /* index in unpacked array */
   while (i < 148) {
     int  count = packed.charAt(i++);
     char value = packed.charAt(i++);
     do map[j++] = value; while (--count > 0);
   }
   return map;
 }


 /**
  * Refills the input buffer.
  *
  * @return      <code>false</code>, iff there was new input.
  *
  * @exception   java.io.IOException  if any I/O-Error occurs
  */
 private boolean zzRefill() throws java.io.IOException {
   return true;
 }


 /**
  * Closes the input stream.
  */
 public final void yyclose() throws java.io.IOException {
   zzAtEOF = true;            /* indicate end of file */
   zzEndRead = zzStartRead;  /* invalidate buffer    */
 }


 /**
  * Resets the scanner to read from a new input stream.
  * Does not close the old reader.
  *
  * All internal variables are reset, the old input stream
  * <b>cannot</b> be reused (internal buffer is discarded and lost).
  * Lexical state is set to <tt>ZZ_INITIAL</tt>.
  *
  * @param reader   the new input stream
  */
 public final void yyreset(java.io.Reader reader) {
   zzAtBOL  = true;
   zzAtEOF  = false;
   zzEndRead = zzStartRead = 0;
   zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
   zzLexicalState = YYINITIAL;
 }


 /**
  * Returns the current lexical state.
  */
 public final int yystate() {
   return zzLexicalState;
 }


 /**
  * Enters a new lexical state
  *
  * @param newState the new lexical state
  */
 public final void yybegin(int newState) {
   zzLexicalState = newState;
 }


 /**
  * Returns the text matched by the current regular expression.
  */
 public final String yytext() {
   return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
 }


 /**
  * Returns the character at position <tt>pos</tt> from the
  * matched text.
  *
  * It is equivalent to yytext().charAt(pos), but faster
  *
  * @param pos the position of the character to fetch.
  *            A value from 0 to yylength()-1.
  *
  * @return the character at position pos
  */
 public final char yycharat(int pos) {
   return zzBuffer[zzStartRead+pos];
 }


 /**
  * Returns the length of the matched text region.
  */
 public final int yylength() {
   return zzMarkedPos-zzStartRead;
 }


 /**
  * Reports an error that occured while scanning.
  *
  * In a wellformed scanner (no or only correct usage of
  * yypushback(int) and a match-all fallback rule) this method
  * will only be called with things that "Can't Possibly Happen".
  * If this method is called, something is seriously wrong
  * (e.g. a JFlex bug producing a faulty scanner etc.).
  *
  * Usual syntax/scanner level error handling should be done
  * in error fallback rules.
  *
  * @param   errorCode  the code of the errormessage to display
  */
 private void zzScanError(int errorCode) {
   String message;
   try {
     message = ZZ_ERROR_MSG[errorCode];
   }
   catch (ArrayIndexOutOfBoundsException e) {
     message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
   }

   throw new Error(message);
 }


 /**
  * Pushes the specified amount of characters back into the input stream.
  *
  * They will be read again by then next call of the scanning method
  *
  * @param number  the number of characters to be read again.
  *                This number must not be greater than yylength()!
  */
 public void yypushback(int number)  {
   if ( number > yylength() )
     zzScanError(ZZ_PUSHBACK_2BIG);

   zzMarkedPos -= number;
 }


 /**
  * Contains user EOF-code, which will be executed exactly once,
  * when the end of file is reached
  */
 private void zzDoEOF() {
   if (!zzEOFDone) {
     zzEOFDone = true;

   }
 }


 /**
  * Resumes scanning until the next regular expression is matched,
  * the end of input is encountered or an I/O-Error occurs.
  *
  * @return      the next token
  * @exception   java.io.IOException  if any I/O-Error occurs
  */
 public void _locateToken() throws java.io.IOException {
   int zzInput;
   int zzAction;

   // cached fields:
   int zzCurrentPosL;
   int zzMarkedPosL;
   int zzEndReadL = zzEndRead;
   char [] zzBufferL = zzBuffer;
   char [] zzCMapL = ZZ_CMAP;

   int [] zzTransL = ZZ_TRANS;
   int [] zzRowMapL = ZZ_ROWMAP;
   int [] zzAttrL = ZZ_ATTRIBUTE;

   while (true) {
     zzMarkedPosL = zzMarkedPos;

     zzAction = -1;

     zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

     zzState = zzLexicalState;


     zzForAction: {
       while (true) {

         if (zzCurrentPosL < zzEndReadL)
           zzInput = zzBufferL[zzCurrentPosL++];
         else if (zzAtEOF) {
           zzInput = YYEOF;
           break zzForAction;
         }
         else {
           // store back cached positions
           zzCurrentPos  = zzCurrentPosL;
           zzMarkedPos   = zzMarkedPosL;
           boolean eof = zzRefill();
           // get translated positions and possibly new buffer
           zzCurrentPosL  = zzCurrentPos;
           zzMarkedPosL   = zzMarkedPos;
           zzBufferL      = zzBuffer;
           zzEndReadL     = zzEndRead;
           if (eof) {
             zzInput = YYEOF;
             break zzForAction;
           }
           else {
             zzInput = zzBufferL[zzCurrentPosL++];
           }
         }
         int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
         if (zzNext == -1) break zzForAction;
         zzState = zzNext;

         int zzAttributes = zzAttrL[zzState];
         if ( (zzAttributes & 1) == 1 ) {
           zzAction = zzState;
           zzMarkedPosL = zzCurrentPosL;
           if ( (zzAttributes & 8) == 8 ) break zzForAction;
         }

       }
     }

     // store back cached position
     zzMarkedPos = zzMarkedPosL;

     switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
       case 39:
         { myTokenType = XmlTokenType.XML_DOCTYPE_START; yybegin(DOCTYPE); return;
         }
       case 40: break;
       case 5:
         { myTokenType = XmlTokenType.XML_WHITE_SPACE; return;
         }
       case 41: break;
       case 32:
         { myTokenType = XmlTokenType.XML_COMMENT_END; yybegin(YYINITIAL); return;
         }
       case 42: break;
       case 26:
         { myTokenType = XmlTokenType.XML_EMPTY_ELEMENT_END; yybegin(YYINITIAL); return;
         }
       case 43: break;
       case 38:
         { myTokenType = XmlTokenType.XML_CDATA_START; yybegin(CDATA); return;
         }
       case 44: break;
       case 7:
         { if(yystate() == YYINITIAL){
       myTokenType = XmlTokenType.XML_BAD_CHARACTER;
       return;
     }
     else yybegin(popState()); yypushback(yylength());
         }
       case 45: break;
       case 37:
         { myTokenType = XmlTokenType.XML_DOCTYPE_SYSTEM;  return;
         }
       case 46: break;
       case 23:
         { myTokenType = XmlTokenType.XML_PI_START; yybegin(PROCESSING_INSTRUCTION); return;
         }
       case 47: break;
       case 4:
         { myTokenType = elValueType; return;
         }
       case 48: break;
       case 18:
         { myTokenType = XmlTokenType.XML_NAME;  return;
         }
       case 49: break;
       case 13:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER; yybegin(ATTR_VALUE_DQ); return;
         }
       case 50: break;
       case 24:
         { myTokenType = XmlTokenType.XML_END_TAG_START; yybegin(END_TAG); return;
         }
       case 51: break;
       case 2:
         { myTokenType = XmlTokenType.XML_COMMENT_CHARACTERS; return;
         }
       case 52: break;
       case 20:
         { myTokenType = elEndType; yybegin(YYINITIAL); return;
         }
       case 53: break;
       case 14:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER; yybegin(ATTR_VALUE_SQ); return;
         }
       case 54: break;
       case 34:
         { myTokenType = XmlTokenType.XML_COMMENT_START; yybegin(COMMENT); return;
         }
       case 55: break;
       case 10:
         { myTokenType = XmlTokenType.XML_NAME; return;
         }
       case 56: break;
       case 27:
         { if (elEnabled) {
   myTokenType = elStartType;
   yybegin(EL_ATTR_VALUE);
 } else {
   myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
 }
 return;
         }
       case 57: break;
       case 30:
         { myTokenType = XmlTokenType.XML_MARKUP; return;
         }
       case 58: break;
       case 28:
         { if (elEnabled) {
   myTokenType = elStartType;
   yybegin(EL_ATTR_VALUE2);
 } else {
   myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
 }
 return;
         }
       case 59: break;
       case 6:
         { myTokenType = XmlTokenType.XML_START_TAG_START; yybegin(TAG); return;
         }
       case 60: break;
       case 17:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR_LIST); pushState(PROCESSING_INSTRUCTION); return;
         }
       case 61: break;
       case 25:
         { if (elEnabled) {
   myTokenType = elStartType; yybegin(EL);
 } else {
   myTokenType = XmlTokenType.XML_DATA_CHARACTERS;
 }
 return;
         }
       case 62: break;
       case 1:
         { myTokenType = XmlTokenType.XML_DATA_CHARACTERS; return;
         }
       case 63: break;
       case 15:
         { myTokenType = XmlTokenType.XML_EQ; return;
         }
       case 64: break;
       case 8:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR_LIST); pushState(TAG); return;
         }
       case 65: break;
       case 12:
         { yybegin(ATTR_LIST); yypushback(yylength());
         }
       case 66: break;
       case 19:
         { myTokenType = XmlTokenType.XML_DOCTYPE_END;  yybegin(YYINITIAL); return;
         }
       case 67: break;
       case 36:
         { myTokenType = XmlTokenType.XML_DOCTYPE_PUBLIC;  return;
         }
       case 68: break;
       case 35:
         { myTokenType = XmlTokenType.XML_CHAR_ENTITY_REF; return;
         }
       case 69: break;
       case 11:
         { myTokenType = XmlTokenType.XML_NAME; yybegin(ATTR); return;
         }
       case 70: break;
       case 9:
         { myTokenType = XmlTokenType.XML_TAG_END; yybegin(YYINITIAL); return;
         }
       case 71: break;
       case 31:
         { myTokenType = XmlTokenType.XML_ENTITY_REF_TOKEN; return;
         }
       case 72: break;
       case 21:
         { myTokenType = elEndType; yybegin(ATTR_VALUE_DQ); return;
         }
       case 73: break;
       case 29:
         { myTokenType = XmlTokenType.XML_PI_END; yybegin(YYINITIAL); return;
         }
       case 74: break;
       case 22:
         { myTokenType = elEndType; yybegin(ATTR_VALUE_SQ); return;
         }
       case 75: break;
       case 33:
         { myTokenType = XmlTokenType.XML_CDATA_END; yybegin(YYINITIAL); return;
         }
       case 76: break;
       case 16:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER; yybegin(ATTR_LIST); return;
         }
       case 77: break;
       case 3:
         { myTokenType = XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN; return;
         }
       case 78: break;
       default:
         if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
           zzAtEOF = true;
           zzDoEOF();
           return;
         }
         else {
           zzScanError(ZZ_NO_MATCH);
         }
     }
   }
 }


 }
